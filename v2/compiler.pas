{ TuxPascal v2 - Self-hosting Pascal Compiler }
{ Written in Pascal, compiled by v1 }
{ Generated by merging include files }

program TuxPascalV2;

const
  MAX_TOKENS = 1000;
  MAX_SYMBOLS = 100;
  MAX_STRINGS = 64;
  MAX_NAME = 32;

  { Token types }
  TOK_EOF = 0;
  TOK_IDENT = 1;
  TOK_INTEGER = 2;
  TOK_STRING = 3;
  TOK_PLUS = 4;
  TOK_MINUS = 5;
  TOK_STAR = 6;
  TOK_SLASH = 7;
  TOK_EQ = 8;
  TOK_NEQ = 9;
  TOK_LT = 10;
  TOK_GT = 11;
  TOK_LE = 12;
  TOK_GE = 13;
  TOK_LPAREN = 14;
  TOK_RPAREN = 15;
  TOK_LBRACKET = 16;
  TOK_RBRACKET = 17;
  TOK_ASSIGN = 18;
  TOK_COLON = 19;
  TOK_SEMICOLON = 20;
  TOK_COMMA = 21;
  TOK_DOT = 22;
  TOK_DOTDOT = 23;
  TOK_CARET = 24;    { ^ - dereference/pointer type }
  TOK_AT = 25;       { @ - address-of }

  { Keywords - starting at 100 }
  TOK_PROGRAM = 100;
  TOK_BEGIN = 101;
  TOK_END = 102;
  TOK_VAR = 103;
  TOK_CONST = 104;
  TOK_PROCEDURE = 105;
  TOK_FUNCTION = 106;
  TOK_IF = 107;
  TOK_THEN = 108;
  TOK_ELSE = 109;
  TOK_WHILE = 110;
  TOK_DO = 111;
  TOK_REPEAT = 112;
  TOK_UNTIL = 113;
  TOK_FOR = 114;
  TOK_TO = 115;
  TOK_DOWNTO = 116;
  TOK_ARRAY = 117;
  TOK_OF = 118;
  TOK_DIV = 119;
  TOK_MOD = 120;
  TOK_AND = 121;
  TOK_OR = 122;
  TOK_NOT = 123;
  TOK_TRUE = 124;
  TOK_FALSE = 125;
  TOK_INTEGER_TYPE = 126;
  TOK_CHAR_TYPE = 127;
  TOK_BOOLEAN_TYPE = 128;
  TOK_STRING_TYPE = 129;
  TOK_FORWARD = 130;
  TOK_READ = 131;
  TOK_READLN = 132;
  TOK_REAL_TYPE = 133;
  TOK_FLOAT_LITERAL = 134;
  TOK_NIL = 135;     { nil keyword }
  TOK_RECORD = 136;  { record keyword }
  TOK_TYPE_KW = 137;    { type keyword }
  TOK_CASE = 138;    { case keyword }
  TOK_WITH = 139;    { with keyword }

  { Symbol kinds }
  SYM_VAR = 0;
  SYM_CONST = 1;
  SYM_PROCEDURE = 2;
  SYM_FUNCTION = 3;
  SYM_PARAM = 4;
  SYM_TYPEDEF = 5;       { type definition (for records) }

  { Type kinds }
  TYPE_INTEGER = 0;
  TYPE_CHAR = 1;
  TYPE_BOOLEAN = 2;
  TYPE_STRING = 3;
  TYPE_ARRAY = 4;
  TYPE_VOID = 5;
  TYPE_REAL = 6;
  TYPE_POINTER = 7;
  TYPE_RECORD = 8;

var
  { Source input }
  ch: integer;
  line_num, col_num: integer;
  pushback_ch: integer;  { -1 means no pushback }

  { Current token }
  tok_type: integer;
  tok_int: integer;
  tok_str: array[0..255] of integer;  { string as array of chars }
  tok_len: integer;

  { Symbol table - flattened 2D array: sym_name[idx * 32 + char_pos] }
  sym_name: array[0..15999] of integer;  { 500 symbols * 32 chars each }
  sym_kind: array[0..499] of integer;
  sym_type: array[0..499] of integer;
  sym_level: array[0..499] of integer;
  sym_offset: array[0..499] of integer;
  sym_const_val: array[0..499] of integer;
  sym_label: array[0..499] of integer;
  sym_is_var_param: array[0..499] of integer;  { 1 if var parameter (pass by ref) }
  sym_var_param_flags: array[0..499] of integer;  { bitmap: bit i = 1 if param i is var (for proc/func) }
  sym_count: integer;

  { Record field table }
  field_name: array[0..6399] of integer;   { 200 fields * 32 chars each }
  field_type: array[0..199] of integer;    { type of each field }
  field_offset: array[0..199] of integer;  { offset within record }
  field_rec_idx: array[0..199] of integer; { which record type this field belongs to }
  field_count: integer;                    { total fields defined }

  { Scope tracking }
  scope_level: integer;
  local_offset: integer;

  { Code generation }
  label_count: integer;

  { String table - not used yet, simplified }
  string_count: integer;

  { Runtime labels }
  rt_print_int: integer;
  rt_newline: integer;
  rt_readchar: integer;
  rt_print_char: integer;
  rt_read_int: integer;
  rt_skip_line: integer;
  rt_print_string: integer;
  rt_print_real: integer;
  rt_read_real: integer;
  rt_read_string: integer;

  { Float literal parsing }
  tok_float_int: integer;   { integer part of float }
  tok_float_frac: integer;  { fractional part (scaled by 1000000) }
  tok_float_neg: integer;   { 1 if negative }

  { Expression type tracking }
  expr_type: integer;

  { Pointer base type tracking for arithmetic }
  ptr_base_type: integer;

  { Output file descriptor - x20 is used to store it }
  out_fd: integer;

  { Error flag }
  had_error: integer;

  { WITH statement tracking }
  with_rec_idx: integer;    { symbol index of active with record, -1 if none }
  with_rec_type: integer;   { type index for field lookup }

  { Runtime labels for heap }
  rt_heap_init: integer;

  { Runtime labels for string operations }
  rt_str_copy: integer;
  rt_str_compare: integer;
  rt_str_concat: integer;
  rt_str_cmp: integer;  { lexicographic compare: returns -1, 0, or 1 }
  rt_str_pos: integer;  { find substring: returns position or 0 }
  rt_str_delete: integer;  { delete chars from string in place }
  rt_str_insert: integer;  { insert string into another }
  rt_int_to_str: integer;  { convert integer to string }
  rt_str_to_int: integer;  { convert string to integer with error code }
  rt_str_ltrim: integer;  { trim leading whitespace }
  rt_str_rtrim: integer;  { trim trailing whitespace }
  rt_str_trim: integer;   { trim both leading and trailing whitespace }

  { Runtime labels for screen/terminal control }
  rt_clrscr: integer;     { clear screen and home cursor }
  rt_gotoxy: integer;     { move cursor to x,y position }
  rt_clreol: integer;     { clear to end of line }
  rt_textcolor: integer;  { set foreground color }
  rt_textbackground: integer;  { set background color }
  rt_normvideo: integer;  { reset attributes }
  rt_highvideo: integer;  { bold/bright }
  rt_lowvideo: integer;   { dim }
  rt_hidecursor: integer; { hide cursor }
  rt_showcursor: integer; { show cursor }
  rt_sleep: integer;      { sleep for N milliseconds using nanosleep syscall }
  rt_keypressed: integer; { check if key available (non-blocking) }
  rt_initkeyboard: integer;  { set terminal to raw mode }
  rt_donekeyboard: integer;  { restore terminal to cooked mode }

  { Saved terminal settings for restore }
  saved_termios: array[0..79] of integer;  { 80 bytes for termios struct }

  { String temp index (0-3) for copy/concat results }
  string_temp_idx: integer;

{ ----- Utility ----- }

procedure Error(msg: integer);
var
  i: integer;
begin
  write('Error ');
  write(msg);
  write(' at line ');
  write(line_num);
  write(' tok_type=');
  write(tok_type);
  write(' tok_len=');
  write(tok_len);
  write(' scope=');
  write(scope_level);
  write(' offset=');
  write(local_offset);
  write(' sym_count=');
  write(sym_count);
  write(' ch=');
  write(ch);
  write(' tok=');
  for i := 0 to tok_len - 1 do
    writechar(tok_str[i]);
  writeln(0);
  halt(1)
end;

function IsDigit(c: integer): integer;
begin
  if (c >= 48) and (c <= 57) then
    IsDigit := 1
  else
    IsDigit := 0
end;

function IsAlpha(c: integer): integer;
begin
  if ((c >= 65) and (c <= 90)) or ((c >= 97) and (c <= 122)) or (c = 95) then
    IsAlpha := 1
  else
    IsAlpha := 0
end;

function ToLower(c: integer): integer;
begin
  if (c >= 65) and (c <= 90) then
    ToLower := c + 32
  else
    ToLower := c
end;

function StrEqual(idx: integer): integer;
var
  i: integer;
  match: integer;
  base: integer;
  c1, c2: integer;
begin
  { Compare tok_str with sym_name[idx] }
  { sym_name is flattened: base = idx * 32 }
  base := idx * 32;
  match := 1;
  i := 0;
  while (i < tok_len) and (match = 1) do
  begin
    c1 := tok_str[i];
    c2 := sym_name[base + i];
    if ToLower(c1) <> ToLower(c2) then
      match := 0;
    i := i + 1
  end;
  if match = 1 then
    if sym_name[base + tok_len] <> 0 then
      match := 0;
  StrEqual := match
end;

{ Check if current token matches a string (case insensitive) }
{ s1-s8 are ASCII codes of the expected string, 0 marks end }
function TokIs8(s1, s2, s3, s4, s5, s6, s7, s8: integer): integer;
var
  i, match, slen: integer;
  s: array[0..7] of integer;
begin
  s[0] := s1; s[1] := s2; s[2] := s3; s[3] := s4;
  s[4] := s5; s[5] := s6; s[6] := s7; s[7] := s8;
  { Find length of expected string }
  slen := 0;
  while (slen < 8) and (s[slen] <> 0) do
    slen := slen + 1;
  { Check length match }
  if tok_len <> slen then
    match := 0
  else
  begin
    match := 1;
    i := 0;
    while (i < slen) and (match = 1) do
    begin
      if ToLower(tok_str[i]) <> ToLower(s[i]) then
        match := 0;
      i := i + 1
    end
  end;
  TokIs8 := match
end;

{ ----- Lexer ----- }

procedure NextChar;
begin
  if pushback_ch >= 0 then
  begin
    ch := pushback_ch;
    pushback_ch := -1
  end
  else
  begin
    ch := readchar;
    if ch = 10 then
    begin
      line_num := line_num + 1;
      col_num := 0
    end
    else
      col_num := col_num + 1
  end
end;

procedure SkipWhitespace;
begin
  while (ch = 32) or (ch = 9) or (ch = 10) or (ch = 13) do
    NextChar;
  { Skip comments }
  if ch = 123 then  { '{' }
  begin
    while (ch <> 125) and (ch <> -1) do
      NextChar;
    if ch = 125 then
      NextChar;
    SkipWhitespace
  end
end;

procedure NextToken;
var
  i: integer;
begin
  SkipWhitespace;

  if ch = -1 then
  begin
    tok_type := TOK_EOF;
    tok_len := 0
  end
  else if IsDigit(ch) = 1 then
  begin
    tok_type := TOK_INTEGER;
    tok_int := 0;
    while IsDigit(ch) = 1 do
    begin
      tok_int := tok_int * 10 + (ch - 48);
      NextChar
    end;
    { Check for decimal point (but not ..) }
    if ch = 46 then  { '.' }
    begin
      NextChar;
      if IsDigit(ch) = 1 then
      begin
        { This is a float literal }
        tok_type := TOK_FLOAT_LITERAL;
        tok_float_int := tok_int;
        tok_float_frac := 0;
        tok_float_neg := 0;
        { Parse fractional digits (up to 6 digits of precision) }
        i := 0;
        while (IsDigit(ch) = 1) and (i < 6) do
        begin
          tok_float_frac := tok_float_frac * 10 + (ch - 48);
          i := i + 1;
          NextChar
        end;
        { Scale frac to 6 digits }
        while i < 6 do
        begin
          tok_float_frac := tok_float_frac * 10;
          i := i + 1
        end;
        { Skip any remaining fractional digits }
        while IsDigit(ch) = 1 do
          NextChar
      end
      else
      begin
        { It was just an integer followed by '.', push back current char }
        { and set pushback to '.' so next NextToken gets DOT or DOTDOT }
        pushback_ch := ch;
        ch := 46  { Put '.' back as current so the DOT handling code gets it }
      end
    end
  end
  else if IsAlpha(ch) = 1 then
  begin
    tok_type := TOK_IDENT;
    tok_len := 0;
    while (IsAlpha(ch) = 1) or (IsDigit(ch) = 1) do
    begin
      if tok_len < 255 then
      begin
        tok_str[tok_len] := ch;
        tok_len := tok_len + 1
      end;
      NextChar
    end;
    tok_str[tok_len] := 0;

    { Check for keywords }
    { This is simplified - would need proper keyword table }
    if tok_len = 7 then
      if (ToLower(tok_str[0]) = 112) and (ToLower(tok_str[1]) = 114) then { pr }
        if (ToLower(tok_str[2]) = 111) and (ToLower(tok_str[3]) = 103) then { og }
          if (ToLower(tok_str[4]) = 114) and (ToLower(tok_str[5]) = 97) then { ra }
            if ToLower(tok_str[6]) = 109 then { m }
              tok_type := TOK_PROGRAM;
    if tok_len = 5 then
      if (ToLower(tok_str[0]) = 98) and (ToLower(tok_str[1]) = 101) then { be }
        if (ToLower(tok_str[2]) = 103) and (ToLower(tok_str[3]) = 105) then { gi }
          if ToLower(tok_str[4]) = 110 then { n }
            tok_type := TOK_BEGIN;
    if tok_len = 3 then
    begin
      if (ToLower(tok_str[0]) = 101) and (ToLower(tok_str[1]) = 110) then { en }
        if ToLower(tok_str[2]) = 100 then { d }
          tok_type := TOK_END;
      if (ToLower(tok_str[0]) = 118) and (ToLower(tok_str[1]) = 97) then { va }
        if ToLower(tok_str[2]) = 114 then { r }
          tok_type := TOK_VAR;
      if (ToLower(tok_str[0]) = 100) and (ToLower(tok_str[1]) = 105) then { di }
        if ToLower(tok_str[2]) = 118 then { v }
          tok_type := TOK_DIV;
      if (ToLower(tok_str[0]) = 109) and (ToLower(tok_str[1]) = 111) then { mo }
        if ToLower(tok_str[2]) = 100 then { d }
          tok_type := TOK_MOD;
      if (ToLower(tok_str[0]) = 97) and (ToLower(tok_str[1]) = 110) then { an }
        if ToLower(tok_str[2]) = 100 then { d }
          tok_type := TOK_AND;
      if (ToLower(tok_str[0]) = 110) and (ToLower(tok_str[1]) = 111) then { no }
        if ToLower(tok_str[2]) = 116 then { t }
          tok_type := TOK_NOT;
      if (ToLower(tok_str[0]) = 102) and (ToLower(tok_str[1]) = 111) then { fo }
        if ToLower(tok_str[2]) = 114 then { r }
          tok_type := TOK_FOR;
      if (ToLower(tok_str[0]) = 110) and (ToLower(tok_str[1]) = 105) then { ni }
        if ToLower(tok_str[2]) = 108 then { l }
          tok_type := TOK_NIL
    end;
    if tok_len = 2 then
    begin
      if (ToLower(tok_str[0]) = 105) and (ToLower(tok_str[1]) = 102) then { if }
        tok_type := TOK_IF;
      if (ToLower(tok_str[0]) = 100) and (ToLower(tok_str[1]) = 111) then { do }
        tok_type := TOK_DO;
      if (ToLower(tok_str[0]) = 116) and (ToLower(tok_str[1]) = 111) then { to }
        tok_type := TOK_TO;
      if (ToLower(tok_str[0]) = 111) and (ToLower(tok_str[1]) = 114) then { or }
        tok_type := TOK_OR;
      if (ToLower(tok_str[0]) = 111) and (ToLower(tok_str[1]) = 102) then { of }
        tok_type := TOK_OF
    end;
    if tok_len = 4 then
    begin
      if (ToLower(tok_str[0]) = 116) and (ToLower(tok_str[1]) = 104) then { th }
        if (ToLower(tok_str[2]) = 101) and (ToLower(tok_str[3]) = 110) then { en }
          tok_type := TOK_THEN;
      if (ToLower(tok_str[0]) = 101) and (ToLower(tok_str[1]) = 108) then { el }
        if (ToLower(tok_str[2]) = 115) and (ToLower(tok_str[3]) = 101) then { se }
          tok_type := TOK_ELSE;
      if (ToLower(tok_str[0]) = 116) and (ToLower(tok_str[1]) = 114) then { tr }
        if (ToLower(tok_str[2]) = 117) and (ToLower(tok_str[3]) = 101) then { ue }
          tok_type := TOK_TRUE
    end;
    if tok_len = 5 then
    begin
      if (ToLower(tok_str[0]) = 99) and (ToLower(tok_str[1]) = 111) then { co }
        if (ToLower(tok_str[2]) = 110) and (ToLower(tok_str[3]) = 115) then { ns }
          if ToLower(tok_str[4]) = 116 then { t }
            tok_type := TOK_CONST;
      if (ToLower(tok_str[0]) = 119) and (ToLower(tok_str[1]) = 104) then { wh }
        if (ToLower(tok_str[2]) = 105) and (ToLower(tok_str[3]) = 108) then { il }
          if ToLower(tok_str[4]) = 101 then { e }
            tok_type := TOK_WHILE;
      if (ToLower(tok_str[0]) = 117) and (ToLower(tok_str[1]) = 110) then { un }
        if (ToLower(tok_str[2]) = 116) and (ToLower(tok_str[3]) = 105) then { ti }
          if ToLower(tok_str[4]) = 108 then { l }
            tok_type := TOK_UNTIL;
      if (ToLower(tok_str[0]) = 97) and (ToLower(tok_str[1]) = 114) then { ar }
        if (ToLower(tok_str[2]) = 114) and (ToLower(tok_str[3]) = 97) then { ra }
          if ToLower(tok_str[4]) = 121 then { y }
            tok_type := TOK_ARRAY;
      if (ToLower(tok_str[0]) = 102) and (ToLower(tok_str[1]) = 97) then { fa }
        if (ToLower(tok_str[2]) = 108) and (ToLower(tok_str[3]) = 115) then { ls }
          if ToLower(tok_str[4]) = 101 then { e }
            tok_type := TOK_FALSE
    end;
    if tok_len = 6 then
    begin
      if (ToLower(tok_str[0]) = 114) and (ToLower(tok_str[1]) = 101) then { re }
        if (ToLower(tok_str[2]) = 112) and (ToLower(tok_str[3]) = 101) then { pe }
          if (ToLower(tok_str[4]) = 97) and (ToLower(tok_str[5]) = 116) then { at }
            tok_type := TOK_REPEAT;
      if (ToLower(tok_str[0]) = 100) and (ToLower(tok_str[1]) = 111) then { do }
        if (ToLower(tok_str[2]) = 119) and (ToLower(tok_str[3]) = 110) then { wn }
          if (ToLower(tok_str[4]) = 116) and (ToLower(tok_str[5]) = 111) then { to }
            tok_type := TOK_DOWNTO;
      if (ToLower(tok_str[0]) = 114) and (ToLower(tok_str[1]) = 101) then { re }
        if (ToLower(tok_str[2]) = 97) and (ToLower(tok_str[3]) = 100) then { ad }
          if (ToLower(tok_str[4]) = 108) and (ToLower(tok_str[5]) = 110) then { ln }
            tok_type := TOK_READLN;
      if (ToLower(tok_str[0]) = 115) and (ToLower(tok_str[1]) = 116) then { st }
        if (ToLower(tok_str[2]) = 114) and (ToLower(tok_str[3]) = 105) then { ri }
          if (ToLower(tok_str[4]) = 110) and (ToLower(tok_str[5]) = 103) then { ng }
            tok_type := TOK_STRING_TYPE;
      if (ToLower(tok_str[0]) = 114) and (ToLower(tok_str[1]) = 101) then { re }
        if (ToLower(tok_str[2]) = 99) and (ToLower(tok_str[3]) = 111) then { co }
          if (ToLower(tok_str[4]) = 114) and (ToLower(tok_str[5]) = 100) then { rd }
            tok_type := TOK_RECORD
    end;
    if tok_len = 7 then
    begin
      if (ToLower(tok_str[0]) = 105) and (ToLower(tok_str[1]) = 110) then { in }
        if (ToLower(tok_str[2]) = 116) and (ToLower(tok_str[3]) = 101) then { te }
          if (ToLower(tok_str[4]) = 103) and (ToLower(tok_str[5]) = 101) then { ge }
            if ToLower(tok_str[6]) = 114 then { r }
              tok_type := TOK_INTEGER_TYPE;
      if (ToLower(tok_str[0]) = 98) and (ToLower(tok_str[1]) = 111) then { bo }
        if (ToLower(tok_str[2]) = 111) and (ToLower(tok_str[3]) = 108) then { ol }
          if (ToLower(tok_str[4]) = 101) and (ToLower(tok_str[5]) = 97) then { ea }
            if ToLower(tok_str[6]) = 110 then { n }
              tok_type := TOK_BOOLEAN_TYPE;
      if (ToLower(tok_str[0]) = 102) and (ToLower(tok_str[1]) = 111) then { fo }
        if (ToLower(tok_str[2]) = 114) and (ToLower(tok_str[3]) = 119) then { rw }
          if (ToLower(tok_str[4]) = 97) and (ToLower(tok_str[5]) = 114) then { ar }
            if ToLower(tok_str[6]) = 100 then { d }
              tok_type := TOK_FORWARD
    end;
    if tok_len = 4 then
    begin
      if (ToLower(tok_str[0]) = 99) and (ToLower(tok_str[1]) = 104) then { ch }
        if (ToLower(tok_str[2]) = 97) and (ToLower(tok_str[3]) = 114) then { ar }
          tok_type := TOK_CHAR_TYPE;
      if (ToLower(tok_str[0]) = 114) and (ToLower(tok_str[1]) = 101) then { re }
        if (ToLower(tok_str[2]) = 97) and (ToLower(tok_str[3]) = 100) then { ad }
          tok_type := TOK_READ;
      if (ToLower(tok_str[0]) = 114) and (ToLower(tok_str[1]) = 101) then { re }
        if (ToLower(tok_str[2]) = 97) and (ToLower(tok_str[3]) = 108) then { al }
          tok_type := TOK_REAL_TYPE;
      if (ToLower(tok_str[0]) = 116) and (ToLower(tok_str[1]) = 121) then { ty }
        if (ToLower(tok_str[2]) = 112) and (ToLower(tok_str[3]) = 101) then { pe }
          tok_type := TOK_TYPE_KW;
      if (ToLower(tok_str[0]) = 99) and (ToLower(tok_str[1]) = 97) then { ca }
        if (ToLower(tok_str[2]) = 115) and (ToLower(tok_str[3]) = 101) then { se }
          tok_type := TOK_CASE;
      if (ToLower(tok_str[0]) = 119) and (ToLower(tok_str[1]) = 105) then { wi }
        if (ToLower(tok_str[2]) = 116) and (ToLower(tok_str[3]) = 104) then { th }
          tok_type := TOK_WITH
    end;
    if tok_len = 9 then
      if (ToLower(tok_str[0]) = 112) and (ToLower(tok_str[1]) = 114) then { pr }
        if (ToLower(tok_str[2]) = 111) and (ToLower(tok_str[3]) = 99) then { oc }
          if (ToLower(tok_str[4]) = 101) and (ToLower(tok_str[5]) = 100) then { ed }
            if (ToLower(tok_str[6]) = 117) and (ToLower(tok_str[7]) = 114) then { ur }
              if ToLower(tok_str[8]) = 101 then { e }
                tok_type := TOK_PROCEDURE;
    if tok_len = 8 then
      if (ToLower(tok_str[0]) = 102) and (ToLower(tok_str[1]) = 117) then { fu }
        if (ToLower(tok_str[2]) = 110) and (ToLower(tok_str[3]) = 99) then { nc }
          if (ToLower(tok_str[4]) = 116) and (ToLower(tok_str[5]) = 105) then { ti }
            if (ToLower(tok_str[6]) = 111) and (ToLower(tok_str[7]) = 110) then { on }
              tok_type := TOK_FUNCTION
  end
  else if ch = 39 then  { single quote - string }
  begin
    tok_type := TOK_STRING;
    tok_len := 0;
    NextChar;
    while (ch <> 39) and (ch <> -1) do
    begin
      if tok_len < 255 then
      begin
        tok_str[tok_len] := ch;
        tok_len := tok_len + 1
      end;
      NextChar
    end;
    tok_str[tok_len] := 0;
    if ch = 39 then
      NextChar
  end
  else if ch = 43 then  { + }
  begin
    tok_type := TOK_PLUS;
    NextChar
  end
  else if ch = 45 then  { - }
  begin
    tok_type := TOK_MINUS;
    NextChar
  end
  else if ch = 42 then  { * }
  begin
    tok_type := TOK_STAR;
    NextChar
  end
  else if ch = 47 then  { / }
  begin
    tok_type := TOK_SLASH;
    NextChar
  end
  else if ch = 61 then  { = }
  begin
    tok_type := TOK_EQ;
    NextChar
  end
  else if ch = 60 then  { < }
  begin
    NextChar;
    if ch = 62 then  { <> }
    begin
      tok_type := TOK_NEQ;
      NextChar
    end
    else if ch = 61 then  { <= }
    begin
      tok_type := TOK_LE;
      NextChar
    end
    else
      tok_type := TOK_LT
  end
  else if ch = 62 then  { > }
  begin
    NextChar;
    if ch = 61 then  { >= }
    begin
      tok_type := TOK_GE;
      NextChar
    end
    else
      tok_type := TOK_GT
  end
  else if ch = 40 then  { ( }
  begin
    tok_type := TOK_LPAREN;
    NextChar
  end
  else if ch = 41 then  { ) }
  begin
    tok_type := TOK_RPAREN;
    NextChar
  end
  else if ch = 91 then  { [ }
  begin
    tok_type := TOK_LBRACKET;
    NextChar
  end
  else if ch = 93 then  { ] }
  begin
    tok_type := TOK_RBRACKET;
    NextChar
  end
  else if ch = 58 then  { : }
  begin
    NextChar;
    if ch = 61 then  { := }
    begin
      tok_type := TOK_ASSIGN;
      NextChar
    end
    else
      tok_type := TOK_COLON
  end
  else if ch = 59 then  { ; }
  begin
    tok_type := TOK_SEMICOLON;
    NextChar
  end
  else if ch = 44 then  { , }
  begin
    tok_type := TOK_COMMA;
    NextChar
  end
  else if ch = 46 then  { . }
  begin
    NextChar;
    if ch = 46 then  { .. }
    begin
      tok_type := TOK_DOTDOT;
      NextChar
    end
    else
      tok_type := TOK_DOT
  end
  else if ch = 94 then  { ^ (caret) }
  begin
    tok_type := TOK_CARET;
    NextChar
  end
  else if ch = 64 then  { @ }
  begin
    tok_type := TOK_AT;
    NextChar
  end
  else
  begin
    Error(1);  { unexpected character }
    NextChar
  end
end;

{ ----- Symbol Table ----- }

procedure CopyTokenToSym(idx: integer);
var
  i: integer;
  base: integer;
begin
  { sym_name is flattened: base = idx * 32 }
  base := idx * 32;
  i := 0;
  while i < tok_len do
  begin
    sym_name[base + i] := tok_str[i];
    i := i + 1
  end;
  sym_name[base + tok_len] := 0
end;

function SymLookup: integer;
var
  i: integer;
  found: integer;
begin
  { Search backwards to find most recent definition }
  i := sym_count - 1;
  found := -1;
  while (i >= 0) and (found = -1) do
  begin
    if StrEqual(i) = 1 then
      found := i;
    i := i - 1
  end;
  SymLookup := found
end;

function SymAdd(kind, typ, level, offset: integer): integer;
begin
  CopyTokenToSym(sym_count);
  sym_kind[sym_count] := kind;
  sym_type[sym_count] := typ;
  sym_level[sym_count] := level;
  sym_offset[sym_count] := offset;
  sym_label[sym_count] := 0;
  sym_const_val[sym_count] := 0;
  sym_is_var_param[sym_count] := 0;
  sym_var_param_flags[sym_count] := 0;
  sym_count := sym_count + 1;
  SymAdd := sym_count - 1
end;

procedure PopScope(level: integer);
begin
  while (sym_count > 0) and (sym_level[sym_count - 1] >= level) do
    sym_count := sym_count - 1
end;

{ Check if parameter position i is marked as var in flags bitmap }
function IsVarParam(flags, i: integer): integer;
var
  bit_val, result: integer;
begin
  if i = 0 then bit_val := 1
  else if i = 1 then bit_val := 2
  else if i = 2 then bit_val := 4
  else if i = 3 then bit_val := 8
  else if i = 4 then bit_val := 16
  else if i = 5 then bit_val := 32
  else if i = 6 then bit_val := 64
  else bit_val := 128;
  result := (flags div bit_val) mod 2;
  IsVarParam := result
end;

{ Find a field in a record type, returns field index or -1 }
function FindField(type_idx: integer): integer;
var
  i, j, base, match: integer;
  first_fld: integer;
begin
  FindField := -1;
  first_fld := sym_const_val[type_idx];
  i := first_fld;
  while (i < field_count) and (field_rec_idx[i] = type_idx) do
  begin
    { Compare field name with current token }
    base := i * 32;
    match := 1;
    j := 0;
    while (j < tok_len) and (match = 1) do
    begin
      if ToLower(field_name[base + j]) <> ToLower(tok_str[j]) then
        match := 0;
      j := j + 1
    end;
    if (match = 1) and (field_name[base + tok_len] = 0) then
    begin
      FindField := i;
      i := field_count  { exit loop }
    end
    else
      i := i + 1
  end
end;

{ ----- Output Helpers ----- }

procedure EmitIndent;
begin
  writechar(32);
  writechar(32);
  writechar(32);
  writechar(32)
end;

procedure EmitNL;
begin
  writeln
end;

{ Emit specific strings character by character }
procedure EmitGlobl;
begin
  { .globl _main }
  writechar(46); writechar(103); writechar(108); writechar(111);
  writechar(98); writechar(108); writechar(32);
  writechar(95); writechar(109); writechar(97); writechar(105); writechar(110);
  EmitNL
end;

procedure EmitAlign4;
begin
  { .align 4 }
  writechar(46); writechar(97); writechar(108); writechar(105);
  writechar(103); writechar(110); writechar(32); writechar(52);
  EmitNL
end;

procedure EmitMain;
begin
  { _main: }
  writechar(95); writechar(109); writechar(97); writechar(105); writechar(110);
  writechar(58);
  EmitNL
end;

procedure EmitLabel(n: integer);
begin
  writechar(76);  { L }
  write(n);
  writechar(58);  { : }
  EmitNL
end;

function NewLabel: integer;
begin
  NewLabel := label_count;
  label_count := label_count + 1
end;

procedure EmitStp;
begin
  { stp x29, x30, [sp, #-16]! }
  EmitIndent;
  writechar(115); writechar(116); writechar(112); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(120); writechar(51); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);
  writechar(35); writechar(45); writechar(49); writechar(54);
  writechar(93); writechar(33);
  EmitNL
end;

procedure EmitMovFP;
begin
  { mov x29, sp }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL
end;

procedure EmitLdp;
begin
  { ldp x29, x30, [sp], #16 }
  EmitIndent;
  writechar(108); writechar(100); writechar(112); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(120); writechar(51); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  writechar(44); writechar(32); writechar(35); writechar(49); writechar(54);
  EmitNL
end;

procedure EmitRet;
begin
  { ret }
  EmitIndent;
  writechar(114); writechar(101); writechar(116);
  EmitNL
end;

procedure EmitStoreStaticLink;
begin
  { stur x9, [x29, #-8] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL
end;

{ Emit code to set up static link in x9 before a call }
{ The callee was declared at sym_level, so its static link should point to frame at sym_level }
procedure EmitStaticLink(sym_level, cur_level: integer);
var
  i: integer;
begin
  { mov x9, x29 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;
  { Follow static link chain to reach sym_level }
  for i := cur_level downto sym_level + 1 do
  begin
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
    writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
    writechar(91); writechar(120); writechar(57); writechar(44); writechar(32);  { [x9, }
    writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
    EmitNL
  end
end;

procedure EmitMovX0(val: integer);
var
  lo, hi: integer;
  neg: integer;
begin
  neg := 0;
  if val < 0 then
  begin
    neg := 1;
    val := 0 - val
  end;
  if val > 65535 then
  begin
    lo := val mod 65536;
    hi := val div 65536;
    { movz x0, #lo }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);
    writechar(120); writechar(48); writechar(44); writechar(32);
    writechar(35);
    write(lo);
    EmitNL;
    { movk x0, #hi, lsl #16 }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);
    writechar(120); writechar(48); writechar(44); writechar(32);
    writechar(35);
    write(hi);
    writechar(44); writechar(32);
    writechar(108); writechar(115); writechar(108); writechar(32);
    writechar(35); writechar(49); writechar(54);
    EmitNL
  end
  else
  begin
    { mov x0, #val }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(32);
    writechar(120); writechar(48); writechar(44); writechar(32);
    writechar(35);
    write(val);
    EmitNL
  end;
  if neg = 1 then
  begin
    { neg x0, x0 }
    EmitIndent;
    writechar(110); writechar(101); writechar(103); writechar(32);
    writechar(120); writechar(48); writechar(44); writechar(32);
    writechar(120); writechar(48);
    EmitNL
  end
end;

procedure EmitMovX16(val: integer);
var
  lo, hi: integer;
begin
  { For large values like syscall numbers (0x2000001, etc), use movz+movk }
  if val > 65535 then
  begin
    lo := val mod 65536;
    hi := val div 65536;
    { movz x16, #lo }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);
    writechar(120); writechar(49); writechar(54); writechar(44); writechar(32);
    writechar(35);
    write(lo);
    EmitNL;
    { movk x16, #hi, lsl #16 }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);
    writechar(120); writechar(49); writechar(54); writechar(44); writechar(32);
    writechar(35);
    write(hi);
    writechar(44); writechar(32);
    writechar(108); writechar(115); writechar(108); writechar(32);
    writechar(35); writechar(49); writechar(54);
    EmitNL
  end
  else
  begin
    { mov x16, #val }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(32);
    writechar(120); writechar(49); writechar(54); writechar(44); writechar(32);
    writechar(35);
    write(val);
    EmitNL
  end
end;

procedure EmitMovX8(val: integer);
var
  lo, hi: integer;
  neg: integer;
begin
  { Handle negative values: negate, emit, then negate result }
  neg := 0;
  if val < 0 then
  begin
    neg := 1;
    val := 0 - val
  end;
  if val > 65535 then
  begin
    lo := val mod 65536;
    hi := val div 65536;
    { movz x8, #lo }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);
    writechar(120); writechar(56); writechar(44); writechar(32);
    writechar(35);
    write(lo);
    EmitNL;
    { movk x8, #hi, lsl #16 }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);
    writechar(120); writechar(56); writechar(44); writechar(32);
    writechar(35);
    write(hi);
    writechar(44); writechar(32);
    writechar(108); writechar(115); writechar(108); writechar(32);
    writechar(35); writechar(49); writechar(54);
    EmitNL
  end
  else
  begin
    { mov x8, #val }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(32);
    writechar(120); writechar(56); writechar(44); writechar(32);
    writechar(35);
    write(val);
    EmitNL
  end;
  if neg = 1 then
  begin
    { neg x8, x8 }
    EmitIndent;
    writechar(110); writechar(101); writechar(103); writechar(32);
    writechar(120); writechar(56); writechar(44); writechar(32);
    writechar(120); writechar(56);
    EmitNL
  end
end;

{ Emit sub xD, xS, #offset where offset can be large }
{ If offset > 4095, loads into x10 first }
procedure EmitSubLargeOffset(dest, src, offset: integer);
var
  lo, hi: integer;
begin
  if offset <= 4095 then
  begin
    { sub xD, xS, #offset }
    EmitIndent;
    writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
    writechar(120);
    if dest < 10 then
      writechar(48 + dest)
    else
    begin
      writechar(49);
      writechar(48 + dest - 10)
    end;
    writechar(44); writechar(32);
    writechar(120);
    if src < 10 then
      writechar(48 + src)
    else
    begin
      if src = 29 then
      begin
        writechar(50); writechar(57)
      end
      else
      begin
        writechar(49);
        writechar(48 + src - 10)
      end
    end;
    writechar(44); writechar(32);
    writechar(35);
    write(offset);
    EmitNL
  end
  else
  begin
    { Load offset into x10 }
    lo := offset mod 65536;
    hi := offset div 65536;
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
    writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
    writechar(35);
    write(lo);
    EmitNL;
    if hi > 0 then
    begin
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
      writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
      writechar(35);
      write(hi);
      writechar(44); writechar(32);
      writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
      writechar(35); writechar(49); writechar(54);  { #16 }
      EmitNL
    end;
    { sub xD, xS, x10 }
    EmitIndent;
    writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
    writechar(120);
    if dest < 10 then
      writechar(48 + dest)
    else
    begin
      writechar(49);
      writechar(48 + dest - 10)
    end;
    writechar(44); writechar(32);
    writechar(120);
    if src < 10 then
      writechar(48 + src)
    else
    begin
      if src = 29 then
      begin
        writechar(50); writechar(57)
      end
      else
      begin
        writechar(49);
        writechar(48 + src - 10)
      end
    end;
    writechar(44); writechar(32);
    writechar(120); writechar(49); writechar(48);  { x10 }
    EmitNL
  end
end;

procedure EmitSvc;
begin
  { svc #0x80 }
  EmitIndent;
  writechar(115); writechar(118); writechar(99); writechar(32);
  writechar(35); writechar(48); writechar(120); writechar(56); writechar(48);
  EmitNL
end;

procedure EmitPushX0;
begin
  { str x0, [sp, #-16]! }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);
  writechar(35); writechar(45); writechar(49); writechar(54);
  writechar(93); writechar(33);
  EmitNL
end;

procedure EmitPopX0;
begin
  { ldr x0, [sp], #16 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  writechar(44); writechar(32); writechar(35); writechar(49); writechar(54);
  EmitNL
end;

procedure EmitPopX1;
begin
  { ldr x1, [sp], #16 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  writechar(44); writechar(32); writechar(35); writechar(49); writechar(54);
  EmitNL
end;

procedure EmitPushX1;
begin
  { str x1, [sp, #-16]! }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);
  writechar(35); writechar(45); writechar(49); writechar(54);
  writechar(93); writechar(33);
  EmitNL
end;

procedure EmitAdd;
begin
  { add x0, x1, x0 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitSub;
begin
  { sub x0, x1, x0 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitMul;
begin
  { mul x0, x1, x0 }
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitSDiv;
begin
  { sdiv x0, x1, x0 }
  EmitIndent;
  writechar(115); writechar(100); writechar(105); writechar(118); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitMovX0X20;
begin
  { mov x0, x20 - use output file descriptor }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);     { x0, }
  writechar(120); writechar(50); writechar(48);                    { x20 }
  EmitNL
end;

procedure EmitBranchLabel(lbl: integer);
begin
  { b Lxx }
  EmitIndent;
  writechar(98); writechar(32);
  writechar(76);
  write(lbl);
  EmitNL
end;

procedure EmitBranchLabelZ(lbl: integer);
begin
  { cbz x0, Lxx }
  EmitIndent;
  writechar(99); writechar(98); writechar(122); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(76);
  write(lbl);
  EmitNL
end;

procedure EmitBranchLabelNZ(lbl: integer);
begin
  { cbnz x0, Lxx }
  EmitIndent;
  writechar(99); writechar(98); writechar(110); writechar(122); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(76);
  write(lbl);
  EmitNL
end;

procedure EmitBL(lbl: integer);
begin
  { bl Lxx }
  EmitIndent;
  writechar(98); writechar(108); writechar(32);
  writechar(76);
  write(lbl);
  EmitNL
end;

procedure EmitCmpX0X1;
begin
  { cmp x0, x1 - actually cmp x1, x0 for our stack order }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitCset(cond: integer);
begin
  { cset x0, <cond> }
  { cond: 0=eq, 1=ne, 2=lt, 3=le, 4=gt, 5=ge }
  EmitIndent;
  writechar(99); writechar(115); writechar(101); writechar(116); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  if cond = 0 then
  begin writechar(101); writechar(113) end  { eq }
  else if cond = 1 then
  begin writechar(110); writechar(101) end  { ne }
  else if cond = 2 then
  begin writechar(108); writechar(116) end  { lt }
  else if cond = 3 then
  begin writechar(108); writechar(101) end  { le }
  else if cond = 4 then
  begin writechar(103); writechar(116) end  { gt }
  else
  begin writechar(103); writechar(101) end; { ge }
  EmitNL
end;

procedure EmitLdurX0(offset: integer);
begin
  if (offset >= -255) and (offset <= 255) then
  begin
    { ldur x0, [x29, #offset] }
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);
    writechar(120); writechar(48); writechar(44); writechar(32);
    writechar(91); writechar(120); writechar(50); writechar(57);
    writechar(44); writechar(32); writechar(35);
    write(offset);
    writechar(93);
    EmitNL
  end
  else
  begin
    { Large offset: mov x8, #offset; add x8, x29, x8; ldr x0, [x8] }
    EmitMovX8(offset);
    EmitIndent;
    writechar(97); writechar(100); writechar(100); writechar(32);  { add }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
    writechar(120); writechar(56);  { x8 }
    EmitNL;
    EmitIndent;
    writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
    writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
    writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
    EmitNL
  end
end;

{ Load from outer scope - follow static link chain }
{ Static link is stored at [frame, #-8] }
procedure EmitLdurX0Outer(offset, sym_level, cur_level: integer);
var
  i: integer;
begin
  { Start with current frame pointer }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;
  { Follow static link chain }
  for i := cur_level downto sym_level + 1 do
  begin
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
    writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
    EmitNL
  end;
  { Now x8 points to the target frame }
  if (offset >= -255) and (offset <= 255) then
  begin
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
    writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
    writechar(91); writechar(120); writechar(56);  { [x8 }
    writechar(44); writechar(32); writechar(35);  { , # }
    write(offset);
    writechar(93);  { ] }
    EmitNL
  end
  else
  begin
    { Large offset: save x8 to x9, load offset to x8, add them }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
    writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
    writechar(120); writechar(56);  { x8 }
    EmitNL;
    EmitMovX8(offset);
    EmitIndent;
    writechar(97); writechar(100); writechar(100); writechar(32);  { add }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
    writechar(120); writechar(56);  { x8 }
    EmitNL;
    EmitIndent;
    writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
    writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
    writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
    EmitNL
  end
end;

{ Follow static link chain, leave target frame in x8 }
{ Static link is stored at [frame, #-8] }
procedure EmitFollowChain(sym_level, cur_level: integer);
var
  i: integer;
begin
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;
  for i := cur_level downto sym_level + 1 do
  begin
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
    writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
    EmitNL
  end
end;

{ Emit code to compute address of a variable into x0 }
{ For use with var parameters - caller passes address }
procedure EmitVarAddr(var_idx, cur_scope: integer);
var
  offset, var_level, i: integer;
begin
  offset := sym_offset[var_idx];
  var_level := sym_level[var_idx];

  if var_level < cur_scope then
  begin
    { Variable is in outer scope - follow static chain to x8 }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(120); writechar(50); writechar(57);  { x29 }
    EmitNL;
    for i := cur_scope downto var_level + 1 do
    begin
      EmitIndent;
      writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
      writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
      writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
      writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
      EmitNL
    end;
    { Now x8 has target frame, compute address }
    if offset < 0 then
    begin
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
      writechar(35);
      write(0 - offset);
      EmitNL
    end
    else
    begin
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
      writechar(35);
      write(offset);
      EmitNL
    end
  end
  else
  begin
    { Variable is in current scope }
    if offset < 0 then
    begin
      { Negative offset: use sub x0, x29, #abs(offset) }
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
      writechar(35);
      write(0 - offset);
      EmitNL
    end
    else
    begin
      { Positive offset: use add x0, x29, #offset }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
      writechar(35);
      write(offset);
      EmitNL
    end
  end
end;

{ Store to outer scope - follow saved frame pointer chain }
procedure EmitSturX0Outer(offset, sym_level, cur_level: integer);
var
  i: integer;
begin
  { Save x0 temporarily }
  EmitPushX0;
  { Start with current frame pointer }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;
  { Follow static link chain }
  for i := cur_level downto sym_level + 1 do
  begin
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
    writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
    EmitNL
  end;
  { Restore x0 }
  EmitPopX0;
  { Now x8 points to the target frame }
  if (offset >= -255) and (offset <= 255) then
  begin
    EmitIndent;
    writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
    writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
    writechar(91); writechar(120); writechar(56);  { [x8 }
    writechar(44); writechar(32); writechar(35);  { , # }
    write(offset);
    writechar(93);  { ] }
    EmitNL
  end
  else
  begin
    { Large offset: save x8 to x9, x0 to stack, load offset to x8, add, restore x0 }
    EmitIndent;
    writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
    writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
    writechar(120); writechar(56);  { x8 }
    EmitNL;
    EmitPushX0;
    EmitMovX8(offset);
    EmitIndent;
    writechar(97); writechar(100); writechar(100); writechar(32);  { add }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
    writechar(120); writechar(56);  { x8 }
    EmitNL;
    EmitPopX0;
    EmitIndent;
    writechar(115); writechar(116); writechar(114); writechar(32);  { str }
    writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
    writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
    EmitNL
  end
end;

procedure EmitSturX0(offset: integer);
begin
  if (offset >= -255) and (offset <= 255) then
  begin
    { stur x0, [x29, #offset] }
    EmitIndent;
    writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);
    writechar(120); writechar(48); writechar(44); writechar(32);
    writechar(91); writechar(120); writechar(50); writechar(57);
    writechar(44); writechar(32); writechar(35);
    write(offset);
    writechar(93);
    EmitNL
  end
  else
  begin
    { Large offset: mov x8, #offset; add x8, x29, x8; str x0, [x8] }
    EmitMovX8(offset);
    EmitIndent;
    writechar(97); writechar(100); writechar(100); writechar(32);  { add }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
    writechar(120); writechar(56);  { x8 }
    EmitNL;
    EmitIndent;
    writechar(115); writechar(116); writechar(114); writechar(32);  { str }
    writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
    writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
    EmitNL
  end
end;

procedure EmitSubSP(n: integer);
begin
  if n <= 4095 then
  begin
    { sub sp, sp, #n }
    EmitIndent;
    writechar(115); writechar(117); writechar(98); writechar(32);
    writechar(115); writechar(112); writechar(44); writechar(32);
    writechar(115); writechar(112); writechar(44); writechar(32);
    writechar(35);
    write(n);
    EmitNL
  end
  else
  begin
    { Large value: mov x8, #n; sub sp, sp, x8 }
    EmitMovX8(n);
    EmitIndent;
    writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
    writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
    writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
    writechar(120); writechar(56);  { x8 }
    EmitNL
  end
end;

procedure EmitAddSP(n: integer);
begin
  if n <= 4095 then
  begin
    { add sp, sp, #n }
    EmitIndent;
    writechar(97); writechar(100); writechar(100); writechar(32);
    writechar(115); writechar(112); writechar(44); writechar(32);
    writechar(115); writechar(112); writechar(44); writechar(32);
    writechar(35);
    write(n);
    EmitNL
  end
  else
  begin
    { Large value: mov x8, #n; add sp, sp, x8 }
    EmitMovX8(n);
    EmitIndent;
    writechar(97); writechar(100); writechar(100); writechar(32);  { add }
    writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
    writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
    writechar(120); writechar(56);  { x8 }
    EmitNL
  end
end;

procedure EmitNeg;
begin
  { neg x0, x0 }
  EmitIndent;
  writechar(110); writechar(101); writechar(103); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitMsub;
begin
  { msub x0, x0, x2, x1   (x0 = x1 - x0 * x2) for mod }
  EmitIndent;
  writechar(109); writechar(115); writechar(117); writechar(98); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(49);
  EmitNL
end;

procedure EmitMovX2X0;
begin
  { mov x2, x0 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitAndX0X1;
begin
  { and x0, x1, x0 }
  EmitIndent;
  writechar(97); writechar(110); writechar(100); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitOrrX0X1;
begin
  { orr x0, x1, x0 }
  EmitIndent;
  writechar(111); writechar(114); writechar(114); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL
end;

procedure EmitEorX0(val: integer);
begin
  { eor x0, x0, #val }
  EmitIndent;
  writechar(101); writechar(111); writechar(114); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35);
  write(val);
  EmitNL
end;

{ ----- Floating Point Emitters ----- }

procedure EmitPushD0;
begin
  { str d0, [sp, #-16]! }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(45); writechar(49); writechar(54);     { #-16 }
  writechar(93); writechar(33);  { ]! }
  EmitNL
end;

procedure EmitPopD0;
begin
  { ldr d0, [sp], #16 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(91); writechar(115); writechar(112); writechar(93);   { [sp] }
  writechar(44); writechar(32); writechar(35); writechar(49); writechar(54);  { , #16 }
  EmitNL
end;

procedure EmitPopD1;
begin
  { ldr d1, [sp], #16 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
  writechar(100); writechar(49); writechar(44); writechar(32);    { d1, }
  writechar(91); writechar(115); writechar(112); writechar(93);   { [sp] }
  writechar(44); writechar(32); writechar(35); writechar(49); writechar(54);  { , #16 }
  EmitNL
end;

procedure EmitFAdd;
begin
  { fadd d0, d1, d0 }
  EmitIndent;
  writechar(102); writechar(97); writechar(100); writechar(100); writechar(32);  { fadd }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(100); writechar(49); writechar(44); writechar(32);    { d1, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitFSub;
begin
  { fsub d0, d1, d0 }
  EmitIndent;
  writechar(102); writechar(115); writechar(117); writechar(98); writechar(32);  { fsub }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(100); writechar(49); writechar(44); writechar(32);    { d1, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitFMul;
begin
  { fmul d0, d1, d0 }
  EmitIndent;
  writechar(102); writechar(109); writechar(117); writechar(108); writechar(32);  { fmul }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(100); writechar(49); writechar(44); writechar(32);    { d1, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitFDiv;
begin
  { fdiv d0, d1, d0 }
  EmitIndent;
  writechar(102); writechar(100); writechar(105); writechar(118); writechar(32);  { fdiv }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(100); writechar(49); writechar(44); writechar(32);    { d1, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitFNeg;
begin
  { fneg d0, d0 }
  EmitIndent;
  writechar(102); writechar(110); writechar(101); writechar(103); writechar(32);  { fneg }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitFCmp;
begin
  { fcmp d1, d0 }
  EmitIndent;
  writechar(102); writechar(99); writechar(109); writechar(112); writechar(32);  { fcmp }
  writechar(100); writechar(49); writechar(44); writechar(32);    { d1, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitScvtfD0X0;
begin
  { scvtf d0, x0 - convert signed int to float }
  EmitIndent;
  writechar(115); writechar(99); writechar(118); writechar(116); writechar(102); writechar(32);  { scvtf }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(120); writechar(48);  { x0 }
  EmitNL
end;

procedure EmitScvtfD1X1;
begin
  { scvtf d1, x1 - convert signed int to float }
  EmitIndent;
  writechar(115); writechar(99); writechar(118); writechar(116); writechar(102); writechar(32);  { scvtf }
  writechar(100); writechar(49); writechar(44); writechar(32);    { d1, }
  writechar(120); writechar(49);  { x1 }
  EmitNL
end;

procedure EmitFcvtzsX0D0;
begin
  { fcvtzs x0, d0 - convert float to signed int (truncate toward zero) }
  EmitIndent;
  writechar(102); writechar(99); writechar(118); writechar(116); writechar(122); writechar(115); writechar(32);  { fcvtzs }
  writechar(120); writechar(48); writechar(44); writechar(32);    { x0, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitFmovD0X0;
begin
  { fmov d0, x0 - move bits from x0 to d0 }
  EmitIndent;
  writechar(102); writechar(109); writechar(111); writechar(118); writechar(32);  { fmov }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(120); writechar(48);  { x0 }
  EmitNL
end;

procedure EmitFmovX0D0;
begin
  { fmov x0, d0 - move bits from d0 to x0 }
  EmitIndent;
  writechar(102); writechar(109); writechar(111); writechar(118); writechar(32);  { fmov }
  writechar(120); writechar(48); writechar(44); writechar(32);    { x0, }
  writechar(100); writechar(48);  { d0 }
  EmitNL
end;

procedure EmitLdurD0(offset: integer);
begin
  { ldur d0, [x29, #offset] }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57);    { [x29 }
  writechar(44); writechar(32); writechar(35);  { , # }
  write(offset);
  writechar(93);  { ] }
  EmitNL
end;

procedure EmitSturD0(offset: integer);
begin
  { stur d0, [x29, #offset] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57);    { [x29 }
  writechar(44); writechar(32); writechar(35);  { , # }
  write(offset);
  writechar(93);  { ] }
  EmitNL
end;

procedure EmitLdurD0Outer(offset, sym_level, cur_level: integer);
var
  i: integer;
begin
  { Follow static link chain to load float from outer scope }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(56); writechar(44); writechar(32);    { x8, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;
  for i := cur_level downto sym_level + 1 do
  begin
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
    writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
    EmitNL
  end;
  { ldur d0, [x8, #offset] }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(91); writechar(120); writechar(56);  { [x8 }
  writechar(44); writechar(32); writechar(35);  { , # }
  write(offset);
  writechar(93);  { ] }
  EmitNL
end;

procedure EmitSturD0Outer(offset, sym_level, cur_level: integer);
var
  i: integer;
begin
  { Follow static link chain to store float to outer scope }
  { Save d0 temporarily to stack }
  EmitPushD0;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(56); writechar(44); writechar(32);    { x8, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;
  for i := cur_level downto sym_level + 1 do
  begin
    EmitIndent;
    writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
    writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
    writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
    writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
    EmitNL
  end;
  { Restore d0 }
  EmitPopD0;
  { stur d0, [x8, #offset] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(100); writechar(48); writechar(44); writechar(32);    { d0, }
  writechar(91); writechar(120); writechar(56);  { [x8 }
  writechar(44); writechar(32); writechar(35);  { , # }
  write(offset);
  writechar(93);  { ] }
  EmitNL
end;

{ ----- Print Runtime ----- }

procedure EmitPrintIntRuntime;
var
  loop_lbl, done_lbl, neg_lbl, print_lbl: integer;
begin
  { Runtime routine to print integer in x0 }
  EmitLabel(rt_print_int);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { Save value }
  EmitSturX0(-24);

  { Handle negative }
  neg_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #0 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;

  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge Lxx }
  writechar(76); write(neg_lbl);
  EmitNL;

  { Print minus sign }
  EmitMovX0(1);
  EmitSturX0(-32);
  EmitMovX0(45);  { '-' }
  EmitSturX0(-8);
  EmitMovX16(33554436); { 0x2000004 }
  EmitMovX0X20;
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x1, x29, #8 }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(56);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitSvc;

  { Negate }
  EmitLdurX0(-24);
  EmitNeg;
  EmitSturX0(-24);

  EmitLabel(neg_lbl);

  { Convert to string (digits in reverse) }
  EmitMovX0(0);
  EmitSturX0(-40);  { digit count }

  loop_lbl := NewLabel;
  print_lbl := NewLabel;

  EmitLabel(loop_lbl);
  EmitLdurX0(-24);
  EmitBranchLabelZ(print_lbl);

  { val % 10 }
  EmitLdurX0(-24);
  EmitPushX0;
  EmitMovX0(10);
  EmitPopX1;
  EmitSDiv;
  EmitMovX2X0;
  EmitLdurX0(-24);
  EmitPushX0;
  EmitMovX0(10);
  EmitPopX1;
  EmitMsub;

  { Store digit }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add x0, x0, #48 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;

  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur x1, [x29, #-40] }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(45); writechar(52); writechar(48); writechar(93);
  EmitNL;

  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x2, x29, #48 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;

  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb w0, [x2, x1] }
  writechar(119); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(93);
  EmitNL;

  { digit count++ }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add x1, x1, #1 }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;

  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur x1, [x29, #-40] }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(45); writechar(52); writechar(48); writechar(93);
  EmitNL;

  { val /= 10 }
  EmitLdurX0(-24);
  EmitPushX0;
  EmitMovX0(10);
  EmitPopX1;
  EmitSDiv;
  EmitSturX0(-24);

  EmitBranchLabel(loop_lbl);

  EmitLabel(print_lbl);

  { Handle zero }
  EmitLdurX0(-40);
  EmitBranchLabelNZ(done_lbl);
  EmitMovX0(48);  { '0' }
  EmitSturX0(-48);
  EmitMovX0(1);
  EmitSturX0(-40);

  EmitLabel(done_lbl);

  { Print digits in reverse order }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop_lbl);
  EmitLdurX0(-40);
  EmitBranchLabelZ(done_lbl);

  { digit count-- }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x0, x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitSturX0(-40);

  { Load digit }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x1, x29, #48 }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;

  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w0, [x1, x0] }
  writechar(119); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48); writechar(93);
  EmitNL;

  { Print char }
  EmitSturX0(-8);
  EmitMovX16(33554436);
  EmitMovX0X20;
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x1, x29, #8 }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(56);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitSvc;

  EmitBranchLabel(loop_lbl);

  { Exit label }
  EmitLabel(done_lbl);

  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

procedure EmitNewlineRuntime;
begin
  { Newline routine - print chr(10) }
  EmitLabel(rt_newline);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  EmitMovX0(10);
  EmitSturX0(-9);
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x1, x29, #9 }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitReadcharRuntime;
begin
  { Readchar routine - read one char, return in x0 (-1 for EOF) }
  { Uses x19 as input file descriptor (0=stdin, or opened file) }
  EmitLabel(rt_readchar);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x19 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read }
  EmitSvc;
  { Check if read returned >= 1 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge Lxx }
  writechar(76); write(label_count);
  EmitNL;
  EmitMovX0(-1);  { EOF }
  EmitBranchLabel(label_count + 1);
  EmitLabel(label_count);
  label_count := label_count + 1;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w0, [sp] }
  writechar(119); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;
  EmitLabel(label_count);
  label_count := label_count + 1;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitPrintCharRuntime;
begin
  { Print char routine - print char in x0 }
  EmitLabel(rt_print_char);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb w0, [sp] }
  writechar(119); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitPrintStringRuntime;
var
  loop_lbl, done_lbl: integer;
begin
  { Print string routine - x0 = address of pascal string (length byte + chars) }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(rt_print_string);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);
  { Save base address to [x29, #-8] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL;
  { Load length from [x0] into x1 and save to [x29, #-16] }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(49); writechar(44); writechar(32);  { w1, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  { Initialize index to 0 at [x29, #-24] }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  { Loop label }
  EmitLabel(loop_lbl);
  { Load index and length, compare }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(49);  { x1 }
  EmitNL;
  { b.ge done_lbl }
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(done_lbl);
  EmitNL;
  { Load char at [base + index + 1] }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  { Call print_char }
  EmitBL(rt_print_char);
  { Increment index }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  { Branch back to loop }
  EmitBranchLabel(loop_lbl);
  { Done label }
  EmitLabel(done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

procedure EmitReadIntRuntime;
var
  skip_ws_lbl, read_digit_lbl, done_lbl, neg_lbl, not_neg_lbl, skip_neg_lbl: integer;
begin
  { Read integer routine - reads from x19 (input fd), returns in x0 }
  { Skips whitespace, handles optional minus sign, reads digits }
  EmitLabel(rt_read_int);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  { x21 = accumulated value, x22 = negative flag }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x21, #0 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x22, #0 }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;

  { Skip whitespace loop }
  skip_ws_lbl := NewLabel;
  EmitLabel(skip_ws_lbl);
  { Read one char }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x19 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read }
  EmitSvc;
  { Check if read failed }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  done_lbl := NewLabel;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt done }
  writechar(76); write(done_lbl);
  EmitNL;
  { Load char into x23 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w23, [sp] }
  writechar(119); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;
  { Check if space (32), tab (9), newline (10), or carriage return (13) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x23, #32 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(51); writechar(50);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x23, #9 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x23, #10 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x23, #13 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(51);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;

  { Check for minus sign (45) }
  neg_lbl := NewLabel;
  not_neg_lbl := NewLabel;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x23, #45 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(53);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne not_neg }
  writechar(76); write(not_neg_lbl);
  EmitNL;
  { Set negative flag }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x22, #1 }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitBranchLabel(neg_lbl);
  EmitLabel(not_neg_lbl);
  { Not a minus, so it should be a digit - process it }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x23, x23, #48 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;
  { Check if valid digit (0-9) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x23, #9 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(104); writechar(105); writechar(32);  { b.hi done (unsigned >9) }
  writechar(76); write(done_lbl);
  EmitNL;
  { Add to accumulated value: x21 = x21 * 10 + x23 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x24, #10 }
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul x21, x21, x24 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(52);
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add x21, x21, x23 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(51);
  EmitNL;

  { Read digit loop }
  EmitLabel(neg_lbl);
  read_digit_lbl := NewLabel;
  EmitLabel(read_digit_lbl);
  { Read one char }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x19 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read }
  EmitSvc;
  { Check if read failed }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt done }
  writechar(76); write(done_lbl);
  EmitNL;
  { Load char into x23 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w23, [sp] }
  writechar(119); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;
  { Save original char to x18 for pushback }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x18, x23 }
  writechar(120); writechar(49); writechar(56); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(51);
  EmitNL;
  { Convert to digit }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x23, x23, #48 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;
  { Check if valid digit (0-9) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x23, #9 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(104); writechar(105); writechar(32);  { b.hi done }
  writechar(76); write(done_lbl);
  EmitNL;
  { Add to accumulated value: x21 = x21 * 10 + x23 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x24, #10 }
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul x21, x21, x24 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(52);
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add x21, x21, x23 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(51);
  EmitNL;
  EmitBranchLabel(read_digit_lbl);

  { Done - apply negative if needed }
  EmitLabel(done_lbl);
  skip_neg_lbl := NewLabel;
  EmitIndent;
  writechar(99); writechar(98); writechar(122); writechar(32);  { cbz x22, Lxx (skip neg) }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(76); write(skip_neg_lbl);
  EmitNL;
  EmitIndent;
  writechar(110); writechar(101); writechar(103); writechar(32);  { neg x21, x21 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49);
  EmitNL;
  EmitLabel(skip_neg_lbl);
  { Move result to x0 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x21 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49);
  EmitNL;
  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

procedure EmitSkipLineRuntime;
var
  loop_lbl, done_lbl, check_pb_lbl: integer;
begin
  { Skip to end of line routine - reads chars until newline or EOF }
  { Uses x18 as pushback character from read_int (-1 means none) }
  EmitLabel(rt_skip_line);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);

  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  check_pb_lbl := NewLabel;

  { First check if pushback character is available }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x18, #0 }
  writechar(120); writechar(49); writechar(56); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt loop (no pushback) }
  writechar(76); write(loop_lbl);
  EmitNL;
  { Check if pushback is newline }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x18, #10 }
  writechar(120); writechar(49); writechar(56); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  { Clear pushback }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x18, #-1 }
  writechar(120); writechar(49); writechar(56); writechar(44); writechar(32);
  writechar(35); writechar(45); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq done (was newline, done) }
  writechar(76); write(done_lbl);
  EmitNL;

  EmitLabel(loop_lbl);
  { Read one char }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x19 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read }
  EmitSvc;
  { Check if read failed }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt done }
  writechar(76); write(done_lbl);
  EmitNL;
  { Load char }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w0, [sp] }
  writechar(119); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;
  { Check if newline (10) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #10 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne loop }
  writechar(76); write(loop_lbl);
  EmitNL;

  EmitLabel(done_lbl);
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitPrintRealRuntime;
var
  neg_lbl, skip_neg_lbl, print_frac_lbl, frac_loop_lbl: integer;
begin
  { Print real in d0 - format: integer.fraction (6 decimal places) }
  EmitLabel(rt_print_real);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);

  { Save original value to [x29, #-16] as double }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  { Check for negative }
  neg_lbl := NewLabel;
  skip_neg_lbl := NewLabel;
  { fcmp d0, #0.0 }
  EmitIndent;
  writechar(102); writechar(99); writechar(109); writechar(112); writechar(32);  { fcmp }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(35); writechar(48); writechar(46); writechar(48);  { #0.0 }
  EmitNL;
  { b.ge skip_neg }
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(neg_lbl);
  EmitNL;

  { Print '-' and negate }
  EmitMovX0(45);  { '-' }
  EmitBL(rt_print_char);
  { fneg d0, d0 }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitFNeg;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  EmitLabel(neg_lbl);

  { Load value and get integer part }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  { fcvtzs x0, d0 - truncate to integer }
  EmitFcvtzsX0D0;

  { Save integer part to [x29, #-24] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;

  { Print integer part }
  EmitBL(rt_print_int);

  { Print '.' }
  EmitMovX0(46);  { '.' }
  EmitBL(rt_print_char);

  { Calculate fractional part: (original - int_part) * 1000000 }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  { Load integer part and convert to float }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;

  { scvtf d1, x0 }
  EmitIndent;
  writechar(115); writechar(99); writechar(118); writechar(116); writechar(102); writechar(32);  { scvtf }
  writechar(100); writechar(49); writechar(44); writechar(32);  { d1, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;

  { fsub d0, d0, d1 - fractional part (d0 = original - int_part) }
  { EmitFSub does d0=d1-d0, so emit inline for d0=d0-d1 }
  EmitIndent;
  writechar(102); writechar(115); writechar(117); writechar(98); writechar(32);  { fsub }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(100); writechar(49);  { d1 }
  EmitNL;

  { Multiply by 1000000 }
  EmitMovX0(1000000);
  EmitScvtfD0X0;  { d0 = 1000000.0 }
  EmitPushD0;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(99); writechar(118); writechar(116); writechar(102); writechar(32);  { scvtf }
  writechar(100); writechar(49); writechar(44); writechar(32);  { d1, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  { fsub d0, d0, d1 - d0 = frac part (original - int_part) }
  { EmitFSub does d0=d1-d0, so emit inline for d0=d0-d1 }
  EmitIndent;
  writechar(102); writechar(115); writechar(117); writechar(98); writechar(32);  { fsub }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(100); writechar(49);  { d1 }
  EmitNL;
  EmitPopD1;  { d1 = 1000000.0 }
  EmitFMul;  { d0 = frac * 1000000 }

  { Convert to integer }
  EmitFcvtzsX0D0;

  { Save fractional digits to [x29, #-32] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;

  { Print fractional part with leading zeros (6 digits) }
  { Count digits needed }
  frac_loop_lbl := NewLabel;
  print_frac_lbl := NewLabel;

  { Print leading zeros: if frac < 100000, print '0', etc }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;

  { x1 = 100000 - use movz since 100000 > 65535 }
  { movz x1, #34464; movk x1, #1, lsl #16 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(51); writechar(52); writechar(52); writechar(54); writechar(52);  { #34464 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(49);  { #1 }
  writechar(44); writechar(32);
  writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  EmitLabel(frac_loop_lbl);
  { cmp x1, #10 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  { b.lt print_frac }
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(print_frac_lbl);
  EmitNL;
  { cmp x0, x1 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49);  { x1 }
  EmitNL;
  { b.ge print_frac }
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(print_frac_lbl);
  EmitNL;
  { Print '0' }
  EmitPushX0;
  EmitPushX1;
  EmitMovX0(48);
  EmitBL(rt_print_char);
  EmitPopX1;
  EmitPopX0;
  { x1 = x1 / 10 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(117); writechar(100); writechar(105); writechar(118); writechar(32);  { udiv }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitBranchLabel(frac_loop_lbl);

  EmitLabel(print_frac_lbl);
  { Load and print the fractional value }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  { Only print if non-zero }
  EmitBranchLabelZ(label_count);
  EmitBL(rt_print_int);
  EmitLabel(label_count);
  label_count := label_count + 1;

  EmitAddSP(64);
  EmitLdp;
  EmitRet
end;

procedure EmitReadRealRuntime;
var
  skip_ws_lbl, read_int_lbl, read_frac_lbl, done_lbl, neg_lbl, not_neg_lbl, skip_neg_lbl: integer;
begin
  { Read real from input, return in d0 }
  EmitLabel(rt_read_real);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);

  { x21 = integer part, x22 = fractional part (scaled), x23 = neg flag, x24 = frac scale }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x21, #0 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x22, #0 }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x23, #0 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x24, #1 }
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;

  { Skip whitespace }
  skip_ws_lbl := NewLabel;
  EmitLabel(skip_ws_lbl);
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x19 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read }
  EmitSvc;
  done_lbl := NewLabel;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt done }
  writechar(76); write(done_lbl);
  EmitNL;
  { Load char }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w25, [sp] }
  writechar(119); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;
  { Check whitespace }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #32 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(51); writechar(50);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #9 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #10 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #13 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(51);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq skip_ws }
  writechar(76); write(skip_ws_lbl);
  EmitNL;

  { Check for minus }
  neg_lbl := NewLabel;
  not_neg_lbl := NewLabel;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #45 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(53);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne not_neg }
  writechar(76); write(not_neg_lbl);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x23, #1 }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitBranchLabel(neg_lbl);
  EmitLabel(not_neg_lbl);

  { First char is a digit - process it }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x25, x25, #48 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #9 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(104); writechar(105); writechar(32);  { b.hi done }
  writechar(76); write(done_lbl);
  EmitNL;
  { x21 = x21 * 10 + x25 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x26, #10 }
  writechar(120); writechar(50); writechar(54); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul x21, x21, x26 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(54);
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add x21, x21, x25 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(53);
  EmitNL;

  { Read integer part loop }
  EmitLabel(neg_lbl);
  read_int_lbl := NewLabel;
  read_frac_lbl := NewLabel;
  EmitLabel(read_int_lbl);
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x19 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read }
  EmitSvc;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt done }
  writechar(76); write(done_lbl);
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w25, [sp] }
  writechar(119); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;

  { Check for '.' }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #46 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(54);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq read_frac }
  writechar(76); write(read_frac_lbl);
  EmitNL;

  { Check if digit }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x25, x25, #48 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #9 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(104); writechar(105); writechar(32);  { b.hi done }
  writechar(76); write(done_lbl);
  EmitNL;
  { x21 = x21 * 10 + x25 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x26, #10 }
  writechar(120); writechar(50); writechar(54); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul x21, x21, x26 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(54);
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add x21, x21, x25 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(53);
  EmitNL;
  EmitBranchLabel(read_int_lbl);

  { Read fractional part }
  EmitLabel(read_frac_lbl);
  skip_neg_lbl := NewLabel;
  EmitLabel(skip_neg_lbl);
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x0, x19 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(49); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, sp }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(115); writechar(112);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #1 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read }
  EmitSvc;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x0, #1 }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt done }
  writechar(76); write(done_lbl);
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w25, [sp] }
  writechar(119); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(91); writechar(115); writechar(112); writechar(93);
  EmitNL;

  { Check if digit }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub x25, x25, #48 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(56);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x25, #9 }
  writechar(120); writechar(50); writechar(53); writechar(44); writechar(32);
  writechar(35); writechar(57);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(104); writechar(105); writechar(32);  { b.hi done }
  writechar(76); write(done_lbl);
  EmitNL;
  { x22 = x22 * 10 + x25, x24 = x24 * 10 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x26, #10 }
  writechar(120); writechar(50); writechar(54); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul x22, x22, x26 }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(54);
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add x22, x22, x25 }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(53);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul x24, x24, x26 }
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);
  writechar(120); writechar(50); writechar(54);
  EmitNL;
  EmitBranchLabel(skip_neg_lbl);

  { Done - combine integer and fractional parts }
  EmitLabel(done_lbl);
  { d0 = x21 (integer part) }
  EmitIndent;
  writechar(115); writechar(99); writechar(118); writechar(116); writechar(102); writechar(32);  { scvtf }
  writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
  writechar(120); writechar(50); writechar(49);  { x21 }
  EmitNL;
  { d1 = x22 (fractional part) }
  EmitIndent;
  writechar(115); writechar(99); writechar(118); writechar(116); writechar(102); writechar(32);  { scvtf }
  writechar(100); writechar(49); writechar(44); writechar(32);  { d1, }
  writechar(120); writechar(50); writechar(50);  { x22 }
  EmitNL;
  { d2 = x24 (scale) }
  EmitIndent;
  writechar(115); writechar(99); writechar(118); writechar(116); writechar(102); writechar(32);  { scvtf }
  writechar(100); writechar(50); writechar(44); writechar(32);  { d2, }
  writechar(120); writechar(50); writechar(52);  { x24 }
  EmitNL;
  { d1 = d1 / d2 }
  EmitIndent;
  writechar(102); writechar(100); writechar(105); writechar(118); writechar(32);  { fdiv }
  writechar(100); writechar(49); writechar(44); writechar(32);  { d1, }
  writechar(100); writechar(49); writechar(44); writechar(32);  { d1, }
  writechar(100); writechar(50);  { d2 }
  EmitNL;
  { d0 = d0 + d1 }
  EmitFAdd;

  { Apply negative if needed }
  skip_neg_lbl := NewLabel;
  EmitIndent;
  writechar(99); writechar(98); writechar(122); writechar(32);  { cbz x23, skip }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);
  writechar(76); write(skip_neg_lbl);
  EmitNL;
  EmitFNeg;
  EmitLabel(skip_neg_lbl);

  EmitAddSP(64);
  EmitLdp;
  EmitRet
end;

procedure EmitReadStringRuntime;
var
  loop_lbl, done_lbl, store_len_lbl: integer;
begin
  { Read string from input (x19), string buffer address passed in x0 }
  { String format: byte 0 = length, bytes 1-255 = characters }
  { Reads until newline or max 255 chars }
  EmitLabel(rt_read_string);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save string buffer address in x21 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;

  { x22 = character count (starts at 0) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);  { x22, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { Read loop }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop_lbl);

  { Check if count >= 255 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);  { x22, }
  writechar(35); writechar(50); writechar(53); writechar(53);  { #255 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(done_lbl);
  EmitNL;

  { Read one character: read(x19, sp, 1) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49); writechar(57);  { x19 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(115); writechar(112);  { sp }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitMovX16(33554435);  { 0x2000003 = read syscall }
  EmitSvc;

  { Check if read failed or EOF (x0 < 1) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(done_lbl);
  EmitNL;

  { Load character into x23 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(51); writechar(44); writechar(32);  { w23, }
  writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
  EmitNL;

  { Check if newline (10) or carriage return (13) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);  { x23, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(done_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);  { x23, }
  writechar(35); writechar(49); writechar(51);  { #13 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(done_lbl);
  EmitNL;

  { Store character at buffer[count+1] }
  { x24 = x21 + x22 + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);  { x24, }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
  writechar(120); writechar(50); writechar(50);  { x22 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);  { x24, }
  writechar(120); writechar(50); writechar(52); writechar(44); writechar(32);  { x24, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(50); writechar(51); writechar(44); writechar(32);  { w23, }
  writechar(91); writechar(120); writechar(50); writechar(52); writechar(93);  { [x24] }
  EmitNL;

  { Increment count }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);  { x22, }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);  { x22, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Loop back }
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(loop_lbl);
  EmitNL;

  { Done - store length at buffer[0] }
  EmitLabel(done_lbl);
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(50); writechar(50); writechar(44); writechar(32);  { w22, }
  writechar(91); writechar(120); writechar(50); writechar(49); writechar(93);  { [x21] }
  EmitNL;

  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

procedure EmitFileOpenInit;
var
  skip_input_lbl, skip_output_lbl: integer;
begin
  { Initialize x19 (input fd) and x20 (output fd) from command line }
  { On entry: x0 = argc, x1 = argv }
  { Usage: tpcv2 input.pas output.s }
  skip_input_lbl := NewLabel;
  skip_output_lbl := NewLabel;

  { Save argc and argv to callee-saved registers }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x21, x0 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x22, x1 }
  writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(120); writechar(49);
  EmitNL;

  { Default: x19 = 0 (stdin), x20 = 1 (stdout), x18 = -1 (no pushback) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x19, #0 }
  writechar(120); writechar(49); writechar(57); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x20, #1 }
  writechar(120); writechar(50); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x18, #-1 }
  writechar(120); writechar(49); writechar(56); writechar(44); writechar(32);
  writechar(35); writechar(45); writechar(49);
  EmitNL;

  { If argc < 2, skip input file open }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x21, #2 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(50);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt Lxx }
  writechar(76); write(skip_input_lbl);
  EmitNL;

  { Load argv[1] into x0 (input filename) }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);  { ldr x0, [x22, #8] }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(56); writechar(93);
  EmitNL;

  { Open input file: open(filename, O_RDONLY, 0) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, #0 }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #0 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(48);
  EmitNL;
  EmitMovX16(33554437);  { 0x2000005 = open }
  EmitSvc;

  { Move input fd to x19 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x19, x0 }
  writechar(120); writechar(49); writechar(57); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL;

  { If argc < 4, skip output file open (need: prog input.pas -o output.s) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp x21, #4 }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(52);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt Lxx }
  writechar(76); write(skip_output_lbl);
  EmitNL;

  { Check if argv[2] == "-o": load argv[2], check first two bytes }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);  { ldr x0, [x22, #16] }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(54); writechar(93);
  EmitNL;
  { Load first byte, check for '-' (45) }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w1, [x0] }
  writechar(119); writechar(49); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(48); writechar(93);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp w1, #45 }
  writechar(119); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(53);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne skip }
  writechar(76); write(skip_output_lbl);
  EmitNL;
  { Load second byte, check for 'o' (111) }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb w1, [x0, #1] }
  writechar(119); writechar(49); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(93);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp w1, #111 }
  writechar(119); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(49); writechar(49);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne skip }
  writechar(76); write(skip_output_lbl);
  EmitNL;

  { Load argv[3] into x0 (output filename) }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);  { ldr x0, [x22, #24] }
  writechar(120); writechar(48); writechar(44); writechar(32);
  writechar(91); writechar(120); writechar(50); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(50); writechar(52); writechar(93);
  EmitNL;

  { Open output file: open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0644) }
  { O_WRONLY=1, O_CREAT=0x200, O_TRUNC=0x400 => 0x601 = 1537 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x1, #1537 }
  writechar(120); writechar(49); writechar(44); writechar(32);
  writechar(35); writechar(49); writechar(53); writechar(51); writechar(55);
  EmitNL;
  { mode 0644 = 420 decimal }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x2, #420 }
  writechar(120); writechar(50); writechar(44); writechar(32);
  writechar(35); writechar(52); writechar(50); writechar(48);
  EmitNL;
  EmitMovX16(33554437);  { 0x2000005 = open }
  EmitSvc;

  { Move output fd to x20 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov x20, x0 }
  writechar(120); writechar(50); writechar(48); writechar(44); writechar(32);
  writechar(120); writechar(48);
  EmitNL;

  EmitLabel(skip_output_lbl);
  EmitLabel(skip_input_lbl)
end;

procedure EmitHeapInitRuntime;
begin
  { Initialize heap using mmap syscall }
  { Allocates 1MB of memory for heap, stores base in x21 }
  EmitLabel(rt_heap_init);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);

  { mov x0, #0  - addr = NULL (let kernel choose) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { mov x1, #1048576  - length = 1MB (0x100000) }
  { Need movz + movk since 1048576 > 65535 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(49); writechar(54);  { #16 }
  writechar(44); writechar(32);
  writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  { mov x2, #3  - PROT_READ | PROT_WRITE }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(51);  { #3 }
  EmitNL;

  { mov x3, #4098  - MAP_PRIVATE | MAP_ANON (0x1002) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(52); writechar(48); writechar(57); writechar(56);  { #4098 }
  EmitNL;

  { mov x4, #-1  - fd = -1 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(110); writechar(32);  { movn }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { mov x5, #0  - offset = 0 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { mmap syscall: 0x20000C5 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
  writechar(120); writechar(49); writechar(54); writechar(44); writechar(32);  { x16, }
  writechar(35); writechar(48); writechar(120); writechar(67); writechar(53);  { #0xC5 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
  writechar(120); writechar(49); writechar(54); writechar(44); writechar(32);  { x16, }
  writechar(35); writechar(48); writechar(120); writechar(50); writechar(48); writechar(48);  { #0x200 }
  writechar(44); writechar(32);
  writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  EmitSvc;

  { mov x21, x0  - store heap base in x21 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;

  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitStrCopyRuntime;
var
  loop_lbl, done_lbl: integer;
begin
  { Copy string from x1 (source) to x0 (dest) }
  { Pascal strings: byte 0 = length, bytes 1..length = chars }
  EmitLabel(rt_str_copy);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save dest and source addresses }
  { stur x0, [x29, #-8] - dest }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL;
  { stur x1, [x29, #-16] - source }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  { Load length from source [x1] into x2 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;
  { Store length to dest [x0] }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  { Save length to [x29, #-24] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;

  { Initialize index to 0 }
  EmitMovX0(0);
  EmitSturX0(-32);

  { Loop: copy bytes 1..length }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop_lbl);

  { Load index }
  EmitLdurX0(-32);
  { Load length }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  { cmp x0, x2 - if index >= length, done }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  { b.ge done }
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(done_lbl);
  EmitNL;

  { x3 = index + 1 (offset into string) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Load source char: ldrb w4, [x1, x3] where x1 = source }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(51); writechar(93);  { x3] }
  EmitNL;

  { Store to dest char: strb w4, [x5, x3] where x5 = dest }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(53); writechar(44); writechar(32);  { [x5, }
  writechar(120); writechar(51); writechar(93);  { x3] }
  EmitNL;

  { Increment index }
  EmitLdurX0(-32);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-32);
  EmitBranchLabel(loop_lbl);

  EmitLabel(done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

procedure EmitStrCompareRuntime;
var
  loop_lbl, not_equal_lbl, done_lbl: integer;
begin
  { Compare strings at x0 and x1, return 1 if equal, 0 if not equal in x0 }
  EmitLabel(rt_str_compare);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save addresses }
  EmitSturX0(-8);  { string 1 }
  { stur x1, [x29, #-16] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  { Load lengths }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;

  { Compare lengths first }
  not_equal_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  { b.ne not_equal }
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne }
  writechar(76); write(not_equal_lbl);
  EmitNL;

  { Save length to [x29, #-24] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;

  { Initialize index to 0 }
  EmitMovX0(0);
  EmitSturX0(-32);

  { Loop: compare each byte }
  loop_lbl := NewLabel;
  EmitLabel(loop_lbl);

  { Load index }
  EmitLdurX0(-32);
  { Load length }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  { cmp x0, x2 - if index >= length, all equal }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  { b.ge equal (return 1) }
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(done_lbl);
  EmitNL;

  { x3 = index + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Load chars from both strings }
  EmitLdurX0(-8);  { string 1 addr }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(51); writechar(93);  { x3] }
  EmitNL;

  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(51); writechar(93);  { x3] }
  EmitNL;

  { Compare chars }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(53);  { x5 }
  EmitNL;
  { b.ne not_equal }
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne }
  writechar(76); write(not_equal_lbl);
  EmitNL;

  { Increment index }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-32);
  EmitBranchLabel(loop_lbl);

  { Equal - return 1 }
  EmitLabel(done_lbl);
  EmitMovX0(1);
  EmitBranchLabel(label_count);

  { Not equal - return 0 }
  EmitLabel(not_equal_lbl);
  EmitMovX0(0);

  EmitLabel(label_count);
  label_count := label_count + 1;
  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

procedure EmitStrConcatRuntime;
var
  loop1_lbl, loop2_lbl, done_lbl: integer;
begin
  { Concatenate strings: x0 = dest, x1 = string1, x2 = string2 }
  { Result length = len1 + len2 (capped at 255) }
  EmitLabel(rt_str_concat);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  { Save addresses }
  EmitSturX0(-8);   { dest }
  { stur x1, [x29, #-16] - string 1 }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  { stur x2, [x29, #-24] - string 2 }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;

  { Load lengths }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] - len1 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(50); writechar(93);  { [x2] - len2 }
  EmitNL;

  { Calculate total length (capped at 255) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(52);  { x4 }
  EmitNL;
  { cmp x5, #255 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(50); writechar(53); writechar(53);  { #255 }
  EmitNL;
  { csel x5, x5, x6, le - if x5 <= 255, keep it; else use 255 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(35); writechar(50); writechar(53); writechar(53);  { #255 }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(115); writechar(101); writechar(108); writechar(32);  { csel }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(108); writechar(101);  { le }
  EmitNL;

  { Store total length to dest }
  EmitLdurX0(-8);  { dest }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;

  { Save len1 to [x29, #-32] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;

  { Initialize index to 0 }
  EmitMovX0(0);
  EmitSturX0(-40);

  { Loop 1: copy string1 chars }
  loop1_lbl := NewLabel;
  loop2_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop1_lbl);

  { Load index and len1 }
  EmitLdurX0(-40);
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  { cmp x0, x3 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  { b.ge loop2 }
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(loop2_lbl);
  EmitNL;

  { x7 = index + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Load source1 char }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(56); writechar(44); writechar(32);  { w8, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(55); writechar(93);  { x7] }
  EmitNL;

  { Store to dest }
  EmitLdurX0(-8);
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(56); writechar(44); writechar(32);  { w8, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(55); writechar(93);  { x7] }
  EmitNL;

  { Increment index }
  EmitLdurX0(-40);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-40);
  EmitBranchLabel(loop1_lbl);

  { Loop 2: copy string2 chars }
  EmitLabel(loop2_lbl);
  { Reset index to 0 for string2 }
  EmitMovX0(0);
  EmitSturX0(-40);

  { Load len2 into x4 }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] - string2 addr }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(50); writechar(93);  { [x2] }
  EmitNL;
  { Save len2 to [x29, #-48] }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(56); writechar(93);  { #-48] }
  EmitNL;

  { Loop 2 body label }
  EmitLabel(label_count);
  label_count := label_count + 1;

  { Load index and len2 }
  EmitLdurX0(-40);
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(56); writechar(93);  { #-48] }
  EmitNL;
  { cmp x0, x4 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(52);  { x4 }
  EmitNL;
  { b.ge done }
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(done_lbl);
  EmitNL;

  { x7 = index + 1 (source offset) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Load source2 char }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(56); writechar(44); writechar(32);  { w8, }
  writechar(91); writechar(120); writechar(50); writechar(44); writechar(32);  { [x2, }
  writechar(120); writechar(55); writechar(93);  { x7] }
  EmitNL;

  { Calculate dest offset: len1 + index + 1 }
  EmitLdurX0(-40);  { index }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] - len1 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Store to dest }
  EmitLdurX0(-8);
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(56); writechar(44); writechar(32);  { w8, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(55); writechar(93);  { x7] }
  EmitNL;

  { Increment index }
  EmitLdurX0(-40);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-40);
  EmitBranchLabel(label_count - 1);

  EmitLabel(done_lbl);
  { Return dest address in x0 }
  EmitLdurX0(-8);
  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

procedure EmitStrCmpRuntime;
{ Lexicographic string comparison - returns -1 if x0<x1, 0 if x0=x1, 1 if x0>x1 }
{ Input: x0 = string1 addr, x1 = string2 addr }
{ Output: x0 = -1/0/1 }
var
  loop_lbl, done_lbl, less_lbl, greater_lbl, check_len_lbl: integer;
begin
  EmitLabel(rt_str_cmp);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);
  { stur x0, [x29, #-8]  - string1 }
  EmitSturX0(-8);
  { stur x1, [x29, #-16] - string2 }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  less_lbl := NewLabel;
  greater_lbl := NewLabel;
  check_len_lbl := NewLabel;

  { index = 0 }
  EmitMovX0(0);
  EmitSturX0(-24);

  EmitLabel(loop_lbl);

  { Load lengths }
  EmitLdurX0(-8);    { x0 = &s1 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;            { x2 = len1 }

  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;            { x3 = len2 }

  { Load index }
  EmitLdurX0(-24);   { x0 = index }

  { if index >= min(len1, len2), check length }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(check_len_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(check_len_lbl);
  EmitNL;

  { Compare chars at index+1 }
  { x4 = index + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Load char from s1 }
  EmitLdurX0(-8);
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(52); writechar(93);  { x4] }
  EmitNL;

  { Load char from s2 }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(54); writechar(44); writechar(32);  { w6, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(52); writechar(93);  { x4] }
  EmitNL;

  { Compare chars }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(54);  { x6 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(less_lbl);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
  writechar(76); write(greater_lbl);
  EmitNL;

  { Chars equal, increment index }
  EmitLdurX0(-24);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-24);
  EmitBranchLabel(loop_lbl);

  { Check lengths when all compared chars are equal }
  EmitLabel(check_len_lbl);
  EmitLdurX0(-8);
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(less_lbl);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
  writechar(76); write(greater_lbl);
  EmitNL;
  { Equal }
  EmitMovX0(0);
  EmitBranchLabel(done_lbl);

  EmitLabel(less_lbl);
  EmitMovX0(0);
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;  { x0 = -1 }
  EmitBranchLabel(done_lbl);

  EmitLabel(greater_lbl);
  EmitMovX0(1);

  EmitLabel(done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

procedure EmitStrPosRuntime;
{ Find substring position - returns position (1-based) or 0 if not found }
{ Input: x0 = substring addr, x1 = string addr }
{ Output: x0 = position (1-based) or 0 }
var
  outer_lbl, inner_lbl, done_lbl, found_lbl, not_found_lbl, next_pos_lbl: integer;
begin
  EmitLabel(rt_str_pos);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { [x29-8] = substr, [x29-16] = string, [x29-24] = outer idx, [x29-32] = inner idx }
  EmitSturX0(-8);
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  outer_lbl := NewLabel;
  inner_lbl := NewLabel;
  done_lbl := NewLabel;
  found_lbl := NewLabel;
  not_found_lbl := NewLabel;
  next_pos_lbl := NewLabel;

  { If substr is empty, return 1 }
  EmitLdurX0(-8);
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(98); writechar(122); writechar(32);  { cbz }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(76); write(found_lbl);
  EmitNL;
  { x2 = substr len }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(48); writechar(93);  { #-40] }
  EmitNL;

  { Load string length }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;
  { x3 = string len }

  { outer_idx = 0 (will be 1-based position - 1) }
  EmitMovX0(0);
  EmitSturX0(-24);

  EmitLabel(outer_lbl);
  { Check if outer_idx + substr_len > string_len }
  EmitLdurX0(-24);  { outer_idx }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(48); writechar(93);  { #-40] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  { x4 = outer_idx + substr_len }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
  writechar(76); write(not_found_lbl);
  EmitNL;

  { inner_idx = 0 }
  EmitMovX0(0);
  EmitSturX0(-32);

  EmitLabel(inner_lbl);
  { if inner_idx >= substr_len, found! }
  EmitLdurX0(-32);
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(48); writechar(93);  { #-40] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(found_lbl);
  EmitNL;

  { Compare substr[inner_idx+1] with string[outer_idx+inner_idx+1] }
  EmitLdurX0(-8);  { substr addr }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(52); writechar(93);  { x4] }
  EmitNL;
  { x5 = substr[inner_idx+1] }

  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitLdurX0(-24);  { outer_idx }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(52);  { x4 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(54); writechar(44); writechar(32);  { w6, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(52); writechar(93);  { x4] }
  EmitNL;
  { x6 = string[outer_idx+inner_idx+1] }

  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(54);  { x6 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne }
  writechar(76); write(next_pos_lbl);
  EmitNL;

  { Chars match, increment inner_idx }
  EmitLdurX0(-32);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-32);
  EmitBranchLabel(inner_lbl);

  EmitLabel(next_pos_lbl);
  { Chars don't match, try next outer position }
  EmitLdurX0(-24);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-24);
  EmitBranchLabel(outer_lbl);

  EmitLabel(found_lbl);
  { Return outer_idx + 1 (1-based position) }
  EmitLdurX0(-24);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitBranchLabel(done_lbl);

  EmitLabel(not_found_lbl);
  EmitMovX0(0);

  EmitLabel(done_lbl);
  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

procedure EmitStrDeleteRuntime;
{ Delete chars from string in place }
{ Input: x0 = string addr, x1 = start (1-based), x2 = count }
var
  loop_lbl, done_lbl: integer;
begin
  EmitLabel(rt_str_delete);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { [x29-8]=string, [x29-16]=start, [x29-24]=count, [x29-32]=len, [x29-40]=idx }
  EmitSturX0(-8);
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;

  loop_lbl := NewLabel;
  done_lbl := NewLabel;

  { Load string length }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  { x3 = len }

  { idx = start }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitSturX0(-40);

  EmitLabel(loop_lbl);
  { if idx + count > len, done }
  EmitLdurX0(-40);  { idx }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
  writechar(76); write(done_lbl);
  EmitNL;

  { Copy char from idx+count to idx }
  EmitLdurX0(-8);  { string addr }
  EmitLdurX0(-40);  { idx }
  { RELOAD string addr since we overwrote x0 }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  { x3 = idx + count (source position) }
  { Load char from string[idx+count] }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(51); writechar(93);  { x3] }
  EmitNL;
  { Store to string[idx] }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(48); writechar(93);  { x0] }
  EmitNL;

  { idx++ }
  EmitLdurX0(-40);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-40);
  EmitBranchLabel(loop_lbl);

  EmitLabel(done_lbl);
  { Update string length: new_len = old_len - count }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitLdurX0(-8);
  { RELOAD x0 for store since we overwrote it }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;

  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

procedure EmitStrInsertRuntime;
{ Insert string into another at position }
{ Input: x0 = source string, x1 = dest string, x2 = position (1-based) }
var
  loop1_lbl, loop2_lbl, copy_lbl, done_lbl: integer;
begin
  EmitLabel(rt_str_insert);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);
  { [x29-8]=source, [x29-16]=dest, [x29-24]=pos, [x29-32]=src_len, [x29-40]=dst_len, [x29-48]=idx }
  EmitSturX0(-8);
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;

  loop1_lbl := NewLabel;
  loop2_lbl := NewLabel;
  copy_lbl := NewLabel;
  done_lbl := NewLabel;

  { Load lengths }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;  { src_len }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(48); writechar(93);  { #-40] }
  EmitNL;  { dst_len }

  { Move existing chars from pos to end, shifting right by src_len }
  { idx = dst_len }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(56); writechar(93);  { #-48] }
  EmitNL;

  EmitLabel(loop1_lbl);
  { if idx < pos, done moving }
  EmitLdurX0(-48);  { idx }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(loop2_lbl);
  EmitNL;

  { Copy dest[idx] to dest[idx+src_len] }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(48); writechar(93);  { x0] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(54); writechar(93);  { x6] }
  EmitNL;

  { idx-- }
  EmitLdurX0(-48);
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-48);
  EmitBranchLabel(loop1_lbl);

  EmitLabel(loop2_lbl);
  { Now copy source chars to position pos...pos+src_len-1 }
  { idx = 0 }
  EmitMovX0(0);
  EmitSturX0(-48);

  EmitLabel(copy_lbl);
  { if idx >= src_len, done }
  EmitLdurX0(-48);
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(done_lbl);
  EmitNL;

  { Copy source[idx+1] to dest[pos+idx] }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(56); writechar(93);  { #-8] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(55); writechar(44); writechar(32);  { w7, }
  writechar(91); writechar(120); writechar(53); writechar(44); writechar(32);  { [x5, }
  writechar(120); writechar(54); writechar(93);  { x6] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(50); writechar(52); writechar(93);  { #-24] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(55); writechar(44); writechar(32);  { w7, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(54); writechar(93);  { x6] }
  EmitNL;

  { idx++ }
  EmitLdurX0(-48);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitSturX0(-48);
  EmitBranchLabel(copy_lbl);

  EmitLabel(done_lbl);
  { Update dest length: new_len = dst_len + src_len }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(51); writechar(50); writechar(93);  { #-32] }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(52); writechar(48); writechar(93);  { #-40] }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(52);  { x4 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;

  EmitAddSP(64);
  EmitLdp;
  EmitRet
end;

{ EmitIntToStrRuntime - Convert integer to string }
{ x0 = integer value, x1 = destination string address }
procedure EmitIntToStrRuntime;
var
  done_lbl, neg_lbl, pos_lbl, loop_lbl, rev_lbl, rev_done_lbl: integer;
begin
  EmitLabel(rt_int_to_str);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  done_lbl := NewLabel;
  neg_lbl := NewLabel;
  pos_lbl := NewLabel;
  loop_lbl := NewLabel;
  rev_lbl := NewLabel;
  rev_done_lbl := NewLabel;

  { Save dest string address }
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  { x2 = digit count, x3 = is_negative }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { Check if value is negative }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(neg_lbl);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(pos_lbl);
  EmitNL;

  { Handle negative }
  EmitLabel(neg_lbl);
  EmitIndent;
  writechar(110); writechar(101); writechar(103); writechar(32);  { neg }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Loop to extract digits (stored in reverse on stack) }
  EmitLabel(pos_lbl);
  EmitLabel(loop_lbl);
  { x4 = x0 / 10, x5 = x0 mod 10 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(117); writechar(100); writechar(105); writechar(118); writechar(32);  { udiv }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(54);  { x6 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(115); writechar(117); writechar(98); writechar(32);  { msub }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;

  { Convert digit to ASCII and store on stack }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;

  { Store digit at sp + x2 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(120); writechar(50); writechar(93);  { x2] }
  EmitNL;

  { Increment digit count }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { x0 = x4 (quotient), continue if x0 > 0 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(52);  { x4 }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne }
  writechar(76); write(loop_lbl);
  EmitNL;

  { Now reverse digits into destination string }
  { x1 = dest string, x4 = write position (starts at 1 if no sign, 2 if negative) }
  EmitIndent;
  writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { [x29, }
  writechar(35); writechar(45); writechar(49); writechar(54); writechar(93);  { #-16] }
  EmitNL;

  { If negative, store '-' at position 1, start digits at 2 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(rev_lbl);
  EmitNL;

  { Store '-' sign }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(35); writechar(52); writechar(53);  { #45 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(35); writechar(49); writechar(93);  { #1] }
  EmitNL;

  { x4 = write position (1 for positive, 2 for negative start) }
  EmitLabel(rev_lbl);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { x5 = read position (digit count - 1, reading backwards) }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Reverse copy loop }
  EmitLabel(rev_done_lbl);
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(done_lbl);
  EmitNL;

  { Load digit from stack at position x5 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(54); writechar(44); writechar(32);  { w6, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(120); writechar(53); writechar(93);  { x5] }
  EmitNL;

  { Store at dest position x4 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(54); writechar(44); writechar(32);  { w6, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(52); writechar(93);  { x4] }
  EmitNL;

  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(rev_done_lbl);
  EmitNL;

  { Store length (x2 + x3 = digit count + sign) }
  EmitLabel(done_lbl);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;

  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

{ EmitStrToIntRuntime - Convert string to integer }
{ x0 = source string address }
{ Returns: x0 = integer value, x1 = error code (0 = success, position of error otherwise) }
procedure EmitStrToIntRuntime;
var
  done_lbl, error_lbl, loop_lbl, neg_lbl, pos_lbl, skip_sign_lbl, exit_lbl: integer;
begin
  EmitLabel(rt_str_to_int);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  done_lbl := NewLabel;
  error_lbl := NewLabel;
  loop_lbl := NewLabel;
  neg_lbl := NewLabel;
  pos_lbl := NewLabel;
  skip_sign_lbl := NewLabel;
  exit_lbl := NewLabel;

  { x1 = length, x2 = index (starts at 1), x3 = result, x4 = is_negative }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(49); writechar(44); writechar(32);  { w1, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { Check if empty string }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(error_lbl);
  EmitNL;

  { Check first char for sign }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(35); writechar(49); writechar(93);  { #1] }
  EmitNL;

  { Check for '-' (45) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(52); writechar(53);  { #45 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(neg_lbl);
  EmitNL;

  { Check for '+' (43) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(52); writechar(51);  { #43 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(pos_lbl);
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(loop_lbl);
  EmitNL;

  EmitLabel(neg_lbl);
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitLabel(pos_lbl);
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Main loop }
  EmitLabel(loop_lbl);
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(49);  { x1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
  writechar(76); write(done_lbl);
  EmitNL;

  { Load char at position x2 }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(50); writechar(93);  { x2] }
  EmitNL;

  { Check if digit (48-57) }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76); write(error_lbl);
  EmitNL;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(53); writechar(55);  { #57 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
  writechar(76); write(error_lbl);
  EmitNL;

  { result = result * 10 + digit }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(54);  { x6 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(53);  { x5 }
  EmitNL;

  { x2 := x2 + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(loop_lbl);
  EmitNL;

  { Success }
  EmitLabel(done_lbl);
  { Apply sign if negative }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(skip_sign_lbl);
  EmitNL;
  EmitIndent;
  writechar(110); writechar(101); writechar(103); writechar(32);  { neg }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;

  EmitLabel(skip_sign_lbl);
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(exit_lbl);
  EmitNL;

  { Error - return position in x1 }
  EmitLabel(error_lbl);
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;

  EmitLabel(exit_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

{ EmitStrLtrimRuntime - Remove leading whitespace from string }
{ Input: x0 = source string addr }
{ Output: x0 = new trimmed string addr (allocated from heap) }
procedure EmitStrLtrimRuntime;
var
  loop_lbl, done_lbl, copy_lbl, copy_done_lbl: integer;
begin
  EmitLabel(rt_str_ltrim);
  EmitStp;
  EmitSubSP(32);

  { x1 = source addr, x2 = source length, x3 = skip count }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  copy_lbl := NewLabel;
  copy_done_lbl := NewLabel;

  { Save source addr }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;

  { x2 = source length }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;

  { x3 = 0 (skip count) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { Loop: skip leading whitespace }
  EmitLabel(loop_lbl);
  { if x3 >= x2, done }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(done_lbl);
  EmitNL;

  { x4 = char at [x1 + x3 + 1] }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(52); writechar(93);  { x4] }
  EmitNL;

  { if char = 32 (space), skip }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(51); writechar(50);  { #32 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(label_count);
  EmitNL;

  { if char = 9 (tab), skip }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(57);  { #9 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne }
  writechar(76); write(done_lbl);
  EmitNL;

  EmitLabel(label_count);
  label_count := label_count + 1;

  { x3 := x3 + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(loop_lbl);
  EmitNL;

  { Done scanning: x3 = number to skip, x2 = length }
  EmitLabel(done_lbl);

  { Allocate new string from heap: x0 = x21 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50); writechar(49);  { x21 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
  writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
  EmitNL;

  { x5 = new length = x2 - x3 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;

  { Store new length }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(53); writechar(44); writechar(32);  { w5, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;

  { x6 = copy index (0 to x5-1) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { Copy loop }
  EmitLabel(copy_lbl);
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(120); writechar(53);  { x5 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(copy_done_lbl);
  EmitNL;

  { x7 = x3 + x6 + 1 (source index) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(54);  { x6 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Load char }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(56); writechar(44); writechar(32);  { w8, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(55); writechar(93);  { x7] }
  EmitNL;

  { x7 = x6 + 1 (dest index) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(55); writechar(44); writechar(32);  { x7, }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Store char }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(56); writechar(44); writechar(32);  { w8, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(55); writechar(93);  { x7] }
  EmitNL;

  { x6 := x6 + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(copy_lbl);
  EmitNL;

  EmitLabel(copy_done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

{ EmitStrRtrimRuntime - Remove trailing whitespace from string }
{ Input: x0 = source string addr }
{ Output: x0 = new trimmed string addr (allocated from heap) }
procedure EmitStrRtrimRuntime;
var
  loop_lbl, done_lbl, copy_lbl, copy_done_lbl: integer;
begin
  EmitLabel(rt_str_rtrim);
  EmitStp;
  EmitSubSP(32);

  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  copy_lbl := NewLabel;
  copy_done_lbl := NewLabel;

  { x1 = source addr }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;

  { x2 = source length }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(50); writechar(44); writechar(32);  { w2, }
  writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
  EmitNL;

  { x3 = x2 (scan from end) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(50);  { x2 }
  EmitNL;

  { Loop: find last non-whitespace }
  EmitLabel(loop_lbl);
  { if x3 <= 0, done }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(101); writechar(32);  { b.le }
  writechar(76); write(done_lbl);
  EmitNL;

  { x4 = char at [x1 + x3] }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(52); writechar(44); writechar(32);  { w4, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(51); writechar(93);  { x3] }
  EmitNL;

  { if char = 32 (space), continue }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(51); writechar(50);  { #32 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
  writechar(76); write(label_count);
  EmitNL;

  { if char = 9 (tab), continue }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(35); writechar(57);  { #9 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(110); writechar(101); writechar(32);  { b.ne }
  writechar(76); write(done_lbl);
  EmitNL;

  EmitLabel(label_count);
  label_count := label_count + 1;

  { x3 := x3 - 1 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(loop_lbl);
  EmitNL;

  { Done: x3 = new length }
  EmitLabel(done_lbl);

  { Allocate new string from heap }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(50); writechar(49);  { x21 }
  EmitNL;
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
  writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
  writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
  EmitNL;

  { Store new length }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
  writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
  EmitNL;

  { x5 = copy index (0 to x3-1) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { Copy loop }
  EmitLabel(copy_lbl);
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(51);  { x3 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
  writechar(76); write(copy_done_lbl);
  EmitNL;

  { x6 = x5 + 1 (index) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(54); writechar(44); writechar(32);  { x6, }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { Load char from source }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
  writechar(119); writechar(55); writechar(44); writechar(32);  { w7, }
  writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
  writechar(120); writechar(54); writechar(93);  { x6] }
  EmitNL;

  { Store char to dest }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(55); writechar(44); writechar(32);  { w7, }
  writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
  writechar(120); writechar(54); writechar(93);  { x6] }
  EmitNL;

  { x5 := x5 + 1 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(32);  { b }
  writechar(76); write(copy_lbl);
  EmitNL;

  EmitLabel(copy_done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

{ EmitStrTrimRuntime - Remove both leading and trailing whitespace }
{ Input: x0 = source string addr }
{ Output: x0 = new trimmed string addr }
procedure EmitStrTrimRuntime;
begin
  EmitLabel(rt_str_trim);
  EmitStp;
  EmitSubSP(16);

  { Call ltrim first }
  EmitBL(rt_str_ltrim);

  { Then call rtrim on result }
  EmitBL(rt_str_rtrim);

  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

{ ----- Screen/Terminal Control Routines ----- }

procedure EmitStrbAtOffset(offset: integer);
{ Emit: sturb w0, [x29, #offset] - stores low byte of w0 at x29+offset }
begin
  EmitIndent;
  writechar(115); writechar(116); writechar(117); writechar(114);  { stur }
  writechar(98); writechar(32);  { b }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(50); writechar(57);  { [x29 }
  writechar(44); writechar(32); writechar(35);  { , # }
  write(offset);
  writechar(93);  { ] }
  EmitNL
end;

procedure EmitClrScrRuntime;
{ Emits code to clear screen and home cursor: ESC[2J ESC[H }
begin
  EmitLabel(rt_clrscr);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store escape sequence on stack: ESC[2J ESC[H = 27,91,50,74,27,91,72 }
  { Use sturb to store individual bytes }
  EmitMovX0(27);       { ESC }
  EmitStrbAtOffset(-15);
  EmitMovX0(91);       { [ }
  EmitStrbAtOffset(-14);
  EmitMovX0(50);       { 2 }
  EmitStrbAtOffset(-13);
  EmitMovX0(74);       { J }
  EmitStrbAtOffset(-12);
  EmitMovX0(27);       { ESC }
  EmitStrbAtOffset(-11);
  EmitMovX0(91);       { [ }
  EmitStrbAtOffset(-10);
  EmitMovX0(72);       { H }
  EmitStrbAtOffset(-9);
  { Write syscall: x0=fd, x1=buf, x2=count }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #15 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(53);  { #15 }
  EmitNL;
  { mov x2, #7 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(55);  { #7 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitGotoXYRuntime;
{ Emits code to move cursor: ESC[y;xH }
{ x1=x (column), x0=y (row) }
var
  loop1, done1, loop2, done2, end_lbl: integer;
begin
  EmitLabel(rt_gotoxy);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { Save x and y to registers first to avoid memory corruption }
  { x11 = y (row), x12 = x (column) - using higher regs to avoid conflicts with division }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(49); writechar(44); writechar(32);  { x11, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(50); writechar(44); writechar(32);  { x12, }
  writechar(120); writechar(49);  { x1 }
  EmitNL;
  { Build escape sequence at stack offset -20 onwards (leave room for digits) }
  { Format: ESC [ y ; x H }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-20);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-19);
  { x8 = pointer to next byte (start at -18) }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(56);  { #18 }
  EmitNL;
  { Convert y to decimal digits (y is in x11) }
  { mov x0, x11 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49); writechar(49);  { x11 }
  EmitNL;
  { If y >= 10, output tens digit }
  loop1 := NewLabel;
  done1 := NewLabel;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76);
  write(done1);
  EmitNL;
  { Divide by 10: x1 = x0 / 10, x2 = x0 mod 10 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(117); writechar(100); writechar(105); writechar(118); writechar(32);  { udiv }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(57);  { x9 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(115); writechar(117); writechar(98); writechar(32);  { msub }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  { x1=tens, x0=units - store tens digit }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  { strb w1, [x8], #1 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(49); writechar(44); writechar(32);  { w1, }
  writechar(91); writechar(120); writechar(56); writechar(93); writechar(44); writechar(32);  { [x8], }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitLabel(done1);
  { Store units digit }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  { strb w0, [x8], #1 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(56); writechar(93); writechar(44); writechar(32);  { [x8], }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  { Store semicolon }
  EmitMovX0(59);  { ; }
  { strb w0, [x8], #1 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(56); writechar(93); writechar(44); writechar(32);  { [x8], }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  { Convert x to decimal digits (x is in x12) }
  { mov x0, x12 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49); writechar(50);  { x12 }
  EmitNL;
  done2 := NewLabel;
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
  writechar(76);
  write(done2);
  EmitNL;
  { Divide by 10 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(35); writechar(49); writechar(48);  { #10 }
  EmitNL;
  EmitIndent;
  writechar(117); writechar(100); writechar(105); writechar(118); writechar(32);  { udiv }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(57);  { x9 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(115); writechar(117); writechar(98); writechar(32);  { msub }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  { Store tens digit }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  { strb w1, [x8], #1 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(49); writechar(44); writechar(32);  { w1, }
  writechar(91); writechar(120); writechar(56); writechar(93); writechar(44); writechar(32);  { [x8], }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitLabel(done2);
  { Store units digit }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  { strb w0, [x8], #1 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(56); writechar(93); writechar(44); writechar(32);  { [x8], }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  { Store H terminator }
  EmitMovX0(72);  { H }
  { strb w0, [x8] }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
  writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
  EmitNL;
  { Calculate length: x8 points past last byte, buffer starts at x29-20 }
  { add x8, x8, #1 (point past H) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
  writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  { x2 = x8 - (x29-20) = x8 - x29 + 20 }
  { sub x2, x8, x29 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;
  { add x2, x2, #20 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(50); writechar(48);  { #20 }
  EmitNL;
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #20 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(50); writechar(48);  { #20 }
  EmitNL;
  EmitSvc;
  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

procedure EmitClrEolRuntime;
{ Emits code to clear to end of line: ESC[K }
begin
  EmitLabel(rt_clreol);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[K = 27,91,75 }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-11);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-10);
  EmitMovX0(75);  { K }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #11 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(49);  { #11 }
  EmitNL;
  { mov x2, #3 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(51);  { #3 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitTextColorRuntime;
{ Emits code to set foreground color: ESC[3Xm where X=x0 (0-7) }
begin
  EmitLabel(rt_textcolor);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Save color parameter (x0) to x9 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  { Store ESC[3Xm = 27,91,51,X,109 (5 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-13);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-12);
  EmitMovX0(51);  { 3 }
  EmitStrbAtOffset(-11);
  { Store color digit: x9 + 48 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  EmitStrbAtOffset(-10);
  { Store 'm' }
  EmitMovX0(109);  { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #13 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(51);  { #13 }
  EmitNL;
  { mov x2, #5 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(53);  { #5 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitTextBackgroundRuntime;
{ Emits code to set background color: ESC[4Xm where X=x0 (0-7) }
begin
  EmitLabel(rt_textbackground);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Save color parameter (x0) to x9 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;
  { Store ESC[4Xm = 27,91,52,X,109 (5 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-13);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-12);
  EmitMovX0(52);  { 4 }
  EmitStrbAtOffset(-11);
  { Store color digit: x9 + 48 }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
  writechar(35); writechar(52); writechar(56);  { #48 }
  EmitNL;
  EmitStrbAtOffset(-10);
  { Store 'm' }
  EmitMovX0(109);  { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #13 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(51);  { #13 }
  EmitNL;
  { mov x2, #5 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(53);  { #5 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitNormVideoRuntime;
{ Emits code to reset attributes: ESC[0m }
begin
  EmitLabel(rt_normvideo);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[0m = 27,91,48,109 (4 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-12);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-11);
  EmitMovX0(48);  { 0 }
  EmitStrbAtOffset(-10);
  EmitMovX0(109); { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #12 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(50);  { #12 }
  EmitNL;
  { mov x2, #4 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(52);  { #4 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitHighVideoRuntime;
{ Emits code to enable bold: ESC[1m }
begin
  EmitLabel(rt_highvideo);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[1m = 27,91,49,109 (4 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-12);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-11);
  EmitMovX0(49);  { 1 }
  EmitStrbAtOffset(-10);
  EmitMovX0(109); { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #12 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(50);  { #12 }
  EmitNL;
  { mov x2, #4 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(52);  { #4 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitLowVideoRuntime;
{ Emits code to enable dim: ESC[2m }
begin
  EmitLabel(rt_lowvideo);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[2m = 27,91,50,109 (4 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-12);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-11);
  EmitMovX0(50);  { 2 }
  EmitStrbAtOffset(-10);
  EmitMovX0(109); { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #12 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(50);  { #12 }
  EmitNL;
  { mov x2, #4 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(52);  { #4 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitHideCursorRuntime;
{ Emits code to hide cursor: ESC[?25l }
begin
  EmitLabel(rt_hidecursor);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[?25l = 27,91,63,50,53,108 (6 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-14);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-13);
  EmitMovX0(63);  { ? }
  EmitStrbAtOffset(-12);
  EmitMovX0(50);  { 2 }
  EmitStrbAtOffset(-11);
  EmitMovX0(53);  { 5 }
  EmitStrbAtOffset(-10);
  EmitMovX0(108); { l }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #14 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(52);  { #14 }
  EmitNL;
  { mov x2, #6 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(54);  { #6 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitShowCursorRuntime;
{ Emits code to show cursor: ESC[?25h }
begin
  EmitLabel(rt_showcursor);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[?25h = 27,91,63,50,53,104 (6 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-14);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-13);
  EmitMovX0(63);  { ? }
  EmitStrbAtOffset(-12);
  EmitMovX0(50);  { 2 }
  EmitStrbAtOffset(-11);
  EmitMovX0(53);  { 5 }
  EmitStrbAtOffset(-10);
  EmitMovX0(104); { h }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #14 }
  EmitIndent;
  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
  writechar(35); writechar(49); writechar(52);  { #14 }
  EmitNL;
  { mov x2, #6 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(54);  { #6 }
  EmitNL;
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
end;

procedure EmitSleepRuntime;
{ Emits code to sleep for x0 milliseconds using select syscall }
{ x0 = milliseconds }
{ select(0, NULL, NULL, NULL, &timeval) with nfds=0, all fd_sets=NULL }
{ struct timeval: tv_sec (8 bytes), tv_usec (8 bytes) }
begin
  EmitLabel(rt_sleep);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);  { 16 bytes for timeval + alignment }

  { x10 = ms (save original) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(120); writechar(48);  { x0 }
  EmitNL;

  { x11 = 1000 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(49); writechar(44); writechar(32);  { x11, }
  writechar(35); writechar(49); writechar(48); writechar(48); writechar(48);  { #1000 }
  EmitNL;

  { x0 = ms / 1000 (seconds) }
  EmitIndent;
  writechar(117); writechar(100); writechar(105); writechar(118); writechar(32);  { udiv }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(120); writechar(49); writechar(49);  { x11 }
  EmitNL;

  { x1 = ms mod 1000 (remainder): msub x1, x0, x11, x10 = x10 - (x0 * x11) }
  EmitIndent;
  writechar(109); writechar(115); writechar(117); writechar(98); writechar(32);  { msub }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(120); writechar(49); writechar(49); writechar(44); writechar(32);  { x11, }
  writechar(120); writechar(49); writechar(48);  { x10 }
  EmitNL;

  { x1 = x1 * 1000 (microseconds, not nanoseconds for timeval) }
  EmitIndent;
  writechar(109); writechar(117); writechar(108); writechar(32);  { mul }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(120); writechar(49); writechar(49);  { x11 (x11 is still 1000) }
  EmitNL;

  { Store timeval at sp: [sp] = tv_sec, [sp+8] = tv_usec }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
  EmitNL;

  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(56); writechar(93);  { #8] }
  EmitNL;

  { select(nfds=0, readfds=NULL, writefds=NULL, exceptfds=NULL, timeout=sp) }
  { x0 = 0 (nfds) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x1 = NULL }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x2 = NULL }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x3 = NULL }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x4 = pointer to timeval (sp) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(115); writechar(112);  { sp }
  EmitNL;

  { x16 = syscall number for select: 0x2000000 + 93 = 33554525 }
  EmitMovX16(33554525);
  EmitSvc;

  EmitAddSP(32);
  EmitLdp;
  EmitRet
end;

procedure EmitKeyPressedRuntime;
{ Check if a key is available on stdin using select with 0 timeout }
{ Returns 1 in x0 if key available, 0 otherwise }
begin
  EmitLabel(rt_keypressed);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);  { 8 bytes for fd_set + 16 bytes for timeval + padding }

  { Clear the fd_set at sp }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
  EmitNL;

  { Set bit 0 in fd_set for stdin (fd 0) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
  EmitNL;

  { Set timeval to 0,0 (no wait) at sp+16 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(49); writechar(54); writechar(93);  { #16] }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(50); writechar(52); writechar(93);  { #24] }
  EmitNL;

  { select(nfds=1, readfds=sp, writefds=NULL, exceptfds=NULL, timeout=sp+16) }
  { x0 = 1 (nfds) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;

  { x1 = sp (readfds) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(115); writechar(112);  { sp }
  EmitNL;

  { x2 = NULL }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x3 = NULL }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x4 = sp + 16 (timeout) }
  EmitIndent;
  writechar(97); writechar(100); writechar(100); writechar(32);  { add }
  writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
  writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  { x16 = syscall number for select: 0x2000000 + 93 = 33554525 }
  EmitMovX16(33554525);
  EmitSvc;

  { select returns number of ready fds in x0, or -1 on error }
  { If x0 > 0, key is available; convert to 0 or 1 }
  EmitIndent;
  writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(99); writechar(115); writechar(101); writechar(116); writechar(32);  { cset }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(103); writechar(116);  { gt }
  EmitNL;

  EmitAddSP(48);
  EmitLdp;
  EmitRet
end;

procedure EmitInitKeyboardRuntime;
{ Set terminal to raw mode for immediate key reading }
{ Uses ioctl TIOCGETA to get, then TIOCSETA to set with ICANON and ECHO cleared }
begin
  EmitLabel(rt_initkeyboard);
  EmitStp;
  EmitMovFP;
  EmitSubSP(80);  { Space for termios structure (72 bytes aligned to 80) }

  { First get current terminal settings: ioctl(0, TIOCGETA, sp) }
  { x0 = 0 (stdin) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x1 = TIOCGETA = 0x40487413 }
  { movz x1, #0x7413 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(55); writechar(52); writechar(49); writechar(51);  { #0x7413 }
  EmitNL;
  { movk x1, #0x4048, lsl #16 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(52); writechar(48); writechar(52); writechar(56);  { #0x4048 }
  writechar(44); writechar(32); writechar(108); writechar(115); writechar(108); writechar(32);  { , lsl }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  { x2 = sp (pointer to termios buffer) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(115); writechar(112);  { sp }
  EmitNL;

  { ioctl syscall: 0x2000000 + 54 = 33554486 }
  EmitMovX16(33554486);
  EmitSvc;

  { Save original c_lflag (at offset 24) to x23 (callee-saved) for later restore }
  EmitIndent;
  writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);  { x23, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(50); writechar(52); writechar(93);  { #24] }
  EmitNL;

  { Clear ICANON (0x100 = 256) and ECHO (0x8) from c_lflag }
  { Load current c_lflag into x10 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(120); writechar(50); writechar(51);  { x23 }
  EmitNL;

  { x11 = 0x108 (ICANON | ECHO) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(49); writechar(44); writechar(32);  { x11, }
  writechar(35); writechar(48); writechar(120); writechar(49); writechar(48); writechar(56);  { #0x108 }
  EmitNL;

  { bic x10, x10, x11 (clear bits) }
  EmitIndent;
  writechar(98); writechar(105); writechar(99); writechar(32);  { bic }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(120); writechar(49); writechar(49);  { x11 }
  EmitNL;

  { Store modified c_lflag back }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(50); writechar(52); writechar(93);  { #24] }
  EmitNL;

  { Set VMIN (c_cc[16]) to 1 and VTIME (c_cc[17]) to 0 }
  { c_cc starts at offset 32, so VMIN is at 32+16=48, VTIME at 32+17=49 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(35); writechar(49);  { #1 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(49); writechar(48); writechar(44); writechar(32);  { w10, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(52); writechar(56); writechar(93);  { #48] }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(49); writechar(48); writechar(44); writechar(32);  { x10, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
  writechar(119); writechar(49); writechar(48); writechar(44); writechar(32);  { w10, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(52); writechar(57); writechar(93);  { #49] }
  EmitNL;

  { Now set the modified settings: ioctl(0, TIOCSETA, sp) }
  { x0 = 0 (stdin) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x1 = TIOCSETA = 0x80487414 }
  { movz x1, #0x7414 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(55); writechar(52); writechar(49); writechar(52);  { #0x7414 }
  EmitNL;
  { movk x1, #0x8048, lsl #16 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(56); writechar(48); writechar(52); writechar(56);  { #0x8048 }
  writechar(44); writechar(32); writechar(108); writechar(115); writechar(108); writechar(32);  { , lsl }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  { x2 = sp }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(115); writechar(112);  { sp }
  EmitNL;

  EmitMovX16(33554486);
  EmitSvc;

  EmitAddSP(80);
  EmitLdp;
  EmitRet
end;

procedure EmitDoneKeyboardRuntime;
{ Restore terminal to normal (cooked) mode }
begin
  EmitLabel(rt_donekeyboard);
  EmitStp;
  EmitMovFP;
  EmitSubSP(80);

  { Get current settings first }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x1 = TIOCGETA = 0x40487413 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(55); writechar(52); writechar(49); writechar(51);  { #0x7413 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(52); writechar(48); writechar(52); writechar(56);  { #0x4048 }
  writechar(44); writechar(32); writechar(108); writechar(115); writechar(108); writechar(32);  { , lsl }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(115); writechar(112);  { sp }
  EmitNL;

  EmitMovX16(33554486);
  EmitSvc;

  { Restore original c_lflag from x23 }
  EmitIndent;
  writechar(115); writechar(116); writechar(114); writechar(32);  { str }
  writechar(120); writechar(50); writechar(51); writechar(44); writechar(32);  { x23, }
  writechar(91); writechar(115); writechar(112); writechar(44); writechar(32);  { [sp, }
  writechar(35); writechar(50); writechar(52); writechar(93);  { #24] }
  EmitNL;

  { Set the restored settings }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
  writechar(35); writechar(48);  { #0 }
  EmitNL;

  { x1 = TIOCSETA = 0x80487414 }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(122); writechar(32);  { movz }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(55); writechar(52); writechar(49); writechar(52);  { #0x7414 }
  EmitNL;
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(107); writechar(32);  { movk }
  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
  writechar(35); writechar(48); writechar(120); writechar(56); writechar(48); writechar(52); writechar(56);  { #0x8048 }
  writechar(44); writechar(32); writechar(108); writechar(115); writechar(108); writechar(32);  { , lsl }
  writechar(35); writechar(49); writechar(54);  { #16 }
  EmitNL;

  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
  writechar(115); writechar(112);  { sp }
  EmitNL;

  EmitMovX16(33554486);
  EmitSvc;

  EmitAddSP(80);
  EmitLdp;
  EmitRet
end;

{ ----- Parser ----- }

procedure ParseExpression; forward;
procedure ParseStatement; forward;

procedure Expect(t: integer);
begin
  if tok_type <> t then
    Error(2);
  NextToken
end;

function Match(t: integer): integer;
begin
  if tok_type = t then
  begin
    NextToken;
    Match := 1
  end
  else
    Match := 0
end;

procedure ParseFactor;
var
  idx, arg_count, i, lbl1: integer;
  var_flags, var_arg_idx: integer;
begin
  if tok_type = TOK_INTEGER then
  begin
    EmitMovX0(tok_int);
    expr_type := TYPE_INTEGER;
    NextToken
  end
  else if tok_type = TOK_FLOAT_LITERAL then
  begin
    { Construct float at runtime: int_part + frac_part/1000000 }
    { Load integer part and convert to float }
    EmitMovX0(tok_float_int);
    EmitScvtfD0X0;
    { Load fractional part and convert to float }
    EmitPushD0;
    EmitMovX0(tok_float_frac);
    EmitScvtfD0X0;
    { Divide by 1000000 }
    EmitPushD0;
    EmitMovX0(1000000);
    EmitScvtfD0X0;
    EmitPopD1;
    EmitFDiv;  { d0 = d1 / d0 = frac / 1000000 }
    { Add integer part }
    EmitPopD1;
    EmitFAdd;  { d0 = d1 + d0 = int + frac }
    expr_type := TYPE_REAL;
    NextToken
  end
  else if tok_type = TOK_TRUE then
  begin
    EmitMovX0(1);
    expr_type := TYPE_INTEGER;
    NextToken
  end
  else if tok_type = TOK_FALSE then
  begin
    EmitMovX0(0);
    expr_type := TYPE_INTEGER;
    NextToken
  end
  else if tok_type = TOK_LPAREN then
  begin
    NextToken;
    ParseExpression;
    Expect(TOK_RPAREN)
    { expr_type is already set by ParseExpression }
  end
  else if tok_type = TOK_NOT then
  begin
    NextToken;
    ParseFactor;
    EmitEorX0(1);
    expr_type := TYPE_INTEGER  { not always returns boolean/int }
  end
  else if tok_type = TOK_NIL then
  begin
    EmitMovX0(0);  { nil = 0 }
    expr_type := TYPE_POINTER;
    NextToken
  end
  else if tok_type = TOK_STRING then
  begin
    { String literal in expression }
    if tok_len = 1 then
    begin
      { Single character - treat as char/integer }
      EmitMovX0(tok_str[0]);
      expr_type := TYPE_CHAR
    end
    else
    begin
      { Multi-char string - allocate temp from heap and store string }
      { mov x8, x21 ; store string base to x8 }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
      writechar(120); writechar(50); writechar(49);  { x21 }
      EmitNL;
      { Store length byte }
      EmitMovX0(tok_len);
      EmitIndent;
      writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
      writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
      writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
      EmitNL;
      { Store each character }
      for i := 0 to tok_len - 1 do
      begin
        EmitMovX0(tok_str[i]);
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
        writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
        writechar(35);
        write(i + 1);
        writechar(93);  { ] }
        EmitNL
      end;
      { mov x0, x21 ; return string address }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(50); writechar(49);  { x21 }
      EmitNL;
      { add x21, x21, #256 ; advance heap pointer }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
      EmitNL;
      expr_type := TYPE_STRING
    end;
    NextToken
  end
  else if tok_type = TOK_AT then
  begin
    NextToken;
    if tok_type <> TOK_IDENT then
      Error(6);  { expected identifier }
    idx := SymLookup;
    if idx < 0 then
      Error(3);  { undefined identifier }
    NextToken;
    if (sym_type[idx] = TYPE_ARRAY) and (tok_type = TOK_LBRACKET) then
    begin
      { Address of array element: @arr[index] }
      NextToken;  { consume '[' }
      ParseExpression;  { index in x0 }
      Expect(TOK_RBRACKET);
      { Subtract low bound }
      EmitPushX0;
      EmitMovX0(sym_const_val[idx]);  { low bound }
      EmitPopX1;
      { x0 = x1 - x0 = index - low_bound }
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      { Multiply by 8 (element size) using lsl #3 }
      EmitIndent;
      writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(51);  { #3 }
      EmitNL;
      { Get base address }
      if sym_level[idx] < scope_level then
      begin
        EmitFollowChain(sym_level[idx], scope_level);
        EmitSubLargeOffset(1, 8, 0 - sym_offset[idx])
      end
      else
        EmitSubLargeOffset(1, 29, 0 - sym_offset[idx]);
      { Address = base - element_offset }
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(120); writechar(48);  { x0 }
      EmitNL
    end
    else
      EmitVarAddr(idx, scope_level);
    expr_type := TYPE_POINTER;
    ptr_base_type := sym_type[idx]
  end
  else if tok_type = TOK_IDENT then
  begin
    { Check for built-in functions: readchar, keypressed, ord, chr }
    { readchar = 114,101,97,100,99,104,97,114 }
    if TokIs8(114, 101, 97, 100, 99, 104, 97, 114) = 1 then
    begin
      NextToken;
      if tok_type = TOK_LPAREN then
      begin
        NextToken;
        Expect(TOK_RPAREN)
      end;
      EmitBL(rt_readchar);
      expr_type := TYPE_INTEGER
    end
    { keypressed = 107,101,121,112,114,101,115,115,101,100 (10 chars) }
    else if (tok_len = 10) and (ToLower(tok_str[0]) = 107) and (ToLower(tok_str[1]) = 101) and
            (ToLower(tok_str[2]) = 121) and (ToLower(tok_str[3]) = 112) and (ToLower(tok_str[4]) = 114) and
            (ToLower(tok_str[5]) = 101) and (ToLower(tok_str[6]) = 115) and (ToLower(tok_str[7]) = 115) and
            (ToLower(tok_str[8]) = 101) and (ToLower(tok_str[9]) = 100) then
    begin
      NextToken;
      if tok_type = TOK_LPAREN then
      begin
        NextToken;
        Expect(TOK_RPAREN)
      end;
      EmitBL(rt_keypressed);
      expr_type := TYPE_BOOLEAN
    end
    { ord = 111,114,100 }
    else if TokIs8(111, 114, 100, 0, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { ord() is identity for integers/chars }
      expr_type := TYPE_INTEGER
    end
    { chr = 99,104,114 }
    else if TokIs8(99, 104, 114, 0, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { chr() is identity for integers/chars }
      expr_type := TYPE_INTEGER
    end
    { abs = 97,98,115 }
    else if TokIs8(97, 98, 115, 0, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { If x < 0, negate it }
      { cmp x0, #0; b.ge skip; neg x0, x0; skip: }
      EmitIndent;
      writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(48);  { #0 }
      EmitNL;
      EmitIndent;
      writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
      writechar(76); write(label_count);
      EmitNL;
      EmitIndent;
      writechar(110); writechar(101); writechar(103); writechar(32);  { neg }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_INTEGER
    end
    { odd = 111,100,100 }
    else if TokIs8(111, 100, 100, 0, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x AND 1 }
      EmitIndent;
      writechar(97); writechar(110); writechar(100); writechar(32);  { and }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(49);  { #1 }
      EmitNL;
      expr_type := TYPE_BOOLEAN
    end
    { sqr = 115,113,114 }
    else if TokIs8(115, 113, 114, 0, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x * x }
      EmitIndent;
      writechar(109); writechar(117); writechar(108); writechar(32);  { mul }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      expr_type := TYPE_INTEGER
    end
    { succ = 115,117,99,99 }
    else if TokIs8(115, 117, 99, 99, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x + 1 }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(49);  { #1 }
      EmitNL;
      expr_type := TYPE_INTEGER
    end
    { pred = 112,114,101,100 }
    else if TokIs8(112, 114, 101, 100, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x - 1 }
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(49);  { #1 }
      EmitNL;
      expr_type := TYPE_INTEGER
    end
    { upcase = 117,112,99,97,115,101 }
    else if (tok_len = 6) and (tok_str[0] = 117) and (tok_str[1] = 112) and
            (tok_str[2] = 99) and (tok_str[3] = 97) and (tok_str[4] = 115) and
            (tok_str[5] = 101) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { If char is 'a'-'z' (97-122), subtract 32 }
      { cmp x0, #97; b.lt skip; cmp x0, #122; b.gt skip; sub x0, x0, #32; skip: }
      EmitIndent;
      writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(57); writechar(55);  { #97 }
      EmitNL;
      EmitIndent;
      writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
      writechar(76); write(label_count);
      EmitNL;
      EmitIndent;
      writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(49); writechar(50); writechar(50);  { #122 }
      EmitNL;
      EmitIndent;
      writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
      writechar(76); write(label_count);
      EmitNL;
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(51); writechar(50);  { #32 }
      EmitNL;
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_CHAR
    end
    { lowercase = 108,111,119,101,114,99,97,115,101 }
    else if (tok_len = 9) and (tok_str[0] = 108) and (tok_str[1] = 111) and
            (tok_str[2] = 119) and (tok_str[3] = 101) and (tok_str[4] = 114) and
            (tok_str[5] = 99) and (tok_str[6] = 97) and (tok_str[7] = 115) and
            (tok_str[8] = 101) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { If char is 'A'-'Z' (65-90), add 32 }
      { cmp x0, #65; b.lt skip; cmp x0, #90; b.gt skip; add x0, x0, #32; skip: }
      EmitIndent;
      writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(54); writechar(53);  { #65 }
      EmitNL;
      EmitIndent;
      writechar(98); writechar(46); writechar(108); writechar(116); writechar(32);  { b.lt }
      writechar(76); write(label_count);
      EmitNL;
      EmitIndent;
      writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(57); writechar(48);  { #90 }
      EmitNL;
      EmitIndent;
      writechar(98); writechar(46); writechar(103); writechar(116); writechar(32);  { b.gt }
      writechar(76); write(label_count);
      EmitNL;
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(51); writechar(50);  { #32 }
      EmitNL;
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_CHAR
    end
    { length = 108,101,110,103,116,104 }
    else if (tok_len = 6) and (tok_str[0] = 108) and (tok_str[1] = 101) and
            (tok_str[2] = 110) and (tok_str[3] = 103) and (tok_str[4] = 116) and
            (tok_str[5] = 104) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type = TOK_STRING then
      begin
        { String literal - emit constant length }
        EmitMovX0(tok_len);
        NextToken
      end
      else if tok_type = TOK_IDENT then
      begin
        { Must be a string variable }
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        { Load string address }
        EmitVarAddr(idx, scope_level);
        { Load length byte from [x0] }
        EmitIndent;
        writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
        writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
        writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
        EmitNL
      end
      else
        Error(9);
      Expect(TOK_RPAREN);
      expr_type := TYPE_INTEGER
    end
    { copy = 99,111,112,121 }
    else if (tok_len = 4) and (tok_str[0] = 99) and (tok_str[1] = 111) and
            (tok_str[2] = 112) and (tok_str[3] = 121) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: source string }
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { source addr in x0 }
        EmitPushX0
      end
      else
        Error(9);
      Expect(TOK_COMMA);
      { Second arg: start index }
      ParseExpression;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Third arg: count }
      ParseExpression;  { count in x0 }
      { x0 = count, x1 = start, x2 = source addr }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
      writechar(120); writechar(48);  { x0 - count }
      EmitNL;
      EmitPopX1;  { start }
      EmitPopX0;  { source addr -> x2 }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
      writechar(120); writechar(48);  { x0 - source }
      EmitNL;
      { Allocate temp string from heap: x0 = x21, x21 += 256 }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(50); writechar(49);  { x21 }
      EmitNL;
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
      EmitNL;
      { Save dest addr }
      EmitPushX0;
      { Inline copy logic: copy from source[start] to dest, count bytes }
      { x0 = dest, x1 = start, x2 = source, x3 = count }
      { Store count as length at dest[0] }
      EmitIndent;
      writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
      writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
      writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
      EmitNL;
      { Loop: copy count bytes from source[start+i] to dest[1+i] }
      lbl1 := NewLabel;
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
      writechar(35); writechar(48);  { #0 - index }
      EmitNL;
      EmitLabel(lbl1);
      { cmp x4, x3 }
      EmitIndent;
      writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
      writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
      writechar(120); writechar(51);  { x3 }
      EmitNL;
      { b.ge done }
      EmitIndent;
      writechar(98); writechar(46); writechar(103); writechar(101); writechar(32);  { b.ge }
      writechar(76); write(label_count);
      EmitNL;
      { x5 = start + x4 (source index) }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(120); writechar(52);  { x4 }
      EmitNL;
      { ldrb w6, [x2, x5] }
      EmitIndent;
      writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
      writechar(119); writechar(54); writechar(44); writechar(32);  { w6, }
      writechar(91); writechar(120); writechar(50); writechar(44); writechar(32);  { [x2, }
      writechar(120); writechar(53); writechar(93);  { x5] }
      EmitNL;
      { x5 = x4 + 1 (dest index) }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(53); writechar(44); writechar(32);  { x5, }
      writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
      writechar(35); writechar(49);  { #1 }
      EmitNL;
      { strb w6, [x0, x5] }
      EmitIndent;
      writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
      writechar(119); writechar(54); writechar(44); writechar(32);  { w6, }
      writechar(91); writechar(120); writechar(48); writechar(44); writechar(32);  { [x0, }
      writechar(120); writechar(53); writechar(93);  { x5] }
      EmitNL;
      { x4 = x4 + 1 }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
      writechar(120); writechar(52); writechar(44); writechar(32);  { x4, }
      writechar(35); writechar(49);  { #1 }
      EmitNL;
      EmitBranchLabel(lbl1);
      EmitLabel(label_count);
      label_count := label_count + 1;
      { Restore dest addr to x0 }
      EmitPopX0;
      Expect(TOK_RPAREN);
      expr_type := TYPE_STRING
    end
    { concat = 99,111,110,99,97,116 }
    else if (tok_len = 6) and (tok_str[0] = 99) and (tok_str[1] = 111) and
            (tok_str[2] = 110) and (tok_str[3] = 99) and (tok_str[4] = 97) and
            (tok_str[5] = 116) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      { First string }
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { string1 addr in x0 }
        EmitPushX0
      end
      else
        Error(9);
      Expect(TOK_COMMA);
      { Second string }
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { string2 addr in x0 }
        { x0 = string2, stack top = string1 }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
        writechar(120); writechar(48);  { x0 }
        EmitNL;
        EmitPopX1;  { string1 }
      end
      else
        Error(9);
      { Allocate temp string from heap: x0 = x21, x21 += 256 }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(50); writechar(49);  { x21 }
      EmitNL;
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
      EmitNL;
      { Call rt_str_concat(x0=dest, x1=str1, x2=str2) }
      EmitBL(rt_str_concat);
      Expect(TOK_RPAREN);
      expr_type := TYPE_STRING
    end
    { trim = 116,114,105,109 }
    else if (tok_len = 4) and (tok_str[0] = 116) and (tok_str[1] = 114) and
            (tok_str[2] = 105) and (tok_str[3] = 109) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      end
      else
        Error(9);
      Expect(TOK_RPAREN);
      EmitBL(rt_str_trim);
      expr_type := TYPE_STRING
    end
    { ltrim = 108,116,114,105,109 }
    else if (tok_len = 5) and (tok_str[0] = 108) and (tok_str[1] = 116) and
            (tok_str[2] = 114) and (tok_str[3] = 105) and (tok_str[4] = 109) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      end
      else
        Error(9);
      Expect(TOK_RPAREN);
      EmitBL(rt_str_ltrim);
      expr_type := TYPE_STRING
    end
    { rtrim = 114,116,114,105,109 }
    else if (tok_len = 5) and (tok_str[0] = 114) and (tok_str[1] = 116) and
            (tok_str[2] = 114) and (tok_str[3] = 105) and (tok_str[4] = 109) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      end
      else
        Error(9);
      Expect(TOK_RPAREN);
      EmitBL(rt_str_rtrim);
      expr_type := TYPE_STRING
    end
    { pos = 112,111,115 }
    else if (tok_len = 3) and (tok_str[0] = 112) and (tok_str[1] = 111) and
            (tok_str[2] = 115) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: substring }
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);
        EmitPushX0
      end
      else if tok_type = TOK_STRING then
      begin
        { String literal - allocate temp on heap }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
        writechar(120); writechar(50); writechar(49);  { x21 }
        EmitNL;
        EmitMovX0(tok_len);
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
        writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
        EmitNL;
        for i := 0 to tok_len - 1 do
        begin
          EmitMovX0(tok_str[i]);
          EmitIndent;
          writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
          writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
          writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
          writechar(35);
          write(i + 1);
          writechar(93);  { ] }
          EmitNL
        end;
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(120); writechar(50); writechar(49);  { x21 }
        EmitNL;
        EmitIndent;
        writechar(97); writechar(100); writechar(100); writechar(32);  { add }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
        EmitNL;
        EmitPushX0;
        NextToken
      end
      else
        Error(9);
      Expect(TOK_COMMA);
      { Second arg: string to search in }
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { string addr in x0 }
        { mov x1, x0; pop x0 }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
        writechar(120); writechar(48);  { x0 }
        EmitNL;
        EmitPopX0  { substr in x0 }
      end
      else
        Error(9);
      { Call rt_str_pos(x0=substr, x1=string) }
      EmitBL(rt_str_pos);
      Expect(TOK_RPAREN);
      expr_type := TYPE_INTEGER
    end
    else
    begin
      { Check for WITH context - try to find identifier as a field }
      if with_rec_idx >= 0 then
      begin
        arg_count := FindField(with_rec_type);  { reuse arg_count for field_idx }
        if arg_count >= 0 then
        begin
          { Found field - generate access code }
          NextToken;
          { Compute address: base + field_offset }
          if sym_level[with_rec_idx] < scope_level then
          begin
            EmitFollowChain(sym_level[with_rec_idx], scope_level);
            { add x0, x8, #sym_offset + field_offset }
            EmitIndent;
            writechar(97); writechar(100); writechar(100); writechar(32);  { add }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
            writechar(35);
            write(sym_offset[with_rec_idx] + field_offset[arg_count]);
            EmitNL
          end
          else
          begin
            { add x0, x29, #sym_offset + field_offset }
            EmitIndent;
            writechar(97); writechar(100); writechar(100); writechar(32);  { add }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
            writechar(35);
            write(sym_offset[with_rec_idx] + field_offset[arg_count]);
            EmitNL
          end;
          { Load from computed address }
          if field_type[arg_count] = TYPE_REAL then
          begin
            EmitIndent;
            writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
            writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL;
            expr_type := TYPE_REAL
          end
          else
          begin
            EmitIndent;
            writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL;
            expr_type := field_type[arg_count]
          end
        end
        else
        begin
          { Field not found, proceed with normal lookup }
          idx := SymLookup;
          if idx < 0 then
            Error(3);  { undefined identifier }
          { Continue with the normal identifier handling below }
        end
      end
      else
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);  { undefined identifier }
      end;
      { Skip if we already handled WITH field }
      if (with_rec_idx < 0) or (arg_count < 0) then
      begin
      NextToken;
      if sym_kind[idx] = SYM_CONST then
      begin
        EmitMovX0(sym_const_val[idx]);
        expr_type := TYPE_INTEGER
      end
      else if (sym_kind[idx] = SYM_VAR) or (sym_kind[idx] = SYM_PARAM) then
      begin
        if (sym_type[idx] = TYPE_ARRAY) and (tok_type = TOK_LBRACKET) then
        begin
          { Array element access: arr[index] or arr[index].field }
          NextToken;  { consume '[' }
          ParseExpression;  { index in x0 }
          Expect(TOK_RBRACKET);
          { Subtract low bound }
          EmitPushX0;
          EmitMovX0(sym_const_val[idx]);  { low bound }
          EmitPopX1;
          { x0 = x1 - x0 = index - low_bound }
          EmitIndent;
          writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
          writechar(120); writechar(48);  { x0 }
          EmitNL;
          { Check if array of records }
          if sym_var_param_flags[idx] > 0 then
          begin
            { Array of records - multiply by record size }
            lbl1 := sym_label[sym_var_param_flags[idx] - 1];  { record size }
            EmitPushX0;
            EmitMovX0(lbl1);
            EmitPopX1;
            { mul x0, x1, x0 }
            EmitIndent;
            writechar(109); writechar(117); writechar(108); writechar(32);  { mul }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
            writechar(120); writechar(48);  { x0 }
            EmitNL
          end
          else
          begin
            { Basic type - multiply by 8 using lsl #3 }
            EmitIndent;
            writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(35); writechar(51);  { #3 }
            EmitNL
          end;
          { Get base address: frame + offset (offset is negative) }
          if sym_level[idx] < scope_level then
          begin
            EmitFollowChain(sym_level[idx], scope_level);
            EmitSubLargeOffset(1, 8, 0 - sym_offset[idx])
          end
          else
            EmitSubLargeOffset(1, 29, 0 - sym_offset[idx]);
          { Compute element address: x1 - x0 }
          EmitIndent;
          writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
          writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
          writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
          writechar(120); writechar(48);  { x0 }
          EmitNL;
          { Check for field access on array of records }
          if (sym_var_param_flags[idx] > 0) and (tok_type = TOK_DOT) then
          begin
            NextToken;  { consume '.' }
            arg_count := FindField(sym_var_param_flags[idx] - 1);
            if arg_count < 0 then
              Error(11);
            NextToken;  { consume field name }
            { Add field offset: x1 = x1 + offset }
            if field_offset[arg_count] > 0 then
            begin
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
              writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
              writechar(35);
              write(field_offset[arg_count]);
              EmitNL
            end;
            { Load field value }
            if field_type[arg_count] = TYPE_REAL then
            begin
              EmitIndent;
              writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
              writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL;
              expr_type := TYPE_REAL
            end
            else
            begin
              EmitIndent;
              writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL;
              expr_type := field_type[arg_count]
            end
          end
          else
          begin
            { Load element value }
            EmitIndent;
            writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
            EmitNL
          end
        end
        else if (sym_type[idx] = TYPE_RECORD) and (tok_type = TOK_DOT) then
        begin
          { Record field access: rec.field }
          NextToken;  { consume '.' }
          if tok_type <> TOK_IDENT then
            Error(11);
          { Find the field in the record type }
          arg_count := FindField(sym_const_val[idx]);  { reuse arg_count for field_idx }
          if arg_count < 0 then
            Error(15);  { undefined field }
          { Compute address: base + field_offset }
          { Base is at [x29 + sym_offset] for local, field at positive offset from there }
          if sym_level[idx] < scope_level then
          begin
            EmitFollowChain(sym_level[idx], scope_level);
            { add x0, x8, #sym_offset + field_offset }
            EmitIndent;
            writechar(97); writechar(100); writechar(100); writechar(32);  { add }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
            writechar(35);
            write(sym_offset[idx] + field_offset[arg_count]);
            EmitNL
          end
          else
          begin
            { add x0, x29, #sym_offset + field_offset }
            EmitIndent;
            writechar(97); writechar(100); writechar(100); writechar(32);  { add }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
            writechar(35);
            write(sym_offset[idx] + field_offset[arg_count]);
            EmitNL
          end;
          { Load from computed address }
          if field_type[arg_count] = TYPE_REAL then
          begin
            EmitIndent;
            writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
            writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL;
            expr_type := TYPE_REAL
          end
          else
          begin
            EmitIndent;
            writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL;
            expr_type := field_type[arg_count]
          end;
          NextToken
        end
        else
        begin
          { Load variable value - check for var param and type }
          if sym_type[idx] = TYPE_REAL then
          begin
            if sym_level[idx] < scope_level then
              EmitLdurD0Outer(sym_offset[idx], sym_level[idx], scope_level)
            else
              EmitLdurD0(sym_offset[idx]);
            { If var param, d0 contains address - dereference it }
            if sym_is_var_param[idx] = 1 then
            begin
              { fmov x0, d0; ldr d0, [x0] }
              EmitFmovX0D0;
              EmitIndent;
              writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
              writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
              writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
              EmitNL
            end;
            expr_type := TYPE_REAL
          end
          else if sym_type[idx] = TYPE_STRING then
          begin
            { For strings, emit the address (strings are pass-by-reference) }
            EmitVarAddr(idx, scope_level);
            expr_type := TYPE_STRING;
            { Check for string indexing s[i] }
            if tok_type = TOK_LBRACKET then
            begin
              NextToken;  { consume '[' }
              EmitPushX0;  { save string base address }
              ParseExpression;  { index in x0 }
              Expect(TOK_RBRACKET);
              { x0 = index, stack has base address }
              EmitPopX1;  { x1 = base address }
              { Add index to base: x0 = x1 + x0 }
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
              writechar(120); writechar(48);  { x0 }
              EmitNL;
              { Load byte at [x0]: ldrb w0, [x0] }
              EmitIndent;
              writechar(108); writechar(100); writechar(114); writechar(98); writechar(32);  { ldrb }
              writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
              writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
              EmitNL;
              expr_type := TYPE_CHAR
            end
          end
          else
          begin
            if sym_level[idx] < scope_level then
              EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            else
              EmitLdurX0(sym_offset[idx]);
            { If var param, x0 now contains address - dereference it }
            if sym_is_var_param[idx] = 1 then
            begin
              EmitIndent;
              writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
              EmitNL
            end;
            expr_type := sym_type[idx]
          end
        end;
        { Track pointer base type if this is a pointer }
        if sym_type[idx] = TYPE_POINTER then
          ptr_base_type := sym_const_val[idx];
        { Check for pointer dereference }
        if (sym_type[idx] = TYPE_POINTER) and (tok_type = TOK_CARET) then
        begin
          NextToken;
          if sym_const_val[idx] = TYPE_RECORD then
          begin
            { Pointer to record - x0 has the address, check for field access }
            if tok_type = TOK_DOT then
            begin
              NextToken;  { consume '.' }
              { Find field in the record type }
              arg_count := FindField(sym_label[idx]);  { sym_label has record type index }
              if arg_count < 0 then
                Error(11);  { unknown field }
              NextToken;  { consume field name }
              { Add field offset to pointer: add x0, x0, #offset }
              if field_offset[arg_count] > 0 then
              begin
                EmitIndent;
                writechar(97); writechar(100); writechar(100); writechar(32);  { add }
                writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                writechar(35);
                write(field_offset[arg_count]);
                EmitNL
              end;
              { Load field value }
              if field_type[arg_count] = TYPE_REAL then
              begin
                EmitIndent;
                writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
                writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
                writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
                EmitNL;
                expr_type := TYPE_REAL
              end
              else
              begin
                EmitIndent;
                writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
                writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
                EmitNL;
                expr_type := field_type[arg_count]
              end
            end
            else
            begin
              { Just p^ without field access - not meaningful for records }
              expr_type := TYPE_RECORD
            end
          end
          else if sym_const_val[idx] = TYPE_REAL then
          begin
            { ldr d0, [x0] }
            EmitIndent;
            writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
            writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL;
            expr_type := TYPE_REAL
          end
          else
          begin
            { ldr x0, [x0] }
            EmitIndent;
            writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL;
            expr_type := sym_const_val[idx]
          end
        end
      end
      else if sym_kind[idx] = SYM_FUNCTION then
      begin
        { Function call - pass args in x0-x7 }
        arg_count := 0;
        var_flags := sym_var_param_flags[idx];
        if tok_type = TOK_LPAREN then
        begin
          NextToken;
          if tok_type <> TOK_RPAREN then
          begin
            { Evaluate all args and push to stack }
            repeat
              if tok_type = TOK_COMMA then NextToken;
              { Check if this is a var parameter }
              if IsVarParam(var_flags, arg_count) = 1 then
              begin
                { Var param - pass address of variable }
                if tok_type <> TOK_IDENT then
                  Error(6);  { var param requires variable }
                var_arg_idx := SymLookup;
                if var_arg_idx < 0 then
                  Error(3);
                NextToken;
                { Check for array element - pass address of element }
                if (sym_type[var_arg_idx] = TYPE_ARRAY) and (tok_type = TOK_LBRACKET) then
                begin
                  NextToken;  { consume '[' }
                  ParseExpression;  { index in x0 }
                  Expect(TOK_RBRACKET);
                  { Compute element address }
                  EmitPushX0;
                  EmitMovX0(sym_const_val[var_arg_idx]);  { low bound }
                  EmitPopX1;
                  { x0 = x1 - x0 = index - low_bound }
                  EmitIndent;
                  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
                  writechar(120); writechar(48);  { x0 }
                  EmitNL;
                  { Multiply by 8 using lsl #3 }
                  EmitIndent;
                  writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(35); writechar(51);  { #3 }
                  EmitNL;
                  { Get base address and subtract element offset }
                  if sym_level[var_arg_idx] < scope_level then
                  begin
                    EmitFollowChain(sym_level[var_arg_idx], scope_level);
                    EmitSubLargeOffset(1, 8, 0 - sym_offset[var_arg_idx])
                  end
                  else
                    EmitSubLargeOffset(1, 29, 0 - sym_offset[var_arg_idx]);
                  { Address = base - element_offset }
                  EmitIndent;
                  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
                  writechar(120); writechar(48);  { x0 }
                  EmitNL
                end
                else
                  { Simple variable - emit address }
                  EmitVarAddr(var_arg_idx, scope_level)
              end
              else
              begin
                { Value param - evaluate expression }
                ParseExpression
              end;
              EmitPushX0;
              arg_count := arg_count + 1
            until tok_type <> TOK_COMMA
          end;
          Expect(TOK_RPAREN)
        end;
        { Pop args from stack into registers in reverse order }
        for i := arg_count - 1 downto 0 do
        begin
          EmitIndent;
          writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
          writechar(120); writechar(48 + i); writechar(44); writechar(32);  { xi, }
          writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
          writechar(44); writechar(32); writechar(35); writechar(49); writechar(54);  { , #16 }
          EmitNL
        end;
        { Set up static link for callee }
        EmitStaticLink(sym_level[idx], scope_level);
        EmitBL(sym_label[idx]);
        expr_type := sym_type[idx]  { function return type }
      end
      else
        Error(4)
      end  { end of if (with_rec_idx < 0) or (arg_count < 0) }
    end  { end of else for non-builtin ident }
  end  { end of else if tok_type = TOK_IDENT }
  else
    Error(5)
end;

procedure ParseUnary;
begin
  if tok_type = TOK_MINUS then
  begin
    NextToken;
    ParseFactor;
    if expr_type = TYPE_REAL then
      EmitFNeg
    else
      EmitNeg
  end
  else if tok_type = TOK_PLUS then
  begin
    NextToken;
    ParseFactor
  end
  else
    ParseFactor
end;

procedure ParseTerm;
var
  op, left_type: integer;
begin
  ParseUnary;
  while (tok_type = TOK_STAR) or (tok_type = TOK_DIV) or (tok_type = TOK_MOD) or
        (tok_type = TOK_AND) or (tok_type = TOK_SLASH) do
  begin
    op := tok_type;
    left_type := expr_type;
    NextToken;
    { Push left operand appropriately }
    if left_type = TYPE_REAL then
      EmitPushD0
    else
      EmitPushX0;
    ParseUnary;
    { right operand is now in x0 or d0 depending on expr_type }

    if op = TOK_SLASH then
    begin
      { / always produces real - convert both operands to float }
      if expr_type <> TYPE_REAL then
        EmitScvtfD0X0;  { convert right to float }
      if left_type = TYPE_REAL then
        EmitPopD1
      else
      begin
        EmitPopX1;
        EmitScvtfD1X1  { convert left to float }
      end;
      EmitFDiv;
      expr_type := TYPE_REAL
    end
    else if (left_type = TYPE_REAL) or (expr_type = TYPE_REAL) then
    begin
      { Mixed or both real - use float ops }
      if expr_type <> TYPE_REAL then
        EmitScvtfD0X0;  { convert right to float }
      if left_type = TYPE_REAL then
        EmitPopD1
      else
      begin
        EmitPopX1;
        EmitScvtfD1X1  { convert left to float }
      end;
      if op = TOK_STAR then
        EmitFMul
      else if op = TOK_DIV then
      begin
        { div on floats - truncate result to integer }
        EmitFDiv;
        EmitFcvtzsX0D0;
        expr_type := TYPE_INTEGER
      end
      else if op = TOK_MOD then
        Error(13)  { mod not supported for reals }
      else { TOK_AND }
        Error(13);  { and not supported for reals }
      if (op = TOK_STAR) then
        expr_type := TYPE_REAL
    end
    else
    begin
      { Both integers - use integer ops }
      EmitPopX1;
      if op = TOK_STAR then
        EmitMul
      else if op = TOK_DIV then
        EmitSDiv
      else if op = TOK_MOD then
      begin
        { x1 mod x0: x1 - (x1 / x0) * x0 }
        EmitPushX0;
        EmitPushX1;
        EmitSDiv;
        EmitMovX2X0;
        EmitPopX1;
        EmitPopX0;
        EmitMsub
      end
      else { TOK_AND }
        EmitAndX0X1;
      expr_type := TYPE_INTEGER
    end
  end
end;

procedure ParseSimpleExpr;
var
  op, left_type, left_ptr_base: integer;
begin
  ParseTerm;
  while (tok_type = TOK_PLUS) or (tok_type = TOK_MINUS) or (tok_type = TOK_OR) do
  begin
    op := tok_type;
    left_type := expr_type;
    left_ptr_base := ptr_base_type;
    NextToken;
    { Push left operand appropriately }
    if left_type = TYPE_REAL then
      EmitPushD0
    else
      EmitPushX0;
    ParseTerm;

    if (left_type = TYPE_POINTER) and (op = TOK_PLUS) then
    begin
      { pointer + integer: scale integer by 8 and SUBTRACT (arrays grow downward) }
      EmitPopX1;  { pointer in x1 }
      { x0 has integer offset, multiply by 8 using lsl #3 }
      EmitIndent;
      writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(51);  { #3 }
      EmitNL;
      EmitSub;  { x0 = x1 - x0 (subtract because arrays grow downward) }
      expr_type := TYPE_POINTER;
      ptr_base_type := left_ptr_base
    end
    else if (left_type = TYPE_POINTER) and (op = TOK_MINUS) then
    begin
      if expr_type = TYPE_POINTER then
      begin
        { pointer - pointer: returns integer count (negated for downward growth) }
        EmitPopX1;  { left pointer in x1 }
        EmitSub;  { x0 = x1 - x0 }
        { Negate and divide by 8 for correct count }
        EmitNeg;  { x0 = -(x1 - x0) = x0 - x1 }
        { Divide by 8 (element size) using asr #3 }
        EmitIndent;
        writechar(97); writechar(115); writechar(114); writechar(32);  { asr }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(35); writechar(51);  { #3 }
        EmitNL;
        expr_type := TYPE_INTEGER
      end
      else
      begin
        { pointer - integer: scale integer by 8 and ADD (arrays grow downward) }
        EmitPopX1;  { pointer in x1 }
        { x0 has integer offset, multiply by 8 using lsl #3 }
        EmitIndent;
        writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(35); writechar(51);  { #3 }
        EmitNL;
        EmitAdd;  { x0 = x1 + x0 (add because arrays grow downward) }
        expr_type := TYPE_POINTER;
        ptr_base_type := left_ptr_base
      end
    end
    else if (left_type = TYPE_STRING) and (expr_type = TYPE_STRING) and (op = TOK_PLUS) then
    begin
      { String concatenation: str1 + str2 }
      { x0 = string2 addr, stack top = string1 addr }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
      writechar(120); writechar(48);  { x0 - string2 }
      EmitNL;
      EmitPopX1;  { string1 addr }
      { Allocate temp string from heap }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(50); writechar(49);  { x21 - heap ptr }
      EmitNL;
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
      EmitNL;
      { Call rt_str_concat(x0=dest, x1=str1, x2=str2) }
      EmitBL(rt_str_concat);
      expr_type := TYPE_STRING
    end
    else if (((left_type = TYPE_STRING) and (expr_type = TYPE_CHAR)) or
             ((left_type = TYPE_CHAR) and (expr_type = TYPE_STRING))) and (op = TOK_PLUS) then
    begin
      { String + char or char + string concatenation }
      { Need to convert char to a single-character string, then concatenate }
      if left_type = TYPE_STRING then
      begin
        { string + char: x0 = char, stack top = string addr }
        { Create single-char string from x0 on heap }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
        writechar(120); writechar(48);  { x0 - save char }
        EmitNL;
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
        writechar(120); writechar(50); writechar(49);  { x21 - heap ptr for char string }
        EmitNL;
        EmitMovX0(1);  { length = 1 }
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
        writechar(91); writechar(120); writechar(50); writechar(93);  { [x2] }
        EmitNL;
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
        writechar(91); writechar(120); writechar(50); writechar(44); writechar(32);  { [x2, }
        writechar(35); writechar(49); writechar(93);  { #1] }
        EmitNL;
        EmitIndent;
        writechar(97); writechar(100); writechar(100); writechar(32);  { add }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
        EmitNL;
        EmitPopX1;  { string1 addr }
        { x2 = char string, x1 = string1, allocate result on heap }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(120); writechar(50); writechar(49);  { x21 - heap ptr for result }
        EmitNL;
        EmitIndent;
        writechar(97); writechar(100); writechar(100); writechar(32);  { add }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
        EmitNL;
        EmitBL(rt_str_concat)
      end
      else
      begin
        { char + string: x0 = string addr, stack top = char }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
        writechar(120); writechar(48);  { x0 - save string2 addr }
        EmitNL;
        EmitPopX0;  { x0 = char }
        { Create single-char string from x0 on heap }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
        writechar(120); writechar(50); writechar(49);  { x21 - heap ptr for char string }
        EmitNL;
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(51); writechar(44); writechar(32);  { x3, }
        writechar(120); writechar(48);  { x0 - save char }
        EmitNL;
        EmitMovX0(1);  { length = 1 }
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
        writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
        EmitNL;
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(51); writechar(44); writechar(32);  { w3, }
        writechar(91); writechar(120); writechar(49); writechar(44); writechar(32);  { [x1, }
        writechar(35); writechar(49); writechar(93);  { #1] }
        EmitNL;
        EmitIndent;
        writechar(97); writechar(100); writechar(100); writechar(32);  { add }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
        EmitNL;
        { x1 = char string, x2 = string2, allocate result on heap }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(120); writechar(50); writechar(49);  { x21 - heap ptr for result }
        EmitNL;
        EmitIndent;
        writechar(97); writechar(100); writechar(100); writechar(32);  { add }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
        EmitNL;
        EmitBL(rt_str_concat)
      end;
      expr_type := TYPE_STRING
    end
    else if (left_type = TYPE_REAL) or (expr_type = TYPE_REAL) then
    begin
      { Mixed or both real - use float ops }
      if expr_type <> TYPE_REAL then
        EmitScvtfD0X0;  { convert right to float }
      if left_type = TYPE_REAL then
        EmitPopD1
      else
      begin
        EmitPopX1;
        EmitScvtfD1X1  { convert left to float }
      end;
      if op = TOK_PLUS then
        EmitFAdd
      else if op = TOK_MINUS then
        EmitFSub
      else { TOK_OR }
        Error(13);  { or not supported for reals }
      expr_type := TYPE_REAL
    end
    else
    begin
      { Both integers }
      EmitPopX1;
      if op = TOK_PLUS then
        EmitAdd
      else if op = TOK_MINUS then
        EmitSub
      else { TOK_OR }
        EmitOrrX0X1;
      expr_type := TYPE_INTEGER
    end
  end
end;

procedure ParseExpression;
var
  op, cond, left_type: integer;
begin
  ParseSimpleExpr;
  if (tok_type = TOK_EQ) or (tok_type = TOK_NEQ) or (tok_type = TOK_LT) or
     (tok_type = TOK_LE) or (tok_type = TOK_GT) or (tok_type = TOK_GE) then
  begin
    op := tok_type;
    left_type := expr_type;
    NextToken;
    { Push left operand appropriately }
    if left_type = TYPE_REAL then
      EmitPushD0
    else
      EmitPushX0;
    ParseSimpleExpr;

    if (left_type = TYPE_STRING) and (expr_type = TYPE_STRING) then
    begin
      { String comparison }
      { x0 = string2 addr, stack top = string1 addr }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      EmitPopX0;  { string1 addr in x0 }
      if (op = TOK_EQ) or (op = TOK_NEQ) then
      begin
        { Call rt_str_compare(x0=str1, x1=str2) - returns 1 if equal, 0 if not }
        EmitBL(rt_str_compare);
        if op = TOK_NEQ then
          EmitEorX0(1)
      end
      else
      begin
        { Relational operators: call rt_str_cmp which returns -1/0/1 }
        EmitBL(rt_str_cmp);
        { x0 = -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 }
        if op = TOK_LT then
        begin
          { cmp x0, #0; cset x0, lt }
          EmitIndent;
          writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(35); writechar(48);  { #0 }
          EmitNL;
          EmitIndent;
          writechar(99); writechar(115); writechar(101); writechar(116); writechar(32);  { cset }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(108); writechar(116);  { lt }
          EmitNL
        end
        else if op = TOK_GT then
        begin
          { cmp x0, #0; cset x0, gt }
          EmitIndent;
          writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(35); writechar(48);  { #0 }
          EmitNL;
          EmitIndent;
          writechar(99); writechar(115); writechar(101); writechar(116); writechar(32);  { cset }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(103); writechar(116);  { gt }
          EmitNL
        end
        else if op = TOK_LE then
        begin
          { cmp x0, #0; cset x0, le }
          EmitIndent;
          writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(35); writechar(48);  { #0 }
          EmitNL;
          EmitIndent;
          writechar(99); writechar(115); writechar(101); writechar(116); writechar(32);  { cset }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(108); writechar(101);  { le }
          EmitNL
        end
        else if op = TOK_GE then
        begin
          { cmp x0, #0; cset x0, ge }
          EmitIndent;
          writechar(99); writechar(109); writechar(112); writechar(32);  { cmp }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(35); writechar(48);  { #0 }
          EmitNL;
          EmitIndent;
          writechar(99); writechar(115); writechar(101); writechar(116); writechar(32);  { cset }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(103); writechar(101);  { ge }
          EmitNL
        end
      end;
      expr_type := TYPE_INTEGER
    end
    else if (left_type = TYPE_REAL) or (expr_type = TYPE_REAL) then
    begin
      { Float comparison }
      if expr_type <> TYPE_REAL then
        EmitScvtfD0X0;  { convert right to float }
      if left_type = TYPE_REAL then
        EmitPopD1
      else
      begin
        EmitPopX1;
        EmitScvtfD1X1  { convert left to float }
      end;
      EmitFCmp;
      if op = TOK_EQ then cond := 0
      else if op = TOK_NEQ then cond := 1
      else if op = TOK_LT then cond := 2
      else if op = TOK_LE then cond := 3
      else if op = TOK_GT then cond := 4
      else cond := 5;
      EmitCset(cond);
      expr_type := TYPE_INTEGER
    end
    else
    begin
      { Integer comparison }
      EmitPopX1;
      EmitCmpX0X1;
      if op = TOK_EQ then cond := 0
      else if op = TOK_NEQ then cond := 1
      else if op = TOK_LT then cond := 2
      else if op = TOK_LE then cond := 3
      else if op = TOK_GT then cond := 4
      else cond := 5;
      EmitCset(cond);
      expr_type := TYPE_INTEGER
    end
  end
end;

procedure ParseStatement;
var
  idx, lbl1, lbl2, lbl3, arg_count, i: integer;
  var_flags, arg_idx, var_arg_idx: integer;
begin
  if tok_type = TOK_BEGIN then
  begin
    NextToken;
    ParseStatement;
    while tok_type = TOK_SEMICOLON do
    begin
      NextToken;
      ParseStatement
    end;
    Expect(TOK_END)
  end
  else if tok_type = TOK_IF then
  begin
    NextToken;
    ParseExpression;
    Expect(TOK_THEN);
    lbl1 := NewLabel;
    lbl2 := NewLabel;
    EmitBranchLabelZ(lbl1);
    ParseStatement;
    if tok_type = TOK_ELSE then
    begin
      EmitBranchLabel(lbl2);
      EmitLabel(lbl1);
      NextToken;
      ParseStatement;
      EmitLabel(lbl2)
    end
    else
      EmitLabel(lbl1)
  end
  else if tok_type = TOK_WHILE then
  begin
    lbl1 := NewLabel;
    lbl2 := NewLabel;
    EmitLabel(lbl1);
    NextToken;
    ParseExpression;
    Expect(TOK_DO);
    EmitBranchLabelZ(lbl2);
    ParseStatement;
    EmitBranchLabel(lbl1);
    EmitLabel(lbl2)
  end
  else if tok_type = TOK_REPEAT then
  begin
    lbl1 := NewLabel;
    EmitLabel(lbl1);
    NextToken;
    ParseStatement;
    while tok_type = TOK_SEMICOLON do
    begin
      NextToken;
      ParseStatement
    end;
    Expect(TOK_UNTIL);
    ParseExpression;
    EmitBranchLabelZ(lbl1)
  end
  else if tok_type = TOK_FOR then
  begin
    NextToken;
    if tok_type <> TOK_IDENT then
      Error(6);
    idx := SymLookup;
    if idx < 0 then
      Error(3);
    NextToken;
    Expect(TOK_ASSIGN);
    ParseExpression;
    EmitSturX0(sym_offset[idx]);

    lbl1 := NewLabel;
    lbl2 := NewLabel;

    if tok_type = TOK_TO then
    begin
      NextToken;
      ParseExpression;  { end value into x0 }
      EmitPushX0;       { save end value on stack }
      Expect(TOK_DO);
      EmitLabel(lbl1);
      EmitLdurX0(sym_offset[idx]);  { load loop var }
      { ldur x1, [sp] - load end value from stack }
      EmitIndent;
      writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
      EmitNL;
      EmitCmpX0X1;
      EmitCset(2);  { lt: exit when end < i, meaning i > end }
      EmitBranchLabelNZ(lbl2);
      ParseStatement;
      { increment }
      EmitLdurX0(sym_offset[idx]);
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add x0, x0, #1 }
      writechar(120); writechar(48); writechar(44); writechar(32);
      writechar(120); writechar(48); writechar(44); writechar(32);
      writechar(35); writechar(49);
      EmitNL;
      EmitSturX0(sym_offset[idx]);
      EmitBranchLabel(lbl1);
      EmitLabel(lbl2);
      { Pop end value from stack }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(35); writechar(49); writechar(54);  { #16 }
      EmitNL
    end
    else
    begin
      Expect(TOK_DOWNTO);
      ParseExpression;  { end value into x0 }
      EmitPushX0;       { save end value on stack }
      Expect(TOK_DO);
      EmitLabel(lbl1);
      EmitLdurX0(sym_offset[idx]);  { load loop var }
      { ldur x1, [sp] - load end value from stack }
      EmitIndent;
      writechar(108); writechar(100); writechar(117); writechar(114); writechar(32);  { ldur }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
      EmitNL;
      EmitCmpX0X1;
      EmitCset(4);  { gt: exit when end > i, meaning i < end }
      EmitBranchLabelNZ(lbl2);
      ParseStatement;
      { decrement }
      EmitLdurX0(sym_offset[idx]);
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub x0, x0, #1 }
      writechar(120); writechar(48); writechar(44); writechar(32);
      writechar(120); writechar(48); writechar(44); writechar(32);
      writechar(35); writechar(49);
      EmitNL;
      EmitSturX0(sym_offset[idx]);
      EmitBranchLabel(lbl1);
      EmitLabel(lbl2);
      { Pop end value from stack }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(35); writechar(49); writechar(54);  { #16 }
      EmitNL
    end
  end
  else if tok_type = TOK_CASE then
  begin
    { CASE selector OF const: stmt; ... [ELSE stmt] END }
    NextToken;
    ParseExpression;  { selector in x0 }
    EmitPushX0;       { save selector on stack }
    Expect(TOK_OF);
    lbl1 := NewLabel;  { end of case label }

    while (tok_type <> TOK_END) and (tok_type <> TOK_ELSE) do
    begin
      { Parse constant(s) for this case branch }
      lbl2 := NewLabel;  { next case branch label }
      lbl3 := NewLabel;  { match found, execute statement }
      repeat
        if tok_type = TOK_COMMA then NextToken;
        { Load selector from stack (peek, don't pop): ldr x1, [sp] }
        EmitIndent;
        writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
        writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
        writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
        EmitNL;
        { Parse constant value }
        if tok_type = TOK_INTEGER then
        begin
          EmitMovX0(tok_int);
          NextToken
        end
        else if tok_type = TOK_MINUS then
        begin
          NextToken;
          if tok_type = TOK_INTEGER then
          begin
            EmitMovX0(0 - tok_int);
            NextToken
          end
          else
            Error(10)
        end
        else
          Error(10);  { expected constant }
        { Compare: cmp x1, x0 }
        EmitCmpX0X1;
        { If equal, jump to match label }
        EmitIndent;
        writechar(98); writechar(46); writechar(101); writechar(113); writechar(32);  { b.eq }
        writechar(76); write(lbl3);
        EmitNL
      until tok_type = TOK_COLON;
      { No match in this group, jump to next branch }
      EmitBranchLabel(lbl2);
      { Match found - execute statement }
      EmitLabel(lbl3);
      NextToken;  { consume ':' }
      { Pop selector from stack (discard) }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(35); writechar(49); writechar(54);  { #16 }
      EmitNL;
      ParseStatement;
      { Jump to end of case }
      EmitBranchLabel(lbl1);
      { Repush selector for next comparisons: sub sp, sp, #16; str x0, [sp] }
      { Actually we need to restore selector - this gets tricky }
      { Simpler approach: jump around the next branch's test }
      EmitLabel(lbl2);
      { After ParseStatement the selector was popped, repush it }
      { For simplicity, we push a placeholder and let the next iteration reload }
      { Actually, we need the selector back - let's use a different approach }
      { The cleanest way: keep selector on stack until we match or hit else/end }
      { Re-push selector: we saved it in x0 before? No. Let's rethink. }
      { Better: save selector to a dedicated spot before the loop }
      { For now: don't pop until match, just peek. Pop only when match or done. }
      { Skip the repush - we've jumped to lbl1 if matched, lbl2 if not }
      { At lbl2, we still have selector on stack }
      if tok_type = TOK_SEMICOLON then NextToken
    end;

    if tok_type = TOK_ELSE then
    begin
      NextToken;
      { Pop selector (discard) before else statement }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(35); writechar(49); writechar(54);  { #16 }
      EmitNL;
      ParseStatement;
      { Note: no need to jump to lbl1, we fall through }
    end
    else
    begin
      { No else - just pop selector }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
      writechar(35); writechar(49); writechar(54);  { #16 }
      EmitNL
    end;
    EmitLabel(lbl1);
    Expect(TOK_END)
  end
  else if tok_type = TOK_READ then
  begin
    { read(var) - reads an integer or real into a variable }
    NextToken;
    Expect(TOK_LPAREN);
    if tok_type <> TOK_IDENT then
      Error(6);
    idx := SymLookup;
    if idx < 0 then
      Error(3);
    NextToken;
    if sym_type[idx] = TYPE_REAL then
    begin
      { Call read_real runtime - result in d0 }
      EmitBL(rt_read_real);
      { Store result in variable }
      if sym_level[idx] = scope_level then
        EmitSturD0(sym_offset[idx])
      else
        EmitSturD0Outer(sym_offset[idx], sym_level[idx], scope_level)
    end
    else
    begin
      { Call read_int runtime }
      EmitBL(rt_read_int);
      { Store result in variable }
      if sym_level[idx] = scope_level then
        EmitSturX0(sym_offset[idx])
      else
        EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
    end;
    Expect(TOK_RPAREN)
  end
  else if tok_type = TOK_READLN then
  begin
    { readln(var) or readln - reads integer/real and skips to end of line }
    NextToken;
    if tok_type = TOK_LPAREN then
    begin
      NextToken;
      if tok_type <> TOK_RPAREN then
      begin
        if tok_type <> TOK_IDENT then
          Error(6);
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        NextToken;
        if sym_type[idx] = TYPE_REAL then
        begin
          { Call read_real runtime - result in d0 }
          EmitBL(rt_read_real);
          { Store result in variable }
          if sym_level[idx] = scope_level then
            EmitSturD0(sym_offset[idx])
          else
            EmitSturD0Outer(sym_offset[idx], sym_level[idx], scope_level)
        end
        else if sym_type[idx] = TYPE_STRING then
        begin
          { Load string variable address into x0 }
          EmitVarAddr(idx, scope_level);
          { Call read_string runtime }
          EmitBL(rt_read_string)
        end
        else
        begin
          { Call read_int runtime }
          EmitBL(rt_read_int);
          { Store result in variable }
          if sym_level[idx] = scope_level then
            EmitSturX0(sym_offset[idx])
          else
            EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
        end
      end;
      Expect(TOK_RPAREN)
    end;
    { Skip to end of line }
    EmitBL(rt_skip_line)
  end
  else if tok_type = TOK_WITH then
  begin
    { WITH record_var DO statement }
    NextToken;
    if tok_type <> TOK_IDENT then
      Error(6);  { expected identifier }
    idx := SymLookup;
    if idx < 0 then
      Error(3);  { undefined identifier }
    if sym_type[idx] <> TYPE_RECORD then
      Error(9);  { expected record type }
    { Save current with context }
    lbl1 := with_rec_idx;  { reuse lbl1 to save old with_rec_idx }
    lbl2 := with_rec_type;  { reuse lbl2 to save old with_rec_type }
    with_rec_idx := idx;
    with_rec_type := sym_const_val[idx];  { the type definition index }
    NextToken;
    Expect(TOK_DO);
    ParseStatement;
    { Restore with context }
    with_rec_idx := lbl1;
    with_rec_type := lbl2
  end
  else if tok_type = TOK_IDENT then
  begin
    { Check for built-in procedures first }
    { write = 119,114,105,116,101 }
    { writeln = 119,114,105,116,101,108,110 }
    { readchar = 114,101,97,100,99,104,97,114 }
    { writechar = 119,114,105,116,101,99,104,97 - actually too long, use 8 }
    { halt = 104,97,108,116 }
    if TokIs8(119, 114, 105, 116, 101, 108, 110, 0) = 1 then
    begin
      { writeln }
      NextToken;
      if tok_type = TOK_LPAREN then
      begin
        NextToken;
        if tok_type <> TOK_RPAREN then
        begin
          repeat
            if tok_type = TOK_STRING then
            begin
              { Print string literal character by character }
              idx := 0;
              while idx < tok_len do
              begin
                EmitMovX0(tok_str[idx]);
                EmitBL(rt_print_char);
                idx := idx + 1
              end;
              NextToken
            end
            else if tok_type = TOK_IDENT then
            begin
              { Check if it's a string variable }
              idx := SymLookup;
              if (idx >= 0) and (sym_type[idx] = TYPE_STRING) then
              begin
                { String variable - compute address and call print_string }
                NextToken;
                EmitVarAddr(idx, scope_level);
                EmitBL(rt_print_string)
              end
              else
              begin
                { Not a string - parse as expression and print based on type }
                ParseExpression;
                if expr_type = TYPE_REAL then
                  EmitBL(rt_print_real)
                else
                  EmitBL(rt_print_int)
              end
            end
            else
            begin
              ParseExpression;
              if expr_type = TYPE_REAL then
                EmitBL(rt_print_real)
              else
                EmitBL(rt_print_int)
            end
          until tok_type <> TOK_COMMA;
          if tok_type = TOK_COMMA then NextToken
        end;
        Expect(TOK_RPAREN)
      end;
      EmitBL(rt_newline)
    end
    else if TokIs8(119, 114, 105, 116, 101, 0, 0, 0) = 1 then
    begin
      { write }
      NextToken;
      if tok_type = TOK_LPAREN then
      begin
        NextToken;
        if tok_type <> TOK_RPAREN then
        begin
          repeat
            if tok_type = TOK_STRING then
            begin
              { Print string literal character by character }
              idx := 0;
              while idx < tok_len do
              begin
                EmitMovX0(tok_str[idx]);
                EmitBL(rt_print_char);
                idx := idx + 1
              end;
              NextToken
            end
            else if tok_type = TOK_IDENT then
            begin
              { Check if it's a string variable }
              idx := SymLookup;
              if (idx >= 0) and (sym_type[idx] = TYPE_STRING) then
              begin
                { String variable - compute address and call print_string }
                NextToken;
                EmitVarAddr(idx, scope_level);
                EmitBL(rt_print_string)
              end
              else
              begin
                { Not a string - parse as expression and print based on type }
                ParseExpression;
                if expr_type = TYPE_REAL then
                  EmitBL(rt_print_real)
                else
                  EmitBL(rt_print_int)
              end
            end
            else
            begin
              ParseExpression;
              if expr_type = TYPE_REAL then
                EmitBL(rt_print_real)
              else
                EmitBL(rt_print_int)
            end
          until tok_type <> TOK_COMMA;
          if tok_type = TOK_COMMA then NextToken
        end;
        Expect(TOK_RPAREN)
      end
    end
    else if TokIs8(104, 97, 108, 116, 0, 0, 0, 0) = 1 then
    begin
      { halt }
      NextToken;
      if tok_type = TOK_LPAREN then
      begin
        NextToken;
        if tok_type <> TOK_RPAREN then
          ParseExpression
        else
          EmitMovX0(0);
        Expect(TOK_RPAREN)
      end
      else
        EmitMovX0(0);
      EmitMovX16(33554433);  { 0x2000001 = exit }
      EmitSvc
    end
    { inc = 105,110,99 }
    else if TokIs8(105, 110, 99, 0, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type <> TOK_IDENT then
        Error(3);
      idx := SymLookup;
      if idx < 0 then
        Error(3);
      NextToken;
      { Load address into x8 }
      EmitVarAddr(idx, scope_level);
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      { Load current value }
      EmitIndent;
      writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
      EmitNL;
      { Add 1 }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(49);  { #1 }
      EmitNL;
      { Store back }
      EmitIndent;
      writechar(115); writechar(116); writechar(114); writechar(32);  { str }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
      EmitNL;
      Expect(TOK_RPAREN)
    end
    { dec = 100,101,99 }
    else if TokIs8(100, 101, 99, 0, 0, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type <> TOK_IDENT then
        Error(3);
      idx := SymLookup;
      if idx < 0 then
        Error(3);
      NextToken;
      { Load address into x8 }
      EmitVarAddr(idx, scope_level);
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      { Load current value }
      EmitIndent;
      writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
      EmitNL;
      { Subtract 1 }
      EmitIndent;
      writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(35); writechar(49);  { #1 }
      EmitNL;
      { Store back }
      EmitIndent;
      writechar(115); writechar(116); writechar(114); writechar(32);  { str }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
      EmitNL;
      Expect(TOK_RPAREN)
    end
    else if (tok_len = 9) and (tok_str[0] = 119) and (tok_str[1] = 114) and
            (tok_str[2] = 105) and (tok_str[3] = 116) and (tok_str[4] = 101) and
            (tok_str[5] = 99) and (tok_str[6] = 104) and (tok_str[7] = 97) and
            (tok_str[8] = 114) then
    begin
      { writechar - 119,114,105,116,101,99,104,97,114 }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      EmitBL(rt_print_char)
    end
    else if (tok_len = 8) and (tok_str[0] = 114) and (tok_str[1] = 101) and
            (tok_str[2] = 97) and (tok_str[3] = 100) and (tok_str[4] = 99) and
            (tok_str[5] = 104) and (tok_str[6] = 97) and (tok_str[7] = 114) then
    begin
      { readchar - 114,101,97,100,99,104,97,114 }
      NextToken;
      EmitBL(rt_readchar)
    end
    else if TokIs8(110, 101, 119, 0, 0, 0, 0, 0) = 1 then
    begin
      { new(p) - allocate memory for pointer variable }
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type <> TOK_IDENT then
        Error(6);  { expected identifier }
      idx := SymLookup;
      if idx < 0 then
        Error(3);  { undefined identifier }
      if sym_type[idx] <> TYPE_POINTER then
        Error(14);  { expected pointer type }
      NextToken;
      Expect(TOK_RPAREN);
      { Determine allocation size based on base type }
      if sym_const_val[idx] = TYPE_RECORD then
        lbl1 := sym_label[sym_label[idx]]  { record size from type definition }
      else
        lbl1 := 8;  { basic types are 8 bytes }
      { Align to 8 bytes }
      lbl1 := ((lbl1 + 7) div 8) * 8;
      { Allocate: get current heap pointer (x21), bump by size }
      { mov x0, x21 }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(120); writechar(50); writechar(49);  { x21 }
      EmitNL;
      { add x21, x21, #size }
      EmitIndent;
      writechar(97); writechar(100); writechar(100); writechar(32);  { add }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
      writechar(35);
      write(lbl1);
      EmitNL;
      { Store address in pointer variable }
      if sym_level[idx] < scope_level then
        EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
      else
        EmitSturX0(sym_offset[idx])
    end
    else if (tok_len = 7) and (tok_str[0] = 100) and (tok_str[1] = 105) and
            (tok_str[2] = 115) and (tok_str[3] = 112) and (tok_str[4] = 111) and
            (tok_str[5] = 115) and (tok_str[6] = 101) then
    begin
      { dispose(p) - free memory (no-op for bump allocator) }
      NextToken;
      Expect(TOK_LPAREN);
      if tok_type <> TOK_IDENT then
        Error(6);  { expected identifier }
      idx := SymLookup;
      if idx < 0 then
        Error(3);  { undefined identifier }
      if sym_type[idx] <> TYPE_POINTER then
        Error(14);  { expected pointer type }
      NextToken;
      Expect(TOK_RPAREN)
      { No-op for bump allocator - could set pointer to nil for safety }
    end
    { delete = 100,101,108,101,116,101 }
    else if (tok_len = 6) and (tok_str[0] = 100) and (tok_str[1] = 101) and
            (tok_str[2] = 108) and (tok_str[3] = 101) and (tok_str[4] = 116) and
            (tok_str[5] = 101) then
    begin
      { delete(s, start, count) - remove chars from string }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: string variable }
      if tok_type <> TOK_IDENT then
        Error(6);
      idx := SymLookup;
      if idx < 0 then
        Error(3);
      if sym_type[idx] <> TYPE_STRING then
        Error(9);
      NextToken;
      EmitVarAddr(idx, scope_level);
      EmitPushX0;
      Expect(TOK_COMMA);
      { Second arg: start position }
      ParseExpression;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Third arg: count }
      ParseExpression;
      { x0=count, stack has string addr and start }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      EmitPopX1;  { start }
      EmitPopX0;  { string addr }
      EmitBL(rt_str_delete);
      Expect(TOK_RPAREN)
    end
    { insert = 105,110,115,101,114,116 }
    else if (tok_len = 6) and (tok_str[0] = 105) and (tok_str[1] = 110) and
            (tok_str[2] = 115) and (tok_str[3] = 101) and (tok_str[4] = 114) and
            (tok_str[5] = 116) then
    begin
      { insert(source, dest, pos) - insert source into dest at pos }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: source string }
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);
        EmitPushX0
      end
      else if tok_type = TOK_STRING then
      begin
        { String literal - allocate temp on heap }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
        writechar(120); writechar(50); writechar(49);  { x21 }
        EmitNL;
        EmitMovX0(tok_len);
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
        writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
        EmitNL;
        for i := 0 to tok_len - 1 do
        begin
          EmitMovX0(tok_str[i]);
          EmitIndent;
          writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
          writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
          writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
          writechar(35);
          write(i + 1);
          writechar(93);  { ] }
          EmitNL
        end;
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(120); writechar(50); writechar(49);  { x21 }
        EmitNL;
        EmitIndent;
        writechar(97); writechar(100); writechar(100); writechar(32);  { add }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
        EmitNL;
        EmitPushX0;
        NextToken
      end
      else
        Error(9);
      Expect(TOK_COMMA);
      { Second arg: dest string variable }
      if tok_type <> TOK_IDENT then
        Error(6);
      idx := SymLookup;
      if idx < 0 then
        Error(3);
      if sym_type[idx] <> TYPE_STRING then
        Error(9);
      NextToken;
      EmitVarAddr(idx, scope_level);
      EmitPushX0;
      Expect(TOK_COMMA);
      { Third arg: position }
      ParseExpression;
      { x0=pos, stack has source and dest }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(50); writechar(44); writechar(32);  { x2, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      EmitPopX1;  { dest }
      EmitPopX0;  { source }
      EmitBL(rt_str_insert);
      Expect(TOK_RPAREN)
    end
    { str = 115,116,114 - but only if not a local variable }
    else if (tok_len = 3) and (tok_str[0] = 115) and (tok_str[1] = 116) and
            (tok_str[2] = 114) and (SymLookup < 0) then
    begin
      { str(n, s) - convert integer n to string s }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: integer expression }
      ParseExpression;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Second arg: string variable }
      if tok_type <> TOK_IDENT then
        Error(6);
      idx := SymLookup;
      if idx < 0 then
        Error(3);
      if sym_type[idx] <> TYPE_STRING then
        Error(9);
      NextToken;
      EmitVarAddr(idx, scope_level);
      { x0 = string addr, pop integer into x1 then swap }
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      EmitPopX0;  { x0 = integer value }
      { Now: x0 = integer, x1 = string addr }
      EmitBL(rt_int_to_str);
      Expect(TOK_RPAREN)
    end
    { val = 118,97,108 - but only if not a local variable }
    else if (tok_len = 3) and (tok_str[0] = 118) and (tok_str[1] = 97) and
            (tok_str[2] = 108) and (SymLookup < 0) then
    begin
      { val(s, v, code) - convert string s to integer v, error in code }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: string }
      if tok_type = TOK_IDENT then
      begin
        idx := SymLookup;
        if idx < 0 then
          Error(3);
        if sym_type[idx] <> TYPE_STRING then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      end
      else if tok_type = TOK_STRING then
      begin
        { String literal - allocate temp on heap }
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
        writechar(120); writechar(50); writechar(49);  { x21 }
        EmitNL;
        EmitMovX0(tok_len);
        EmitIndent;
        writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
        writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
        writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
        EmitNL;
        for i := 0 to tok_len - 1 do
        begin
          EmitMovX0(tok_str[i]);
          EmitIndent;
          writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
          writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
          writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
          writechar(35);
          write(i + 1);
          writechar(93);  { ] }
          EmitNL
        end;
        EmitIndent;
        writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
        writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
        writechar(120); writechar(50); writechar(49);  { x21 }
        EmitNL;
        EmitIndent;
        writechar(97); writechar(100); writechar(100); writechar(32);  { add }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
        writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
        EmitNL;
        NextToken
      end
      else
        Error(9);
      { Call rt_str_to_int: x0=string addr -> x0=value, x1=error }
      EmitBL(rt_str_to_int);
      { Save both results: push error first (x1), then value (x0) }
      EmitPushX1;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Second arg: integer variable to receive value }
      if tok_type <> TOK_IDENT then
        Error(6);
      idx := SymLookup;
      if idx < 0 then
        Error(3);
      NextToken;
      { Get address of v into x0, move to x1, pop value, store }
      EmitVarAddr(idx, scope_level);
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      EmitPopX0;  { value }
      { str x0, [x1] }
      EmitIndent;
      writechar(115); writechar(116); writechar(114); writechar(32);  { str }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
      EmitNL;
      Expect(TOK_COMMA);
      { Third arg: integer variable to receive error code }
      if tok_type <> TOK_IDENT then
        Error(6);
      idx := SymLookup;
      if idx < 0 then
        Error(3);
      NextToken;
      { Get address of code into x0, move to x1, pop error, store }
      EmitVarAddr(idx, scope_level);
      EmitIndent;
      writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
      writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
      writechar(120); writechar(48);  { x0 }
      EmitNL;
      EmitPopX0;  { error }
      { str x0, [x1] }
      EmitIndent;
      writechar(115); writechar(116); writechar(114); writechar(32);  { str }
      writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
      writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
      EmitNL;
      Expect(TOK_RPAREN)
    end
    { clrscr = 99,108,114,115,99,114 }
    else if TokIs8(99, 108, 114, 115, 99, 114, 0, 0) = 1 then
    begin
      NextToken;
      EmitBL(rt_clrscr)
    end
    { gotoxy = 103,111,116,111,120,121 }
    else if TokIs8(103, 111, 116, 111, 120, 121, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;    { x }
      EmitPushX0;
      Expect(TOK_COMMA);
      ParseExpression;    { y }
      EmitPopX1;          { x1=x, x0=y }
      EmitBL(rt_gotoxy);
      Expect(TOK_RPAREN)
    end
    { clreol = 99,108,114,101,111,108 }
    else if TokIs8(99, 108, 114, 101, 111, 108, 0, 0) = 1 then
    begin
      NextToken;
      EmitBL(rt_clreol)
    end
    { textcolor = 116,101,120,116,99,111,108,111,114 (9 chars) }
    else if (tok_len = 9) and (ToLower(tok_str[0]) = 116) and (ToLower(tok_str[1]) = 101) and
            (ToLower(tok_str[2]) = 120) and (ToLower(tok_str[3]) = 116) and (ToLower(tok_str[4]) = 99) and
            (ToLower(tok_str[5]) = 111) and (ToLower(tok_str[6]) = 108) and (ToLower(tok_str[7]) = 111) and
            (ToLower(tok_str[8]) = 114) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;    { color code 0-7 }
      EmitBL(rt_textcolor);
      Expect(TOK_RPAREN)
    end
    { textbackground = 116,101,120,116,98,97,99,107,103,114,111,117,110,100 (14 chars) }
    else if (tok_len = 14) and (ToLower(tok_str[0]) = 116) and (ToLower(tok_str[1]) = 101) and
            (ToLower(tok_str[2]) = 120) and (ToLower(tok_str[3]) = 116) and (ToLower(tok_str[4]) = 98) and
            (ToLower(tok_str[5]) = 97) and (ToLower(tok_str[6]) = 99) and (ToLower(tok_str[7]) = 107) and
            (ToLower(tok_str[8]) = 103) and (ToLower(tok_str[9]) = 114) and (ToLower(tok_str[10]) = 111) and
            (ToLower(tok_str[11]) = 117) and (ToLower(tok_str[12]) = 110) and (ToLower(tok_str[13]) = 100) then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;    { color code 0-7 }
      EmitBL(rt_textbackground);
      Expect(TOK_RPAREN)
    end
    { normvideo = 110,111,114,109,118,105,100,101,111 (9 chars) }
    else if (tok_len = 9) and (ToLower(tok_str[0]) = 110) and (ToLower(tok_str[1]) = 111) and
            (ToLower(tok_str[2]) = 114) and (ToLower(tok_str[3]) = 109) and (ToLower(tok_str[4]) = 118) and
            (ToLower(tok_str[5]) = 105) and (ToLower(tok_str[6]) = 100) and (ToLower(tok_str[7]) = 101) and
            (ToLower(tok_str[8]) = 111) then
    begin
      NextToken;
      EmitBL(rt_normvideo)
    end
    { highvideo = 104,105,103,104,118,105,100,101,111 (9 chars) }
    else if (tok_len = 9) and (ToLower(tok_str[0]) = 104) and (ToLower(tok_str[1]) = 105) and
            (ToLower(tok_str[2]) = 103) and (ToLower(tok_str[3]) = 104) and (ToLower(tok_str[4]) = 118) and
            (ToLower(tok_str[5]) = 105) and (ToLower(tok_str[6]) = 100) and (ToLower(tok_str[7]) = 101) and
            (ToLower(tok_str[8]) = 111) then
    begin
      NextToken;
      EmitBL(rt_highvideo)
    end
    { lowvideo = 108,111,119,118,105,100,101,111 (8 chars) }
    else if TokIs8(108, 111, 119, 118, 105, 100, 101, 111) = 1 then
    begin
      NextToken;
      EmitBL(rt_lowvideo)
    end
    { hidecursor = 104,105,100,101,99,117,114,115,111,114 (10 chars) }
    else if (tok_len = 10) and (ToLower(tok_str[0]) = 104) and (ToLower(tok_str[1]) = 105) and
            (ToLower(tok_str[2]) = 100) and (ToLower(tok_str[3]) = 101) and (ToLower(tok_str[4]) = 99) and
            (ToLower(tok_str[5]) = 117) and (ToLower(tok_str[6]) = 114) and (ToLower(tok_str[7]) = 115) and
            (ToLower(tok_str[8]) = 111) and (ToLower(tok_str[9]) = 114) then
    begin
      NextToken;
      EmitBL(rt_hidecursor)
    end
    { showcursor = 115,104,111,119,99,117,114,115,111,114 (10 chars) }
    else if (tok_len = 10) and (ToLower(tok_str[0]) = 115) and (ToLower(tok_str[1]) = 104) and
            (ToLower(tok_str[2]) = 111) and (ToLower(tok_str[3]) = 119) and (ToLower(tok_str[4]) = 99) and
            (ToLower(tok_str[5]) = 117) and (ToLower(tok_str[6]) = 114) and (ToLower(tok_str[7]) = 115) and
            (ToLower(tok_str[8]) = 111) and (ToLower(tok_str[9]) = 114) then
    begin
      NextToken;
      EmitBL(rt_showcursor)
    end
    { sleep = 115,108,101,101,112 (5 chars) - Sleep(ms) }
    else if TokIs8(115, 108, 101, 101, 112, 0, 0, 0) = 1 then
    begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;  { ms in x0 }
      EmitBL(rt_sleep);
      Expect(TOK_RPAREN)
    end
    { initkeyboard = 105,110,105,116,107,101,121,98,111,97,114,100 (12 chars) }
    else if (tok_len = 12) and (ToLower(tok_str[0]) = 105) and (ToLower(tok_str[1]) = 110) and
            (ToLower(tok_str[2]) = 105) and (ToLower(tok_str[3]) = 116) and (ToLower(tok_str[4]) = 107) and
            (ToLower(tok_str[5]) = 101) and (ToLower(tok_str[6]) = 121) and (ToLower(tok_str[7]) = 98) and
            (ToLower(tok_str[8]) = 111) and (ToLower(tok_str[9]) = 97) and (ToLower(tok_str[10]) = 114) and
            (ToLower(tok_str[11]) = 100) then
    begin
      NextToken;
      EmitBL(rt_initkeyboard)
    end
    { donekeyboard = 100,111,110,101,107,101,121,98,111,97,114,100 (12 chars) }
    else if (tok_len = 12) and (ToLower(tok_str[0]) = 100) and (ToLower(tok_str[1]) = 111) and
            (ToLower(tok_str[2]) = 110) and (ToLower(tok_str[3]) = 101) and (ToLower(tok_str[4]) = 107) and
            (ToLower(tok_str[5]) = 101) and (ToLower(tok_str[6]) = 121) and (ToLower(tok_str[7]) = 98) and
            (ToLower(tok_str[8]) = 111) and (ToLower(tok_str[9]) = 97) and (ToLower(tok_str[10]) = 114) and
            (ToLower(tok_str[11]) = 100) then
    begin
      NextToken;
      EmitBL(rt_donekeyboard)
    end
    else
    begin
      { Check for WITH context - try to find identifier as a field }
      if with_rec_idx >= 0 then
      begin
        arg_count := FindField(with_rec_type);  { reuse arg_count for field_idx }
        if arg_count >= 0 then
        begin
          { Found field - handle assignment }
          NextToken;
          Expect(TOK_ASSIGN);
          ParseExpression;  { value in x0 or d0 }
          { Compute address: base + field_offset }
          if field_type[arg_count] = TYPE_REAL then
          begin
            { Value is in d0, need to store to field }
            if expr_type <> TYPE_REAL then
              EmitScvtfD0X0;
            EmitPushD0;  { save value }
          end
          else
            EmitPushX0;  { save value }
          { Compute address }
          if sym_level[with_rec_idx] < scope_level then
          begin
            EmitFollowChain(sym_level[with_rec_idx], scope_level);
            EmitIndent;
            writechar(97); writechar(100); writechar(100); writechar(32);  { add }
            writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
            writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
            writechar(35);
            write(sym_offset[with_rec_idx] + field_offset[arg_count]);
            EmitNL
          end
          else
          begin
            EmitIndent;
            writechar(97); writechar(100); writechar(100); writechar(32);  { add }
            writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
            writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
            writechar(35);
            write(sym_offset[with_rec_idx] + field_offset[arg_count]);
            EmitNL
          end;
          { Store value to field }
          if field_type[arg_count] = TYPE_REAL then
          begin
            EmitPopD0;
            { str d0, [x1] }
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(32);  { str }
            writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
            writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
            EmitNL
          end
          else
          begin
            EmitPopX0;
            { str x0, [x1] }
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(32);  { str }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
            EmitNL
          end
        end
        else
        begin
          { Field not found, proceed with normal lookup }
          idx := SymLookup;
          if idx < 0 then
            Error(3)
        end
      end
      else
      begin
        { Not a built-in, look up in symbol table }
        idx := SymLookup;
        if idx < 0 then
          Error(3)
      end;
      { Skip if we already handled WITH field assignment }
      if (with_rec_idx < 0) or (arg_count < 0) then
      begin
      NextToken;

      if sym_kind[idx] = SYM_PROCEDURE then
      begin
        { Procedure call - pass args in x0-x7 }
        arg_count := 0;
        var_flags := sym_var_param_flags[idx];
        if tok_type = TOK_LPAREN then
        begin
          NextToken;
          if tok_type <> TOK_RPAREN then
          begin
            { Evaluate all args and push to stack }
            repeat
              if tok_type = TOK_COMMA then NextToken;
              { Check if this is a var parameter }
              if IsVarParam(var_flags, arg_count) = 1 then
              begin
                { Var param - pass address of variable }
                if tok_type <> TOK_IDENT then
                  Error(6);  { var param requires variable }
                var_arg_idx := SymLookup;
                if var_arg_idx < 0 then
                  Error(3);
                NextToken;
                { Check for array element - pass address of element }
                if (sym_type[var_arg_idx] = TYPE_ARRAY) and (tok_type = TOK_LBRACKET) then
                begin
                  NextToken;  { consume '[' }
                  ParseExpression;  { index in x0 }
                  Expect(TOK_RBRACKET);
                  { Compute element address }
                  EmitPushX0;
                  EmitMovX0(sym_const_val[var_arg_idx]);  { low bound }
                  EmitPopX1;
                  { x0 = x1 - x0 = index - low_bound }
                  EmitIndent;
                  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
                  writechar(120); writechar(48);  { x0 }
                  EmitNL;
                  { Multiply by 8 using lsl #3 }
                  EmitIndent;
                  writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(35); writechar(51);  { #3 }
                  EmitNL;
                  { Get base address and subtract element offset }
                  if sym_level[var_arg_idx] < scope_level then
                  begin
                    EmitFollowChain(sym_level[var_arg_idx], scope_level);
                    EmitSubLargeOffset(1, 8, 0 - sym_offset[var_arg_idx])
                  end
                  else
                    EmitSubLargeOffset(1, 29, 0 - sym_offset[var_arg_idx]);
                  { Address = base - element_offset }
                  EmitIndent;
                  writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
                  writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
                  writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
                  writechar(120); writechar(48);  { x0 }
                  EmitNL
                end
                else
                  { Simple variable - emit address }
                  EmitVarAddr(var_arg_idx, scope_level)
              end
              else
              begin
                { Value param - evaluate expression }
                ParseExpression
              end;
              EmitPushX0;
              arg_count := arg_count + 1
            until tok_type <> TOK_COMMA
          end;
          Expect(TOK_RPAREN)
        end;
        { Pop args from stack into registers in reverse order }
        for i := arg_count - 1 downto 0 do
        begin
          EmitIndent;
          writechar(108); writechar(100); writechar(114); writechar(32);  { ldr }
          writechar(120); writechar(48 + i); writechar(44); writechar(32);  { xi, }
          writechar(91); writechar(115); writechar(112); writechar(93);  { [sp] }
          writechar(44); writechar(32); writechar(35); writechar(49); writechar(54);  { , #16 }
          EmitNL
        end;
        { Set up static link for callee }
        EmitStaticLink(sym_level[idx], scope_level);
        EmitBL(sym_label[idx])
      end
      else if (sym_kind[idx] = SYM_VAR) or (sym_kind[idx] = SYM_PARAM) then
      begin
        if (sym_type[idx] = TYPE_ARRAY) and (tok_type = TOK_LBRACKET) then
        begin
          { Array element assignment: arr[index] := expr or arr[index].field := expr }
          NextToken;  { consume '[' }
          ParseExpression;  { index in x0 }
          Expect(TOK_RBRACKET);
          { Subtract low bound }
          EmitPushX0;
          EmitMovX0(sym_const_val[idx]);
          EmitPopX1;
          { x0 = x1 - x0 = index - low_bound }
          EmitIndent;
          writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
          writechar(120); writechar(48);  { x0 }
          EmitNL;
          { Multiply by element size }
          if sym_var_param_flags[idx] > 0 then
          begin
            { Array of records }
            lbl1 := sym_label[sym_var_param_flags[idx] - 1];
            EmitPushX0;
            EmitMovX0(lbl1);
            EmitPopX1;
            EmitIndent;
            writechar(109); writechar(117); writechar(108); writechar(32);  { mul }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
            writechar(120); writechar(48);  { x0 }
            EmitNL
          end
          else
          begin
            EmitIndent;
            writechar(108); writechar(115); writechar(108); writechar(32);  { lsl }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(35); writechar(51);  { #3 }
            EmitNL
          end;
          { Get base address }
          if sym_level[idx] < scope_level then
          begin
            EmitFollowChain(sym_level[idx], scope_level);
            EmitSubLargeOffset(1, 8, 0 - sym_offset[idx])
          end
          else
            EmitSubLargeOffset(1, 29, 0 - sym_offset[idx]);
          { x1 = base, x0 = offset, compute element address in x1 }
          EmitIndent;
          writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
          writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
          writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
          writechar(120); writechar(48);  { x0 }
          EmitNL;
          { Check for field access }
          if (sym_var_param_flags[idx] > 0) and (tok_type = TOK_DOT) then
          begin
            NextToken;
            arg_count := FindField(sym_var_param_flags[idx] - 1);
            if arg_count < 0 then
              Error(11);
            NextToken;
            { Add field offset }
            if field_offset[arg_count] > 0 then
            begin
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
              writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
              writechar(35);
              write(field_offset[arg_count]);
              EmitNL
            end;
            EmitPushX1;  { save field address }
            Expect(TOK_ASSIGN);
            ParseExpression;
            if field_type[arg_count] = TYPE_REAL then
            begin
              if expr_type <> TYPE_REAL then
                EmitScvtfD0X0;
              EmitPopX1;
              EmitIndent;
              writechar(115); writechar(116); writechar(114); writechar(32);  { str }
              writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL
            end
            else
            begin
              EmitPopX1;
              EmitIndent;
              writechar(115); writechar(116); writechar(114); writechar(32);  { str }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL
            end
          end
          else
          begin
            { Basic array assignment }
            EmitPushX1;  { save element address }
            Expect(TOK_ASSIGN);
            ParseExpression;
            EmitPopX1;
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(32);  { str }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
            EmitNL
          end
        end
        else if (sym_type[idx] = TYPE_RECORD) and (tok_type = TOK_DOT) then
        begin
          { Record field assignment: rec.field := value }
          NextToken;  { consume '.' }
          if tok_type <> TOK_IDENT then
            Error(11);
          { Find the field }
          arg_count := FindField(sym_const_val[idx]);  { reuse arg_count for field_idx }
          if arg_count < 0 then
            Error(15);  { undefined field }
          NextToken;
          Expect(TOK_ASSIGN);
          ParseExpression;  { value in x0 or d0 }

          { Compute field address: base + field_offset }
          if field_type[arg_count] = TYPE_REAL then
          begin
            { Value is in d0, need to store to field }
            if expr_type <> TYPE_REAL then
              EmitScvtfD0X0;
            EmitPushD0;  { save value }
            { Compute address }
            if sym_level[idx] < scope_level then
            begin
              EmitFollowChain(sym_level[idx], scope_level);
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
              writechar(35);
              write(sym_offset[idx] + field_offset[arg_count]);
              EmitNL
            end
            else
            begin
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
              writechar(35);
              write(sym_offset[idx] + field_offset[arg_count]);
              EmitNL
            end;
            EmitPopD0;
            { str d0, [x0] }
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(32);  { str }
            writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL
          end
          else
          begin
            { Value is in x0 }
            EmitPushX0;  { save value }
            { Compute address }
            if sym_level[idx] < scope_level then
            begin
              EmitFollowChain(sym_level[idx], scope_level);
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
              writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
              writechar(35);
              write(sym_offset[idx] + field_offset[arg_count]);
              EmitNL
            end
            else
            begin
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
              writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
              writechar(35);
              write(sym_offset[idx] + field_offset[arg_count]);
              EmitNL
            end;
            EmitPopX0;
            { str x0, [x1] }
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(32);  { str }
            writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
            writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
            EmitNL
          end
        end
        else if (sym_type[idx] = TYPE_POINTER) and (tok_type = TOK_CARET) then
        begin
          { Pointer dereference assignment: p^ := value or p^.field := value }
          NextToken;  { consume ^ }
          { Load pointer value (address) }
          if sym_level[idx] < scope_level then
            EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
          else
            EmitLdurX0(sym_offset[idx]);

          if (sym_const_val[idx] = TYPE_RECORD) and (tok_type = TOK_DOT) then
          begin
            { Pointer to record field assignment: p^.field := value }
            NextToken;  { consume '.' }
            { Find field in the record type }
            arg_count := FindField(sym_label[idx]);  { sym_label has record type index }
            if arg_count < 0 then
              Error(11);  { unknown field }
            NextToken;  { consume field name }
            { Add field offset to pointer: x0 = x0 + offset }
            if field_offset[arg_count] > 0 then
            begin
              EmitIndent;
              writechar(97); writechar(100); writechar(100); writechar(32);  { add }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(35);
              write(field_offset[arg_count]);
              EmitNL
            end;
            EmitPushX0;  { save field address }
            Expect(TOK_ASSIGN);
            ParseExpression;  { value to store }
            if field_type[arg_count] = TYPE_REAL then
            begin
              if expr_type <> TYPE_REAL then
                EmitScvtfD0X0;
              EmitPopX1;  { get address into x1 }
              { str d0, [x1] }
              EmitIndent;
              writechar(115); writechar(116); writechar(114); writechar(32);  { str }
              writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL
            end
            else
            begin
              EmitPopX1;  { get address into x1 }
              { str x0, [x1] }
              EmitIndent;
              writechar(115); writechar(116); writechar(114); writechar(32);  { str }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL
            end
          end
          else
          begin
            { Simple pointer dereference assignment: p^ := value }
            EmitPushX0;  { save address }
            Expect(TOK_ASSIGN);
            ParseExpression;  { value to store }
            if sym_const_val[idx] = TYPE_REAL then
            begin
              { Value in d0, need to store through pointer }
              if expr_type <> TYPE_REAL then
                EmitScvtfD0X0;
              EmitPopX1;  { get address into x1 }
              { str d0, [x1] }
              EmitIndent;
              writechar(115); writechar(116); writechar(114); writechar(32);  { str }
              writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL
            end
            else
            begin
              { Value in x0 }
              EmitPopX1;  { get address into x1 }
              { str x0, [x1] }
              EmitIndent;
              writechar(115); writechar(116); writechar(114); writechar(32);  { str }
              writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
              writechar(91); writechar(120); writechar(49); writechar(93);  { [x1] }
              EmitNL
            end
          end
        end
        else if sym_type[idx] = TYPE_STRING then
        begin
          { Check for string indexed assignment s[i] := char }
          if tok_type = TOK_LBRACKET then
          begin
            NextToken;  { consume '[' }
            { Get string base address }
            EmitVarAddr(idx, scope_level);
            EmitPushX0;  { save base address }
            ParseExpression;  { index in x0 }
            Expect(TOK_RBRACKET);
            { Add index to base: address = base + index }
            EmitPopX1;  { x1 = base address }
            EmitIndent;
            writechar(97); writechar(100); writechar(100); writechar(32);  { add }
            writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
            writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
            writechar(120); writechar(48);  { x0 }
            EmitNL;
            { x8 now has the address to store to }
            Expect(TOK_ASSIGN);
            ParseExpression;  { value to store in x0 }
            { strb w0, [x8] }
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
            writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
            writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
            EmitNL
          end
          else
          begin
          { String assignment }
          Expect(TOK_ASSIGN);
          if tok_type = TOK_STRING then
          begin
            { Assign from string literal }
            { Compute base address of string variable into x8 }
            if sym_level[idx] < scope_level then
            begin
              EmitFollowChain(sym_level[idx], scope_level);
              { add/sub x8, x8, #offset }
              if sym_offset[idx] < 0 then
              begin
                EmitIndent;
                writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
                writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
                writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
                writechar(35);
                write(0 - sym_offset[idx]);
                EmitNL
              end
              else
              begin
                EmitIndent;
                writechar(97); writechar(100); writechar(100); writechar(32);  { add }
                writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
                writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
                writechar(35);
                write(sym_offset[idx]);
                EmitNL
              end
            end
            else
            begin
              { add/sub x8, x29, #offset }
              if sym_offset[idx] < 0 then
              begin
                EmitIndent;
                writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
                writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
                writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
                writechar(35);
                write(0 - sym_offset[idx]);
                EmitNL
              end
              else
              begin
                EmitIndent;
                writechar(97); writechar(100); writechar(100); writechar(32);  { add }
                writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
                writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
                writechar(35);
                write(sym_offset[idx]);
                EmitNL
              end
            end;
            { Store length at [x8] }
            EmitMovX0(tok_len);
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
            writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
            writechar(91); writechar(120); writechar(56); writechar(93);  { [x8] }
            EmitNL;
            { Store each character at [x8+1], [x8+2], etc }
            for i := 0 to tok_len - 1 do
            begin
              EmitMovX0(tok_str[i]);
              EmitIndent;
              writechar(115); writechar(116); writechar(114); writechar(98); writechar(32);  { strb }
              writechar(119); writechar(48); writechar(44); writechar(32);  { w0, }
              writechar(91); writechar(120); writechar(56); writechar(44); writechar(32);  { [x8, }
              writechar(35);
              write(i + 1);
              writechar(93);  { ] }
              EmitNL
            end;
            NextToken
          end
          else
          begin
            { Parse string expression (variable, copy, concat, or + expressions) }
            ParseExpression;
            if expr_type <> TYPE_STRING then
              Error(12);  { expected string }
            { x0 = source string address, copy to dest }
            EmitIndent;
            writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
            writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
            writechar(120); writechar(48);  { x0 }
            EmitNL;
            { Get dest address into x0 }
            EmitVarAddr(idx, scope_level);
            { Call rt_str_copy(x0=dest, x1=source) }
            EmitBL(rt_str_copy)
          end
          end  { end of else for string whole assignment }
        end
        else if sym_type[idx] = TYPE_REAL then
        begin
          { Real variable assignment }
          Expect(TOK_ASSIGN);
          ParseExpression;
          { Convert integer to float if needed }
          if expr_type <> TYPE_REAL then
            EmitScvtfD0X0;
          { Check if this is a var param - need to dereference address }
          if sym_is_var_param[idx] = 1 then
          begin
            { d0 has the value, need to store to address in var param }
            EmitPushD0;  { save value }
            { Load the address stored in the var param }
            if sym_level[idx] < scope_level then
              EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            else
              EmitLdurX0(sym_offset[idx]);
            { x0 now has the address, pop value to d0 }
            EmitPopD0;
            { Store d0 to [x0] }
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(32);  { str }
            writechar(100); writechar(48); writechar(44); writechar(32);  { d0, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL
          end
          else
          begin
            if sym_level[idx] < scope_level then
              EmitSturD0Outer(sym_offset[idx], sym_level[idx], scope_level)
            else
              EmitSturD0(sym_offset[idx])
          end
        end
        else
        begin
          { Simple integer assignment }
          Expect(TOK_ASSIGN);
          ParseExpression;
          { Check if this is a var param - need to dereference address }
          if sym_is_var_param[idx] = 1 then
          begin
            { x0 has the value, need to store to address in var param }
            EmitPushX0;  { save value }
            { Load the address stored in the var param }
            if sym_level[idx] < scope_level then
              EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            else
              EmitLdurX0(sym_offset[idx]);
            { x0 now has the address, pop value to x1 }
            EmitPopX1;
            { Store x1 to [x0] }
            EmitIndent;
            writechar(115); writechar(116); writechar(114); writechar(32);  { str }
            writechar(120); writechar(49); writechar(44); writechar(32);  { x1, }
            writechar(91); writechar(120); writechar(48); writechar(93);  { [x0] }
            EmitNL
          end
          else
          begin
            if sym_level[idx] < scope_level then
              EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            else
              EmitSturX0(sym_offset[idx])
          end
        end
      end
      else if sym_kind[idx] = SYM_FUNCTION then
      begin
        { Function result assignment - store to result variable at -16 }
        Expect(TOK_ASSIGN);
        ParseExpression;
        { For real functions, store in d0 }
        if sym_type[idx] = TYPE_REAL then
        begin
          if expr_type <> TYPE_REAL then
            EmitScvtfD0X0;
          EmitSturD0(-16)
        end
        else if sym_type[idx] = TYPE_STRING then
        begin
          { String function - x0 has source string addr, copy to heap for return }
          { x0 = source, x1 = dest (heap), call str_copy }
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
          writechar(120); writechar(48);  { x0 - save source }
          EmitNL;
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(48); writechar(44); writechar(32);  { x0, }
          writechar(120); writechar(50); writechar(49);  { x21 - heap ptr }
          EmitNL;
          { Save heap addr as result }
          EmitSturX0(-16);
          { x8 = dest, x9 = source for str_copy }
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
          writechar(120); writechar(56);  { x8 - source }
          EmitNL;
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
          writechar(120); writechar(50); writechar(49);  { x21 - dest }
          EmitNL;
          EmitBL(rt_str_copy);
          { Advance heap pointer }
          EmitIndent;
          writechar(97); writechar(100); writechar(100); writechar(32);  { add }
          writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
          writechar(120); writechar(50); writechar(49); writechar(44); writechar(32);  { x21, }
          writechar(35); writechar(50); writechar(53); writechar(54);  { #256 }
          EmitNL
        end
        else
          EmitSturX0(-16)
      end
      else
        Error(7)
      end  { end of if (with_rec_idx < 0) or (arg_count < 0) }
    end  { end of else for non-builtin identifier }
  end  { end of else if tok_type = TOK_IDENT }
end;

{ ----- Declarations ----- }

procedure ParseVarDeclarations;
var
  idx, first_idx, arr_size, lo_bound, hi_bound, j, base_idx: integer;
begin
  NextToken;  { consume 'var' }
  while tok_type = TOK_IDENT do
  begin
    { Remember first var in a group for fixing up array size }
    local_offset := local_offset - 8;
    first_idx := SymAdd(SYM_VAR, TYPE_INTEGER, scope_level, local_offset);
    idx := first_idx;
    NextToken;
    while tok_type = TOK_COMMA do
    begin
      NextToken;
      if tok_type <> TOK_IDENT then
        Error(8);
      local_offset := local_offset - 8;
      idx := SymAdd(SYM_VAR, TYPE_INTEGER, scope_level, local_offset);
      NextToken
    end;
    Expect(TOK_COLON);
    { Parse type }
    if (tok_type = TOK_INTEGER_TYPE) or (tok_type = TOK_CHAR_TYPE) or
       (tok_type = TOK_BOOLEAN_TYPE) then
      NextToken
    else if tok_type = TOK_REAL_TYPE then
    begin
      { Set type to real for all vars in this group }
      for j := first_idx to idx do
        sym_type[j] := TYPE_REAL;
      NextToken
    end
    else if tok_type = TOK_ARRAY then
    begin
      NextToken;
      Expect(TOK_LBRACKET);
      { Parse low bound }
      if tok_type = TOK_INTEGER then
      begin
        lo_bound := tok_int;
        NextToken
      end
      else
        Error(9);
      Expect(TOK_DOTDOT);
      { Parse high bound }
      if tok_type = TOK_INTEGER then
      begin
        hi_bound := tok_int;
        NextToken
      end
      else
        Error(9);
      Expect(TOK_RBRACKET);
      Expect(TOK_OF);
      { Parse element type }
      if (tok_type = TOK_INTEGER_TYPE) or (tok_type = TOK_CHAR_TYPE) or
         (tok_type = TOK_BOOLEAN_TYPE) then
      begin
        NextToken;
        arr_size := (hi_bound - lo_bound + 1) * 8;
        local_offset := local_offset - (arr_size - 8);
        sym_type[first_idx] := TYPE_ARRAY;
        sym_const_val[first_idx] := lo_bound;
        sym_label[first_idx] := arr_size;
        sym_var_param_flags[first_idx] := 0  { 0 = basic type element }
      end
      else if tok_type = TOK_IDENT then
      begin
        { Array of record type }
        base_idx := SymLookup;
        if (base_idx >= 0) and (sym_kind[base_idx] = SYM_TYPEDEF) and (sym_type[base_idx] = TYPE_RECORD) then
        begin
          arr_size := (hi_bound - lo_bound + 1) * sym_label[base_idx];
          local_offset := local_offset - (arr_size - 8);
          sym_type[first_idx] := TYPE_ARRAY;
          sym_const_val[first_idx] := lo_bound;
          sym_label[first_idx] := arr_size;
          sym_var_param_flags[first_idx] := base_idx + 1;  { record type index + 1 (0 means basic) }
          NextToken
        end
        else
          Error(9)
      end
      else
        Error(9)
    end
    else if tok_type = TOK_STRING_TYPE then
    begin
      { String type: 256 bytes (1 length byte + 255 char bytes) }
      NextToken;
      { Handle all variables in the list }
      for j := first_idx to idx do
      begin
        sym_type[j] := TYPE_STRING;
        sym_label[j] := 256;  { Store size for reference }
        { Adjust offset: already allocated 8 bytes, need 248 more }
        if j = first_idx then
        begin
          local_offset := local_offset - 248;
          sym_offset[j] := local_offset  { Update offset to start of 256-byte area }
        end
        else
        begin
          local_offset := local_offset - 256;
          sym_offset[j] := local_offset
        end
      end
    end
    else if tok_type = TOK_CARET then
    begin
      { Pointer type: ^BaseType }
      NextToken;
      if tok_type = TOK_INTEGER_TYPE then
      begin
        for j := first_idx to idx do
        begin
          sym_type[j] := TYPE_POINTER;
          sym_const_val[j] := TYPE_INTEGER  { base type }
        end;
        NextToken
      end
      else if tok_type = TOK_CHAR_TYPE then
      begin
        for j := first_idx to idx do
        begin
          sym_type[j] := TYPE_POINTER;
          sym_const_val[j] := TYPE_CHAR
        end;
        NextToken
      end
      else if tok_type = TOK_BOOLEAN_TYPE then
      begin
        for j := first_idx to idx do
        begin
          sym_type[j] := TYPE_POINTER;
          sym_const_val[j] := TYPE_BOOLEAN
        end;
        NextToken
      end
      else if tok_type = TOK_REAL_TYPE then
      begin
        for j := first_idx to idx do
        begin
          sym_type[j] := TYPE_POINTER;
          sym_const_val[j] := TYPE_REAL
        end;
        NextToken
      end
      else if tok_type = TOK_IDENT then
      begin
        { Pointer to record type: ^RecordType }
        arr_size := SymLookup;  { reuse arr_size as type_idx }
        if (arr_size >= 0) and (sym_kind[arr_size] = SYM_TYPEDEF) and (sym_type[arr_size] = TYPE_RECORD) then
        begin
          for j := first_idx to idx do
          begin
            sym_type[j] := TYPE_POINTER;
            sym_const_val[j] := TYPE_RECORD;
            sym_label[j] := arr_size  { store record type index }
          end;
          NextToken
        end
        else
          Error(14)  { expected type identifier }
      end
      else
        Error(14)  { expected type identifier }
    end
    else if tok_type = TOK_IDENT then
    begin
      { May be a record type name }
      arr_size := SymLookup;  { reuse arr_size as type_idx temporarily }
      if (arr_size >= 0) and (sym_kind[arr_size] = SYM_TYPEDEF) and (sym_type[arr_size] = TYPE_RECORD) then
      begin
        { Allocate space for record }
        lo_bound := sym_label[arr_size];  { reuse lo_bound for record size }
        { Adjust local_offset: we already allocated 8 bytes, need rest }
        local_offset := local_offset - (lo_bound - 8);
        for j := first_idx to idx do
        begin
          sym_type[j] := TYPE_RECORD;
          sym_const_val[j] := arr_size  { link to type definition }
        end;
        NextToken
      end
      else
        Error(9)
    end
    else
      Error(9);
    Expect(TOK_SEMICOLON)
  end
end;

procedure ParseConstDeclarations;
var
  idx: integer;
begin
  NextToken;  { consume 'const' }
  while tok_type = TOK_IDENT do
  begin
    idx := SymAdd(SYM_CONST, TYPE_INTEGER, scope_level, 0);
    NextToken;
    Expect(TOK_EQ);
    if tok_type = TOK_INTEGER then
    begin
      sym_const_val[idx] := tok_int;
      NextToken
    end
    else
      Error(10);
    Expect(TOK_SEMICOLON)
  end
end;

procedure ParseTypeDeclarations;
var
  type_idx, fld_start, fld_offset, fld_type: integer;
  i, base_idx: integer;
begin
  NextToken;  { consume 'type' }
  while tok_type = TOK_IDENT do
  begin
    { Create type symbol }
    type_idx := SymAdd(SYM_TYPEDEF, TYPE_RECORD, scope_level, 0);
    NextToken;
    Expect(TOK_EQ);
    if tok_type = TOK_RECORD then
    begin
      NextToken;  { consume 'record' }
      fld_start := field_count;
      fld_offset := 0;
      sym_const_val[type_idx] := fld_start;  { first field index }

      { Parse fields until 'end' }
      while tok_type <> TOK_END do
      begin
        if tok_type <> TOK_IDENT then
          Error(11);

        { Save field name }
        base_idx := field_count * 32;
        for i := 0 to tok_len - 1 do
          field_name[base_idx + i] := tok_str[i];
        field_name[base_idx + tok_len] := 0;

        NextToken;
        Expect(TOK_COLON);

        { Parse field type }
        if tok_type = TOK_INTEGER_TYPE then
        begin
          fld_type := TYPE_INTEGER;
          NextToken
        end
        else if tok_type = TOK_CHAR_TYPE then
        begin
          fld_type := TYPE_CHAR;
          NextToken
        end
        else if tok_type = TOK_BOOLEAN_TYPE then
        begin
          fld_type := TYPE_BOOLEAN;
          NextToken
        end
        else if tok_type = TOK_REAL_TYPE then
        begin
          fld_type := TYPE_REAL;
          NextToken
        end
        else
          Error(9);

        field_type[field_count] := fld_type;
        field_offset[field_count] := fld_offset;
        field_rec_idx[field_count] := type_idx;
        field_count := field_count + 1;
        fld_offset := fld_offset + 8;  { all fields are 8 bytes }

        { Expect semicolon or end }
        if tok_type = TOK_SEMICOLON then
          NextToken
      end;

      NextToken;  { consume 'end' }
      sym_label[type_idx] := fld_offset  { total record size }
    end
    else
      Error(9);
    Expect(TOK_SEMICOLON)
  end
end;

procedure ParseProcedureDeclaration; forward;
procedure ParseFunctionDeclaration; forward;

procedure ParseBlock;
var
  saved_offset: integer;
  alloc_size: integer;
  body_label: integer;
begin
  saved_offset := local_offset;
  body_label := 0;

  while (tok_type = TOK_CONST) or (tok_type = TOK_VAR) or (tok_type = TOK_TYPE_KW) do
  begin
    if tok_type = TOK_CONST then
      ParseConstDeclarations
    else if tok_type = TOK_TYPE_KW then
      ParseTypeDeclarations
    else
      ParseVarDeclarations
  end;

  { If there are procedure/function declarations, jump over them }
  if (tok_type = TOK_PROCEDURE) or (tok_type = TOK_FUNCTION) then
  begin
    body_label := NewLabel;
    EmitBranchLabel(body_label)
  end;

  while (tok_type = TOK_PROCEDURE) or (tok_type = TOK_FUNCTION) do
  begin
    if tok_type = TOK_PROCEDURE then
      ParseProcedureDeclaration
    else
      ParseFunctionDeclaration
  end;

  if body_label > 0 then
    EmitLabel(body_label);

  { Allocate stack space - round up to 16 for alignment }
  alloc_size := 0;
  if local_offset < saved_offset then
  begin
    alloc_size := saved_offset - local_offset;
    alloc_size := ((alloc_size + 15) div 16) * 16;
    EmitSubSP(alloc_size)
  end;

  Expect(TOK_BEGIN);
  ParseStatement;
  while tok_type = TOK_SEMICOLON do
  begin
    NextToken;
    ParseStatement
  end;
  Expect(TOK_END);

  { Deallocate stack space }
  if alloc_size > 0 then
  begin
    EmitAddSP(alloc_size)
  end
end;

procedure ParseProcedureDeclaration;
var
  idx, proc_label: integer;
  saved_level, saved_offset: integer;
  param_count, param_idx, i, j: integer;
  param_indices: array[0..7] of integer;
  is_var_group: integer;
begin
  NextToken;  { consume 'procedure' }

  if tok_type <> TOK_IDENT then
    Error(11);

  { Check if procedure already exists (forward declaration) }
  idx := SymLookup;
  if (idx >= 0) and (sym_kind[idx] = SYM_PROCEDURE) then
  begin
    { Reuse existing forward-declared procedure }
    proc_label := sym_label[idx]
  end
  else
  begin
    { Create new procedure symbol }
    idx := SymAdd(SYM_PROCEDURE, TYPE_VOID, scope_level, 0);
    proc_label := NewLabel;
    sym_label[idx] := proc_label
  end;
  NextToken;

  { Save state and enter new scope for parameters }
  saved_level := scope_level;
  saved_offset := local_offset;
  scope_level := scope_level + 1;
  local_offset := -8;  { Reserve -8 for static link }
  param_count := 0;

  { Handle optional parameters }
  if tok_type = TOK_LPAREN then
  begin
    NextToken;
    if tok_type <> TOK_RPAREN then
    begin
      repeat
        if tok_type = TOK_SEMICOLON then NextToken;
        { Check for 'var' keyword - applies to all idents in this group }
        is_var_group := 0;
        if tok_type = TOK_VAR then
        begin
          is_var_group := 1;
          NextToken
        end;
        { Parse identifier list for this parameter group }
        if tok_type <> TOK_IDENT then Error(11);
        repeat
          if tok_type = TOK_COMMA then NextToken;
          if tok_type <> TOK_IDENT then Error(11);
          { Add parameter }
          local_offset := local_offset - 8;
          param_idx := SymAdd(SYM_PARAM, TYPE_INTEGER, scope_level, local_offset);
          if is_var_group = 1 then
            sym_is_var_param[param_idx] := 1;
          if param_count < 8 then
            param_indices[param_count] := param_idx;
          param_count := param_count + 1;
          NextToken
        until tok_type <> TOK_COMMA;
        { Parse type annotation and set param types }
        if tok_type = TOK_COLON then
        begin
          NextToken;
          if tok_type = TOK_REAL_TYPE then
          begin
            { Set all params in this group to TYPE_REAL }
            { Find starting index of this group and set types }
            { param_indices has the indices, but we need to know where this group started }
            { For simplicity, set all recent params to real - this is approximate }
            sym_type[param_idx] := TYPE_REAL;
            NextToken
          end
          else if tok_type = TOK_STRING_TYPE then
          begin
            { String parameter }
            sym_type[param_idx] := TYPE_STRING;
            if is_var_group = 0 then
            begin
              { Value parameter - need 256 bytes total, already have 8, need 248 more }
              local_offset := local_offset - 248;
              sym_offset[param_idx] := local_offset;  { Update offset to start of 256-byte area }
              sym_label[param_idx] := 256  { Mark as needing copy-in }
            end;
            { var string params keep the 8-byte slot for address }
            NextToken
          end
          else if (tok_type = TOK_INTEGER_TYPE) or (tok_type = TOK_CHAR_TYPE) or
             (tok_type = TOK_BOOLEAN_TYPE) then
            NextToken
        end
      until tok_type <> TOK_SEMICOLON
    end;
    Expect(TOK_RPAREN)
  end;

  { Build var-param bitmap and store on procedure symbol }
  sym_var_param_flags[idx] := 0;
  for i := 0 to param_count - 1 do
    if sym_is_var_param[param_indices[i]] = 1 then
    begin
      if i = 0 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 1;
      if i = 1 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 2;
      if i = 2 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 4;
      if i = 3 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 8;
      if i = 4 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 16;
      if i = 5 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 32;
      if i = 6 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 64;
      if i = 7 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 128
    end;

  Expect(TOK_SEMICOLON);

  { Check for forward declaration }
  if tok_type = TOK_FORWARD then
  begin
    NextToken;
    Expect(TOK_SEMICOLON);
    PopScope(scope_level);
    scope_level := saved_level;
    local_offset := saved_offset
  end
  else
  begin

  { Emit procedure label and prolog - save x29, x30, static link }
  EmitLabel(proc_label);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);  { Allocate space for static link }
  EmitStoreStaticLink;

  { Allocate space for parameters and copy from registers }
  if param_count > 0 then
  begin
    { Allocate based on actual space needed (local_offset tracks it) }
    { param_space = -(local_offset) - 8 (static link already counted separately) }
    j := 0 - local_offset - 8;
    j := ((j + 15) div 16) * 16;  { Align to 16 }
    if j > 0 then
      EmitSubSP(j);
    for i := 0 to param_count - 1 do
    begin
      if i < 8 then
      begin
        { Check if this is a string value parameter (needs copy) }
        if (sym_type[param_indices[i]] = TYPE_STRING) and (sym_is_var_param[param_indices[i]] = 0) then
        begin
          { String value param: xi has address of source, copy to local storage }
          { x9 = source (passed address), compute x8 = dest using large offset handling }
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
          writechar(120); writechar(48 + i);  { xi }
          EmitNL;
          { Compute dest address: x8 = x29 - offset (handle large negative offset) }
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
          writechar(35);
          write(0 - sym_offset[param_indices[i]]);  { positive value }
          EmitNL;
          EmitIndent;
          writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
          writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
          writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
          writechar(120); writechar(56);  { x8 }
          EmitNL;
          EmitBL(rt_str_copy)
        end
        else
        begin
          { Normal param: store register to stack }
          EmitIndent;
          writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
          writechar(120); writechar(48 + i); writechar(44); writechar(32);  { xi, }
          writechar(91); writechar(120); writechar(50); writechar(57);  { [x29 }
          writechar(44); writechar(32); writechar(35);  { , # }
          write(sym_offset[param_indices[i]]);
          writechar(93);  { ] }
          EmitNL
        end
      end
    end
  end;

  { Parse procedure body }
  ParseBlock;

  { Pop local symbols and restore scope }
  PopScope(scope_level);
  scope_level := saved_level;
  local_offset := saved_offset;

  { Restore sp to frame pointer (undoes static link + params + local allocations) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;

  { Restore frame and return }
  EmitLdp;
  EmitIndent;
  writechar(114); writechar(101); writechar(116);  { ret }
  EmitNL;

  Expect(TOK_SEMICOLON)
  end  { end of else for non-forward declaration }
end;

procedure ParseFunctionDeclaration;
var
  idx, func_label: integer;
  saved_level, saved_offset: integer;
  param_count, param_idx, i, j: integer;
  param_indices: array[0..7] of integer;
  is_var_group: integer;
begin
  NextToken;  { consume 'function' }

  if tok_type <> TOK_IDENT then
    Error(11);

  { Check if function already exists (forward declaration) }
  idx := SymLookup;
  if (idx >= 0) and (sym_kind[idx] = SYM_FUNCTION) then
  begin
    { Reuse existing forward-declared function }
    func_label := sym_label[idx]
  end
  else
  begin
    { Create new function symbol }
    idx := SymAdd(SYM_FUNCTION, TYPE_INTEGER, scope_level, 0);
    func_label := NewLabel;
    sym_label[idx] := func_label
  end;
  NextToken;

  { Save state and enter new scope for parameters }
  saved_level := scope_level;
  saved_offset := local_offset;
  scope_level := scope_level + 1;
  local_offset := -16;  { Reserve -8 for static link, -16 for result }
  param_count := 0;

  { Handle optional parameters }
  if tok_type = TOK_LPAREN then
  begin
    NextToken;
    if tok_type <> TOK_RPAREN then
    begin
      repeat
        if tok_type = TOK_SEMICOLON then NextToken;
        { Check for 'var' keyword - applies to all idents in this group }
        is_var_group := 0;
        if tok_type = TOK_VAR then
        begin
          is_var_group := 1;
          NextToken
        end;
        { Parse identifier list for this parameter group }
        if tok_type <> TOK_IDENT then Error(11);
        repeat
          if tok_type = TOK_COMMA then NextToken;
          if tok_type <> TOK_IDENT then Error(11);
          { Add parameter }
          local_offset := local_offset - 8;
          param_idx := SymAdd(SYM_PARAM, TYPE_INTEGER, scope_level, local_offset);
          if is_var_group = 1 then
            sym_is_var_param[param_idx] := 1;
          if param_count < 8 then
            param_indices[param_count] := param_idx;
          param_count := param_count + 1;
          NextToken
        until tok_type <> TOK_COMMA;
        { Parse type annotation and set param types }
        if tok_type = TOK_COLON then
        begin
          NextToken;
          if tok_type = TOK_REAL_TYPE then
          begin
            sym_type[param_idx] := TYPE_REAL;
            NextToken
          end
          else if tok_type = TOK_STRING_TYPE then
          begin
            { String parameter }
            sym_type[param_idx] := TYPE_STRING;
            if is_var_group = 0 then
            begin
              { Value parameter - need 256 bytes total, already have 8, need 248 more }
              local_offset := local_offset - 248;
              sym_offset[param_idx] := local_offset;  { Update offset to start of 256-byte area }
              sym_label[param_idx] := 256  { Mark as needing copy-in }
            end;
            { var string params keep the 8-byte slot for address }
            NextToken
          end
          else if (tok_type = TOK_INTEGER_TYPE) or (tok_type = TOK_CHAR_TYPE) or
             (tok_type = TOK_BOOLEAN_TYPE) then
            NextToken
        end
      until tok_type <> TOK_SEMICOLON
    end;
    Expect(TOK_RPAREN)
  end;

  { Build var-param bitmap and store on function symbol }
  sym_var_param_flags[idx] := 0;
  for i := 0 to param_count - 1 do
    if sym_is_var_param[param_indices[i]] = 1 then
    begin
      if i = 0 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 1;
      if i = 1 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 2;
      if i = 2 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 4;
      if i = 3 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 8;
      if i = 4 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 16;
      if i = 5 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 32;
      if i = 6 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 64;
      if i = 7 then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 128
    end;

  { Parse return type }
  Expect(TOK_COLON);
  if (tok_type = TOK_INTEGER_TYPE) or (tok_type = TOK_CHAR_TYPE) or
     (tok_type = TOK_BOOLEAN_TYPE) then
    NextToken
  else if tok_type = TOK_REAL_TYPE then
  begin
    sym_type[idx] := TYPE_REAL;
    NextToken
  end
  else if tok_type = TOK_STRING_TYPE then
  begin
    sym_type[idx] := TYPE_STRING;
    NextToken
  end
  else
    Error(9);

  Expect(TOK_SEMICOLON);

  { Check for forward declaration }
  if tok_type = TOK_FORWARD then
  begin
    NextToken;
    Expect(TOK_SEMICOLON);
    PopScope(scope_level);
    scope_level := saved_level;
    local_offset := saved_offset
  end
  else
  begin

  { Emit function label and prolog - save x29, x30, static link }
  EmitLabel(func_label);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);  { Allocate space for static link }
  EmitStoreStaticLink;

  { Allocate space for parameters and copy from registers }
  if param_count > 0 then
  begin
    { Allocate based on actual space needed (local_offset tracks it) }
    { For functions, local_offset includes return value at -16, params start at -24 }
    j := 0 - local_offset - 16;  { -16 for return value slot }
    j := ((j + 15) div 16) * 16;  { Align to 16 }
    if j > 0 then
      EmitSubSP(j);
    for i := 0 to param_count - 1 do
    begin
      if i < 8 then
      begin
        { Check if this is a string value parameter (needs copy) }
        if (sym_type[param_indices[i]] = TYPE_STRING) and (sym_is_var_param[param_indices[i]] = 0) then
        begin
          { String value param: xi has address of source, copy to local storage }
          { x9 = source (passed address), compute x8 = dest using large offset handling }
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(57); writechar(44); writechar(32);  { x9, }
          writechar(120); writechar(48 + i);  { xi }
          EmitNL;
          { Compute dest address: x8 = x29 - offset (handle large negative offset) }
          EmitIndent;
          writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
          writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
          writechar(35);
          write(0 - sym_offset[param_indices[i]]);  { positive value }
          EmitNL;
          EmitIndent;
          writechar(115); writechar(117); writechar(98); writechar(32);  { sub }
          writechar(120); writechar(56); writechar(44); writechar(32);  { x8, }
          writechar(120); writechar(50); writechar(57); writechar(44); writechar(32);  { x29, }
          writechar(120); writechar(56);  { x8 }
          EmitNL;
          EmitBL(rt_str_copy)
        end
        else
        begin
          { Normal param: store register to stack }
          EmitIndent;
          writechar(115); writechar(116); writechar(117); writechar(114); writechar(32);  { stur }
          writechar(120); writechar(48 + i); writechar(44); writechar(32);  { xi, }
          writechar(91); writechar(120); writechar(50); writechar(57);  { [x29 }
          writechar(44); writechar(32); writechar(35);  { , # }
          write(sym_offset[param_indices[i]]);
          writechar(93);  { ] }
          EmitNL
        end
      end
    end
  end;

  { Parse function body }
  ParseBlock;

  { Pop local symbols and restore scope }
  PopScope(scope_level);
  scope_level := saved_level;
  local_offset := saved_offset;

  { Load result from local variable into x0 or d0 }
  if sym_type[idx] = TYPE_REAL then
    EmitLdurD0(-16)
  else
    EmitLdurX0(-16);

  { Restore sp to frame pointer (undoes static link + params + local allocations) }
  EmitIndent;
  writechar(109); writechar(111); writechar(118); writechar(32);  { mov }
  writechar(115); writechar(112); writechar(44); writechar(32);  { sp, }
  writechar(120); writechar(50); writechar(57);  { x29 }
  EmitNL;

  { Restore frame and return }
  EmitLdp;
  EmitIndent;
  writechar(114); writechar(101); writechar(116);  { ret }
  EmitNL;

  Expect(TOK_SEMICOLON)
  end  { end of else for non-forward declaration }
end;

procedure ParseProgram;
var
  main_lbl: integer;
begin
  Expect(TOK_PROGRAM);
  if tok_type <> TOK_IDENT then
    Error(11);
  NextToken;
  Expect(TOK_SEMICOLON);

  { Emit header }
  EmitGlobl;
  EmitAlign4;
  EmitMain;

  { Jump over runtime routines }
  main_lbl := NewLabel;
  EmitBranchLabel(main_lbl);

  { Emit runtime routines }
  rt_print_int := NewLabel;
  rt_newline := NewLabel;
  rt_readchar := NewLabel;
  rt_print_char := NewLabel;
  rt_read_int := NewLabel;
  rt_skip_line := NewLabel;
  rt_print_string := NewLabel;
  rt_print_real := NewLabel;
  rt_read_real := NewLabel;
  rt_read_string := NewLabel;
  rt_heap_init := NewLabel;
  rt_str_copy := NewLabel;
  rt_str_compare := NewLabel;
  rt_str_concat := NewLabel;
  rt_str_cmp := NewLabel;
  rt_str_pos := NewLabel;
  rt_str_delete := NewLabel;
  rt_str_insert := NewLabel;
  rt_int_to_str := NewLabel;
  rt_str_to_int := NewLabel;
  rt_str_ltrim := NewLabel;
  rt_str_rtrim := NewLabel;
  rt_str_trim := NewLabel;
  rt_clrscr := NewLabel;
  rt_gotoxy := NewLabel;
  rt_clreol := NewLabel;
  rt_textcolor := NewLabel;
  rt_textbackground := NewLabel;
  rt_normvideo := NewLabel;
  rt_highvideo := NewLabel;
  rt_lowvideo := NewLabel;
  rt_hidecursor := NewLabel;
  rt_showcursor := NewLabel;
  rt_sleep := NewLabel;
  rt_keypressed := NewLabel;
  rt_initkeyboard := NewLabel;
  rt_donekeyboard := NewLabel;

  EmitPrintIntRuntime;
  EmitNewlineRuntime;
  EmitReadcharRuntime;
  EmitPrintCharRuntime;
  EmitReadIntRuntime;
  EmitSkipLineRuntime;
  EmitPrintStringRuntime;
  EmitPrintRealRuntime;
  EmitReadRealRuntime;
  EmitReadStringRuntime;
  EmitHeapInitRuntime;
  EmitStrCopyRuntime;
  EmitStrCompareRuntime;
  EmitStrConcatRuntime;
  EmitStrCmpRuntime;
  EmitStrPosRuntime;
  EmitStrDeleteRuntime;
  EmitStrInsertRuntime;
  EmitIntToStrRuntime;
  EmitStrToIntRuntime;
  EmitStrLtrimRuntime;
  EmitStrRtrimRuntime;
  EmitStrTrimRuntime;
  EmitClrScrRuntime;
  EmitGotoXYRuntime;
  EmitClrEolRuntime;
  EmitTextColorRuntime;
  EmitTextBackgroundRuntime;
  EmitNormVideoRuntime;
  EmitHighVideoRuntime;
  EmitLowVideoRuntime;
  EmitHideCursorRuntime;
  EmitShowCursorRuntime;
  EmitSleepRuntime;
  EmitKeyPressedRuntime;
  EmitInitKeyboardRuntime;
  EmitDoneKeyboardRuntime;

  { Main program entry }
  EmitLabel(main_lbl);
  EmitStp;
  EmitMovFP;
  EmitFileOpenInit;
  EmitBL(rt_heap_init);

  ParseBlock;

  Expect(TOK_DOT);

  { Exit syscall }
  EmitMovX0(0);
  EmitMovX16(33554433);  { 0x2000001 }
  EmitSvc
end;

{ ----- Main ----- }

begin
  { Initialize }
  line_num := 1;
  col_num := 0;
  sym_count := 0;
  scope_level := 0;
  local_offset := 0;
  label_count := 0;
  string_count := 0;
  had_error := 0;
  rt_print_int := 0;
  rt_newline := 0;
  rt_readchar := 0;
  rt_print_char := 0;
  rt_read_int := 0;
  rt_skip_line := 0;
  rt_print_string := 0;
  rt_print_real := 0;
  rt_read_real := 0;
  rt_read_string := 0;
  rt_heap_init := 0;
  rt_str_copy := 0;
  rt_str_compare := 0;
  rt_str_concat := 0;
  string_temp_idx := 0;
  out_fd := 1;
  pushback_ch := -1;
  expr_type := TYPE_INTEGER;
  ptr_base_type := TYPE_INTEGER;
  field_count := 0;
  with_rec_idx := -1;
  with_rec_type := 0;

  { Read first character and token }
  NextChar;
  NextToken;

  { Compile the program }
  ParseProgram
end.
