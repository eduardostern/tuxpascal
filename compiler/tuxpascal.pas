{ TuxPascal - Self-hosting Pascal Compiler }
{ Written in Pascal, compiled by bootstrap }
{ Generated by merging include files - do not edit directly }

program TuxPascal;

Const
  MAX_TOKENS = 1000;
  MAX_SYMBOLS = 100;
  MAX_STRINGS = 64;
  MAX_NAME = 32;

  { Token types }
  TOK_EOF = 0;
  TOK_IDENT = 1;
  TOK_INTEGER = 2;
  TOK_STRING = 3;
  TOK_PLUS = 4;
  TOK_MINUS = 5;
  TOK_STAR = 6;
  TOK_SLASH = 7;
  TOK_EQ = 8;
  TOK_NEQ = 9;
  TOK_LT = 10;
  TOK_GT = 11;
  TOK_LE = 12;
  TOK_GE = 13;
  TOK_LPAREN = 14;
  TOK_RPAREN = 15;
  TOK_LBRACKET = 16;
  TOK_RBRACKET = 17;
  TOK_ASSIGN = 18;
  TOK_COLON = 19;
  TOK_SEMICOLON = 20;
  TOK_COMMA = 21;
  TOK_DOT = 22;
  TOK_DOTDOT = 23;
  TOK_CARET = 24;    { ^ - dereference/pointer Type }
  TOK_AT = 25;       { @ - address-Of }

  { Keywords - starting at 100 }
  TOK_PROGRAM = 100;
  TOK_BEGIN = 101;
  TOK_END = 102;
  TOK_VAR = 103;
  TOK_CONST = 104;
  TOK_PROCEDURE = 105;
  TOK_FUNCTION = 106;
  TOK_IF = 107;
  TOK_THEN = 108;
  TOK_ELSE = 109;
  TOK_WHILE = 110;
  TOK_DO = 111;
  TOK_REPEAT = 112;
  TOK_UNTIL = 113;
  TOK_FOR = 114;
  TOK_TO = 115;
  TOK_DOWNTO = 116;
  TOK_ARRAY = 117;
  TOK_OF = 118;
  TOK_DIV = 119;
  TOK_MOD = 120;
  TOK_AND = 121;
  TOK_OR = 122;
  TOK_NOT = 123;
  TOK_TRUE = 124;
  TOK_FALSE = 125;
  TOK_INTEGER_TYPE = 126;
  TOK_CHAR_TYPE = 127;
  TOK_BOOLEAN_TYPE = 128;
  TOK_STRING_TYPE = 129;
  TOK_FORWARD = 130;
  TOK_READ = 131;
  TOK_READLN = 132;
  TOK_REAL_TYPE = 133;
  TOK_FLOAT_LITERAL = 134;
  TOK_NIL = 135;     { Nil keyword }
  TOK_RECORD = 136;  { Record keyword }
  TOK_TYPE_KW = 137;    { Type keyword }
  TOK_CASE = 138;    { Case keyword }
  TOK_WITH = 139;    { With keyword }
  TOK_TEXT = 140;    { Text file Type }
  TOK_FILE = 141;    { file keyword }
  TOK_SET = 142;     { Set keyword }
  TOK_IN = 143;      { In keyword (Set membership) }
  TOK_UNIT = 144;    { Unit keyword }
  TOK_INTERFACE = 145;      { Interface keyword }
  TOK_IMPLEMENTATION = 146; { Implementation keyword }
  TOK_USES = 147;    { Uses keyword }

  { Symbol kinds }
  SYM_VAR = 0;
  SYM_CONST = 1;
  SYM_PROCEDURE = 2;
  SYM_FUNCTION = 3;
  SYM_PARAM = 4;
  SYM_TYPEDEF = 5;       { Type definition (For records) }

  { Type kinds }
  TYPE_INTEGER = 0;
  TYPE_CHAR = 1;
  TYPE_BOOLEAN = 2;
  TYPE_STRING = 3;
  TYPE_ARRAY = 4;
  TYPE_VOID = 5;
  TYPE_REAL = 6;
  TYPE_POINTER = 7;
  TYPE_RECORD = 8;
  TYPE_FILE = 9;      { file Of T - typed file }
  TYPE_TEXT = 10;     { Text file }
  TYPE_ENUM = 11;     { enumerated Type }
  TYPE_SUBRANGE = 12; { subrange Type }
  TYPE_SET = 13;      { Set Type }

Var
  { Source input }
  ch: Integer;
  line_num, col_num: Integer;
  pushback_ch: Integer;  { -1 means no pushback }

  { Current token }
  tok_type: Integer;
  tok_int: Integer;
  tok_str: Array[0..255] Of Integer;  { String as Array Of chars }
  tok_len: Integer;

  { Symbol table - flattened 2D Array: sym_name[idx * 32 + char_pos] }
  sym_name: Array[0..15999] Of Integer;  { 500 symbols * 32 chars each }
  sym_kind: Array[0..499] Of Integer;
  sym_type: Array[0..499] Of Integer;
  sym_level: Array[0..499] Of Integer;
  sym_offset: Array[0..499] Of Integer;
  sym_const_val: Array[0..499] Of Integer;
  sym_label: Array[0..499] Of Integer;
  sym_is_var_param: Array[0..499] Of Integer;  { 1 If Var parameter (pass by ref) }
  sym_var_param_flags: Array[0..499] Of Integer;  { bitmap: bit i = 1 If param i is Var (For proc/func) }
  sym_unit_idx: Array[0..499] Of Integer;  { Unit index For imported symbols, -1 For local }
  sym_count: Integer;

  { Record field table }
  field_name: Array[0..6399] Of Integer;   { 200 fields * 32 chars each }
  field_type: Array[0..199] Of Integer;    { Type Of each field }
  field_offset: Array[0..199] Of Integer;  { offset within Record }
  field_rec_idx: Array[0..199] Of Integer; { which Record Type this field belongs To }
  field_rec_type: Array[0..199] Of Integer; { For TYPE_RECORD fields, the nested Record Type index }
  field_count: Integer;                    { total fields defined }

  { Pointer metadata For multi-level pointers And pointer-To-Array }
  ptr_depth: Array[0..499] Of Integer;        { pointer indirection depth (1=^T, 2=^^T) }
  ptr_ultimate_type: Array[0..499] Of Integer; { ultimate base Type after all derefs }
  ptr_ultimate_rec: Array[0..499] Of Integer;  { If ultimate base is Record, the Type index }
  ptr_arr_lo: Array[0..99] Of Integer;     { low bound For pointer-To-Array }
  ptr_arr_hi: Array[0..99] Of Integer;     { high bound For pointer-To-Array }
  ptr_arr_elem: Array[0..99] Of Integer;   { element Type For pointer-To-Array }
  ptr_arr_rec: Array[0..99] Of Integer;    { If element is Record, the Type index }
  ptr_arr_count: Integer;                  { count Of pointer-To-Array types }

  { Runtime labels For allocator }
  rt_alloc: Integer;
  rt_free: Integer;

  { Scope tracking }
  scope_level: Integer;
  local_offset: Integer;

  { Code generation }
  label_count: Integer;

  { String table - Not used yet, simplified }
  string_count: Integer;

  { Runtime labels }
  rt_print_int: Integer;
  rt_newline: Integer;
  rt_readchar: Integer;
  rt_print_char: Integer;
  rt_write_char_fd: Integer;  { Write single Char To file: x0=fd, x1=Char }
  rt_read_int: Integer;
  rt_skip_line: Integer;
  rt_print_string: Integer;
  rt_print_real: Integer;
  rt_read_real: Integer;
  rt_read_string: Integer;

  { Float literal parsing }
  tok_float_int: Integer;   { Integer part Of float }
  tok_float_frac: Integer;  { fractional part (scaled by 1000000) }
  tok_float_neg: Integer;   { 1 If negative }

  { Expression Type tracking }
  expr_type: Integer;

  { Pointer base Type tracking For arithmetic }
  ptr_base_type: Integer;

  { Output file descriptor - x20 is used To store it }
  out_fd: Integer;

  { Error flag }
  had_error: Integer;

  { With statement tracking }
  with_rec_idx: Integer;    { symbol index Of active With Record, -1 If none }
  with_rec_type: Integer;   { Type index For field lookup }

  { Loop control For Break/Continue }
  break_label: Integer;     { label To jump To For Break, 0 If Not In loop }
  continue_label: Integer;  { label To jump To For Continue, 0 If Not In loop }

  { Exit label For current Procedure/Function }
  exit_label: Integer;      { label To jump To For Exit, 0 If In main Program }

  { Runtime labels For heap }
  rt_heap_init: Integer;

  { Runtime labels For String operations }
  rt_str_copy: Integer;
  rt_str_compare: Integer;
  rt_str_concat: Integer;
  rt_str_cmp: Integer;  { lexicographic compare: returns -1, 0, Or 1 }
  rt_str_pos: Integer;  { find substring: returns position Or 0 }
  rt_str_delete: Integer;  { delete chars from String In place }
  rt_str_insert: Integer;  { insert String into another }
  rt_int_to_str: Integer;  { convert Integer To String }
  rt_str_to_int: Integer;  { convert String To Integer With error code }
  rt_str_ltrim: Integer;  { trim leading whitespace }
  rt_str_rtrim: Integer;  { trim trailing whitespace }
  rt_str_trim: Integer;   { trim both leading And trailing whitespace }

  { Runtime labels For screen/terminal control }
  rt_clrscr: Integer;     { clear screen And home cursor }
  rt_gotoxy: Integer;     { move cursor To x,y position }
  rt_clreol: Integer;     { clear To End Of line }
  rt_textcolor: Integer;  { Set foreground color }
  rt_textbackground: Integer;  { Set background color }
  rt_normvideo: Integer;  { reset attributes }
  rt_highvideo: Integer;  { bold/bright }
  rt_lowvideo: Integer;   { dim }
  rt_hidecursor: Integer; { hide cursor }
  rt_showcursor: Integer; { show cursor }
  rt_sleep: Integer;      { sleep For N milliseconds using nanosleep syscall }
  rt_keypressed: Integer; { check If key available (non-blocking) }
  rt_initkeyboard: Integer;  { Set terminal To raw mode }
  rt_donekeyboard: Integer;  { restore terminal To cooked mode }

  { Runtime labels For math functions }
  rt_sin: Integer;     { sin(x) - Taylor series }
  rt_cos: Integer;     { cos(x) - Taylor series }
  rt_tan: Integer;     { tan(x) = sin/cos }
  rt_exp: Integer;     { exp(x) - Taylor series }
  rt_ln: Integer;      { ln(x) - Newton iteration }
  rt_random: Integer;  { random - returns random Integer }
  rt_arctan: Integer;  { arctan(x) - Taylor series }
  rt_arcsin: Integer;  { arcsin(x) - derived from arctan }
  rt_arccos: Integer;  { arccos(x) - pi/2 - arcsin }

  { Runtime labels For command line }
  rt_paramstr: Integer;  { paramstr(n) - get command line argument as Pascal String }

  { Register usage:
    x25 = argc (saved at Program start)
    x26 = argv (saved at Program start)
    x27 = random seed }

  { Saved terminal settings For restore }
  saved_termios: Array[0..79] Of Integer;  { 80 bytes For termios struct }

  { String temp index (0-3) For copy/concat results }
  string_temp_idx: Integer;

  { File I/O metadata - element Type And size For typed files }
  file_elem_type: Array[0..99] Of Integer;  { element Type For file Of T }
  file_elem_size: Array[0..99] Of Integer;  { element size In bytes }
  file_rec_idx: Array[0..99] Of Integer;    { If element is Record, Type index }
  file_count: Integer;                      { count Of file types defined }

  { Enumerated Type metadata }
  enum_low: Array[0..99] Of Integer;        { first value (always 0) }
  enum_high: Array[0..99] Of Integer;       { last value }
  enum_count: Integer;                      { count Of enum types defined }

  { Subrange Type metadata }
  subr_low: Array[0..99] Of Integer;        { low bound }
  subr_high: Array[0..99] Of Integer;       { high bound }
  subr_base: Array[0..99] Of Integer;       { base Type (Integer, Char, enum) }
  subr_count: Integer;                      { count Of subrange types defined }

  { Set Type metadata - sets limited To 64 elements (fits In one register) }
  set_base: Array[0..99] Of Integer;        { base Type (Char, enum, subrange) }
  set_low: Array[0..99] Of Integer;         { low bound Of base Type }
  set_high: Array[0..99] Of Integer;        { high bound Of base Type }
  set_count: Integer;                       { count Of Set types defined }

  { File variable structure (at runtime, 272 bytes per file Var):
    offset 0: fd (8 bytes) - file descriptor, -1 If Not open
    offset 8: mode (8 bytes) - 0=closed, 1=Read, 2=Write, 3=append
    offset 16: filename (256 bytes) - null-terminated String }

  { Include file support - using individual variables since bootstrap doesn't support Array subscripts With eof }
  include_file0, include_file1, include_file2, include_file3: Text;
  include_file4, include_file5, include_file6, include_file7: Text;
  include_depth: Integer;                   { 0 = reading from stdin, >0 = In include }
  include_line: Array[0..7] Of Integer;     { Line number In each include file }
  include_col: Array[0..7] Of Integer;      { Column number In each include file }
  include_ch: Array[0..7] Of Integer;       { Current Char In each include file }
  include_pushback: Array[0..7] Of Integer; { Pushback Char For each include file }
  include_path: Array[0..2047] Of Integer;  { Paths Of included files (256 chars * 8 files) }

  { Unit/module support }
  compiling_unit: Integer;       { 0=Program, 1=Unit }
  in_interface: Integer;         { 1=In Interface section }
  current_unit_name: Array[0..31] Of Integer;  { Name Of current Unit being compiled }
  current_unit_len: Integer;

  { TPU file support }
  tpu_file: Text;                { File handle For reading/writing TPU }
  tpu_line: Array[0..1023] Of Integer;  { Buffer For reading TPU lines }
  tpu_line_len: Integer;         { Length Of current line }
  tpu_pos: Integer;              { Current parse position In tpu_line }

  { Interface symbol tracking - marks which symbols are exported }
  interface_start: Integer;      { First symbol index In Interface section }
  interface_end: Integer;        { Last symbol index In Interface section }

  { Loaded units tracking }
  loaded_units: Array[0..511] Of Integer;  { Unit names (16 units * 32 chars) }
  loaded_count: Integer;         { Number Of loaded units }
  unit_sym_start: Array[0..15] Of Integer;  { First symbol index For each Unit }
  unit_sym_end: Array[0..15] Of Integer;    { Last symbol index For each Unit }
  unit_init_label: Array[0..15] Of Integer; { Initialization label For each Unit }

{ ----- Utility ----- }

{ Emit helpers - output multiple chars at once }
Procedure E2(a, b: Integer);
Begin WriteChar(a); WriteChar(b) End;

Procedure E3(a, b, c: Integer);
Begin WriteChar(a); WriteChar(b); WriteChar(c) End;

Procedure E4(a, b, c, d: Integer);
Begin WriteChar(a); WriteChar(b); WriteChar(c); WriteChar(d) End;

Procedure E5(a, b, c, d, e: Integer);
Begin WriteChar(a); WriteChar(b); WriteChar(c); WriteChar(d); WriteChar(e) End;

Procedure E6(a, b, c, d, e, f: Integer);
Begin WriteChar(a); WriteChar(b); WriteChar(c); WriteChar(d); WriteChar(e); WriteChar(f) End;

Procedure Error(msg: Integer);
Var
  i: Integer;
Begin
  Write('Error ');
  Write(msg);
  Write(' at line ');
  Write(line_num);
  Write(' tok_type=');
  Write(tok_type);
  Write(' tok_len=');
  Write(tok_len);
  Write(' scope=');
  Write(scope_level);
  Write(' offset=');
  Write(local_offset);
  Write(' sym_count=');
  Write(sym_count);
  Write(' ch=');
  Write(ch);
  Write(' tok=');
  For i := 0 To tok_len - 1 Do
    WriteChar(tok_str[i]);
  WriteLn(0);
  Halt(1)
End;

Function IsDigit(c: Integer): Integer;
Begin
  If (c >= 48) And (c <= 57) Then
    IsDigit := 1
  Else
    IsDigit := 0
End;

Function IsAlpha(c: Integer): Integer;
Begin
  If ((c >= 65) And (c <= 90)) Or ((c >= 97) And (c <= 122)) Or (c = 95) Then
    IsAlpha := 1
  Else
    IsAlpha := 0
End;

Function ToLower(c: Integer): Integer;
Begin
  If (c >= 65) And (c <= 90) Then
    ToLower := c + 32
  Else
    ToLower := c
End;

Function StrEqual(idx: Integer): Integer;
Var
  i: Integer;
  match: Integer;
  base: Integer;
  c1, c2: Integer;
Begin
  { Compare tok_str With sym_name[idx] }
  { sym_name is flattened: base = idx * 32 }
  base := idx * 32;
  match := 1;
  i := 0;
  While (i < tok_len) And (match = 1) Do
  Begin
    c1 := tok_str[i];
    c2 := sym_name[base + i];
    If ToLower(c1) <> ToLower(c2) Then
      match := 0;
    i := i + 1
  End;
  If match = 1 Then
    If sym_name[base + tok_len] <> 0 Then
      match := 0;
  StrEqual := match
End;

{ Check If current token matches a String (Case insensitive) }
{ s1-s8 are ASCII codes Of the expected String, 0 marks End }
Function TokIs8(s1, s2, s3, s4, s5, s6, s7, s8: Integer): Integer;
Var
  i, match, slen: Integer;
  s: Array[0..7] Of Integer;
Begin
  s[0] := s1; s[1] := s2; s[2] := s3; s[3] := s4;
  s[4] := s5; s[5] := s6; s[6] := s7; s[7] := s8;
  { Find Length Of expected String }
  slen := 0;
  While (slen < 8) And (s[slen] <> 0) Do
    slen := slen + 1;
  { Check Length match }
  If tok_len <> slen Then
    match := 0
  Else
  Begin
    match := 1;
    i := 0;
    While (i < slen) And (match = 1) Do
    Begin
      If ToLower(tok_str[i]) <> ToLower(s[i]) Then
        match := 0;
      i := i + 1
    End
  End;
  TokIs8 := match
End;

{ ----- Lexer ----- }

{ Check If current include file is at EOF }
Function IncludeEof: Integer;
Begin
  IncludeEof := 0;
  If include_depth = 1 Then
  Begin If eof(include_file0) Then IncludeEof := 1 End
  Else If include_depth = 2 Then
  Begin If eof(include_file1) Then IncludeEof := 1 End
  Else If include_depth = 3 Then
  Begin If eof(include_file2) Then IncludeEof := 1 End
  Else If include_depth = 4 Then
  Begin If eof(include_file3) Then IncludeEof := 1 End
  Else If include_depth = 5 Then
  Begin If eof(include_file4) Then IncludeEof := 1 End
  Else If include_depth = 6 Then
  Begin If eof(include_file5) Then IncludeEof := 1 End
  Else If include_depth = 7 Then
  Begin If eof(include_file6) Then IncludeEof := 1 End
  Else If include_depth = 8 Then
  Begin If eof(include_file7) Then IncludeEof := 1 End
End;

{ Read a character from current include file }
Function IncludeRead: Integer;
Var
  c: Integer;
Begin
  c := -1;
  If include_depth = 1 Then
    Read(include_file0, c)
  Else If include_depth = 2 Then
    Read(include_file1, c)
  Else If include_depth = 3 Then
    Read(include_file2, c)
  Else If include_depth = 4 Then
    Read(include_file3, c)
  Else If include_depth = 5 Then
    Read(include_file4, c)
  Else If include_depth = 6 Then
    Read(include_file5, c)
  Else If include_depth = 7 Then
    Read(include_file6, c)
  Else If include_depth = 8 Then
    Read(include_file7, c);
  IncludeRead := c
End;

{ Close current include file }
Procedure IncludeClose;
Begin
  If include_depth = 1 Then
    close(include_file0)
  Else If include_depth = 2 Then
    close(include_file1)
  Else If include_depth = 3 Then
    close(include_file2)
  Else If include_depth = 4 Then
    close(include_file3)
  Else If include_depth = 5 Then
    close(include_file4)
  Else If include_depth = 6 Then
    close(include_file5)
  Else If include_depth = 7 Then
    close(include_file6)
  Else If include_depth = 8 Then
    close(include_file7)
End;

{ Read a single character from stdin Or current include file }
Function ReadCurrentChar: Integer;
Begin
  If include_depth = 0 Then
    ReadCurrentChar := ReadChar
  Else
  Begin
    If IncludeEof = 1 Then
      ReadCurrentChar := -1
    Else
      ReadCurrentChar := IncludeRead
  End
End;

{ Pop back To parent include file }
Procedure PopIncludeFile;
Begin
  If include_depth > 0 Then
  Begin
    IncludeClose;
    include_depth := include_depth - 1;
    { Restore parent file state }
    If include_depth > 0 Then
    Begin
      line_num := include_line[include_depth - 1];
      col_num := include_col[include_depth - 1];
      ch := include_ch[include_depth - 1];
      pushback_ch := include_pushback[include_depth - 1]
    End
  End
End;

Procedure NextChar;
Var
  c: Integer;
Begin
  If pushback_ch >= 0 Then
  Begin
    ch := pushback_ch;
    pushback_ch := -1
  End
  Else
  Begin
    c := ReadCurrentChar;
    { If EOF In include file, pop back To parent }
    While (c = -1) And (include_depth > 0) Do
    Begin
      PopIncludeFile;
      If include_depth = 0 Then
        c := ReadChar
      Else
        c := ReadCurrentChar
    End;
    ch := c;
    If ch = 10 Then
    Begin
      line_num := line_num + 1;
      col_num := 0
    End
    Else
      col_num := col_num + 1
  End
End;

{ Open include file using filename from tok_str at given position }
Procedure IncludeOpenFromTokStr(start, len: Integer);
Begin
  If include_depth = 1 Then
  Begin assigntokstr(include_file0, start, len); reset(include_file0) End
  Else If include_depth = 2 Then
  Begin assigntokstr(include_file1, start, len); reset(include_file1) End
  Else If include_depth = 3 Then
  Begin assigntokstr(include_file2, start, len); reset(include_file2) End
  Else If include_depth = 4 Then
  Begin assigntokstr(include_file3, start, len); reset(include_file3) End
  Else If include_depth = 5 Then
  Begin assigntokstr(include_file4, start, len); reset(include_file4) End
  Else If include_depth = 6 Then
  Begin assigntokstr(include_file5, start, len); reset(include_file5) End
  Else If include_depth = 7 Then
  Begin assigntokstr(include_file6, start, len); reset(include_file6) End
  Else If include_depth = 8 Then
  Begin assigntokstr(include_file7, start, len); reset(include_file7) End
End;

{ Push a New include file onto the stack }
Procedure PushIncludeFile(path_start, path_len: Integer);
Var
  i: Integer;
Begin
  If include_depth >= 8 Then
    Error(17)  { include nesting too deep - Error halts }
  Else
  Begin
    { Save current state }
    If include_depth > 0 Then
    Begin
      include_line[include_depth - 1] := line_num;
      include_col[include_depth - 1] := col_num;
      include_ch[include_depth - 1] := ch;
      include_pushback[include_depth - 1] := pushback_ch
    End;

    { Open include file }
    include_depth := include_depth + 1;
    IncludeOpenFromTokStr(path_start, path_len);

    { Store path For reference (include_depth is already incremented) }
    For i := 0 To path_len - 1 Do
      include_path[(include_depth - 1) * 256 + i] := tok_str[path_start + i];
    include_path[(include_depth - 1) * 256 + path_len] := 0;

    line_num := 1;
    col_num := 0;
    pushback_ch := -1;
    { Read first character from New file }
    ch := ReadCurrentChar
  End
End;

{ Parse And process include directive: dollar-I Or dollar-INCLUDE }
Procedure ParseIncludeDirective;
Var
  i: Integer;
Begin
  { Skip whitespace after I Or INCLUDE }
  While (ch = 32) Or (ch = 9) Do
    NextChar;

  { Read filename Until closing brace Or whitespace }
  i := 0;
  While (ch <> 125) And (ch <> 32) And (ch <> 9) And (ch <> -1) And (i < 255) Do
  Begin
    tok_str[i] := ch;
    i := i + 1;
    NextChar
  End;
  tok_str[i] := 0;

  { Skip To End Of directive }
  While (ch <> 125) And (ch <> -1) Do
    NextChar;
  If ch = 125 Then
    NextChar;

  { Process include }
  If i > 0 Then
    PushIncludeFile(0, i)
End;

Procedure SkipWhitespace;
Var
  directive_char: Integer;
Begin
  While (ch = 32) Or (ch = 9) Or (ch = 10) Or (ch = 13) Do
    NextChar;
  { Skip comments And process directives }
  If ch = 123 Then  { '{' }
  Begin
    NextChar;
    { Check For compiler directive }
    If ch = 36 Then  { '$' }
    Begin
      NextChar;
      directive_char := ToLower(ch);
      If directive_char = 105 Then  { 'i' }
      Begin
        NextChar;
        { Check For 'include' Or just whitespace after 'i' }
        If (ch = 32) Or (ch = 9) Or (ch = 125) Then
        Begin
          { Short form: dollar-I filename }
          ParseIncludeDirective;
          SkipWhitespace
        End
        Else If ToLower(ch) = 110 Then  { 'n' - could be 'include' }
        Begin
          { Check For 'nclude' }
          NextChar;
          If ToLower(ch) = 99 Then  { 'c' }
          Begin
            NextChar;
            If ToLower(ch) = 108 Then  { 'l' }
            Begin
              NextChar;
              If ToLower(ch) = 117 Then  { 'u' }
              Begin
                NextChar;
                If ToLower(ch) = 100 Then  { 'd' }
                Begin
                  NextChar;
                  If ToLower(ch) = 101 Then  { 'e' }
                  Begin
                    NextChar;
                    { Full form: dollar-INCLUDE filename }
                    ParseIncludeDirective;
                    SkipWhitespace
                  End
                  Else
                  Begin
                    { Unknown directive, skip To End }
                    While (ch <> 125) And (ch <> -1) Do NextChar;
                    If ch = 125 Then NextChar;
                    SkipWhitespace
                  End
                End
                Else
                Begin
                  While (ch <> 125) And (ch <> -1) Do NextChar;
                  If ch = 125 Then NextChar;
                  SkipWhitespace
                End
              End
              Else
              Begin
                While (ch <> 125) And (ch <> -1) Do NextChar;
                If ch = 125 Then NextChar;
                SkipWhitespace
              End
            End
            Else
            Begin
              While (ch <> 125) And (ch <> -1) Do NextChar;
              If ch = 125 Then NextChar;
              SkipWhitespace
            End
          End
          Else
          Begin
            While (ch <> 125) And (ch <> -1) Do NextChar;
            If ch = 125 Then NextChar;
            SkipWhitespace
          End
        End
        Else
        Begin
          { Unknown directive starting With 'i', skip }
          While (ch <> 125) And (ch <> -1) Do NextChar;
          If ch = 125 Then NextChar;
          SkipWhitespace
        End
      End
      Else
      Begin
        { Unknown directive, skip as comment }
        While (ch <> 125) And (ch <> -1) Do NextChar;
        If ch = 125 Then NextChar;
        SkipWhitespace
      End
    End
    Else
    Begin
      { Regular comment }
      While (ch <> 125) And (ch <> -1) Do
        NextChar;
      If ch = 125 Then
        NextChar;
      SkipWhitespace
    End
  End
End;

Procedure NextToken;
Var
  i: Integer;
Begin
  SkipWhitespace;

  If ch = -1 Then
  Begin
    tok_type := TOK_EOF;
    tok_len := 0
  End
  Else If IsDigit(ch) = 1 Then
  Begin
    tok_type := TOK_INTEGER;
    tok_int := 0;
    While IsDigit(ch) = 1 Do
    Begin
      tok_int := tok_int * 10 + (ch - 48);
      NextChar
    End;
    { Check For decimal point (but Not ..) }
    If ch = 46 Then  { '.' }
    Begin
      NextChar;
      If IsDigit(ch) = 1 Then
      Begin
        { This is a float literal }
        tok_type := TOK_FLOAT_LITERAL;
        tok_float_int := tok_int;
        tok_float_frac := 0;
        tok_float_neg := 0;
        { Parse fractional digits (up To 6 digits Of precision) }
        i := 0;
        While (IsDigit(ch) = 1) And (i < 6) Do
        Begin
          tok_float_frac := tok_float_frac * 10 + (ch - 48);
          i := i + 1;
          NextChar
        End;
        { Scale frac To 6 digits }
        While i < 6 Do
        Begin
          tok_float_frac := tok_float_frac * 10;
          i := i + 1
        End;
        { Skip any remaining fractional digits }
        While IsDigit(ch) = 1 Do
          NextChar
      End
      Else
      Begin
        { It was just an Integer followed by '.', push back current Char }
        { And Set pushback To '.' so next NextToken gets DOT Or DOTDOT }
        pushback_ch := ch;
        ch := 46  { Put '.' back as current so the DOT handling code gets it }
      End
    End
  End
  Else If IsAlpha(ch) = 1 Then
  Begin
    tok_type := TOK_IDENT;
    tok_len := 0;
    While (IsAlpha(ch) = 1) Or (IsDigit(ch) = 1) Do
    Begin
      If tok_len < 255 Then
      Begin
        tok_str[tok_len] := ch;
        tok_len := tok_len + 1
      End;
      NextChar
    End;
    tok_str[tok_len] := 0;

    { Check For keywords }
    { This is simplified - would need proper keyword table }
    If tok_len = 7 Then
      If (ToLower(tok_str[0]) = 112) And (ToLower(tok_str[1]) = 114) Then { pr }
        If (ToLower(tok_str[2]) = 111) And (ToLower(tok_str[3]) = 103) Then { og }
          If (ToLower(tok_str[4]) = 114) And (ToLower(tok_str[5]) = 97) Then { ra }
            If ToLower(tok_str[6]) = 109 Then { m }
              tok_type := TOK_PROGRAM;
    If tok_len = 5 Then
      If (ToLower(tok_str[0]) = 98) And (ToLower(tok_str[1]) = 101) Then { be }
        If (ToLower(tok_str[2]) = 103) And (ToLower(tok_str[3]) = 105) Then { gi }
          If ToLower(tok_str[4]) = 110 Then { n }
            tok_type := TOK_BEGIN;
    If tok_len = 3 Then
    Begin
      If (ToLower(tok_str[0]) = 101) And (ToLower(tok_str[1]) = 110) Then { en }
        If ToLower(tok_str[2]) = 100 Then { d }
          tok_type := TOK_END;
      If (ToLower(tok_str[0]) = 118) And (ToLower(tok_str[1]) = 97) Then { va }
        If ToLower(tok_str[2]) = 114 Then { r }
          tok_type := TOK_VAR;
      If (ToLower(tok_str[0]) = 100) And (ToLower(tok_str[1]) = 105) Then { di }
        If ToLower(tok_str[2]) = 118 Then { v }
          tok_type := TOK_DIV;
      If (ToLower(tok_str[0]) = 109) And (ToLower(tok_str[1]) = 111) Then { mo }
        If ToLower(tok_str[2]) = 100 Then { d }
          tok_type := TOK_MOD;
      If (ToLower(tok_str[0]) = 97) And (ToLower(tok_str[1]) = 110) Then { an }
        If ToLower(tok_str[2]) = 100 Then { d }
          tok_type := TOK_AND;
      If (ToLower(tok_str[0]) = 110) And (ToLower(tok_str[1]) = 111) Then { no }
        If ToLower(tok_str[2]) = 116 Then { t }
          tok_type := TOK_NOT;
      If (ToLower(tok_str[0]) = 102) And (ToLower(tok_str[1]) = 111) Then { fo }
        If ToLower(tok_str[2]) = 114 Then { r }
          tok_type := TOK_FOR;
      If (ToLower(tok_str[0]) = 110) And (ToLower(tok_str[1]) = 105) Then { ni }
        If ToLower(tok_str[2]) = 108 Then { l }
          tok_type := TOK_NIL;
      If (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 101) Then { se }
        If ToLower(tok_str[2]) = 116 Then { t }
          tok_type := TOK_SET
    End;
    If tok_len = 2 Then
    Begin
      If (ToLower(tok_str[0]) = 105) And (ToLower(tok_str[1]) = 102) Then { If }
        tok_type := TOK_IF;
      If (ToLower(tok_str[0]) = 100) And (ToLower(tok_str[1]) = 111) Then { Do }
        tok_type := TOK_DO;
      If (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 111) Then { To }
        tok_type := TOK_TO;
      If (ToLower(tok_str[0]) = 111) And (ToLower(tok_str[1]) = 114) Then { Or }
        tok_type := TOK_OR;
      If (ToLower(tok_str[0]) = 111) And (ToLower(tok_str[1]) = 102) Then { Of }
        tok_type := TOK_OF;
      If (ToLower(tok_str[0]) = 105) And (ToLower(tok_str[1]) = 110) Then { In }
        tok_type := TOK_IN
    End;
    If tok_len = 4 Then
    Begin
      If (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 104) Then { th }
        If (ToLower(tok_str[2]) = 101) And (ToLower(tok_str[3]) = 110) Then { en }
          tok_type := TOK_THEN;
      If (ToLower(tok_str[0]) = 101) And (ToLower(tok_str[1]) = 108) Then { el }
        If (ToLower(tok_str[2]) = 115) And (ToLower(tok_str[3]) = 101) Then { se }
          tok_type := TOK_ELSE;
      If (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 114) Then { tr }
        If (ToLower(tok_str[2]) = 117) And (ToLower(tok_str[3]) = 101) Then { ue }
          tok_type := TOK_TRUE
    End;
    If tok_len = 5 Then
    Begin
      If (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 111) Then { co }
        If (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 115) Then { ns }
          If ToLower(tok_str[4]) = 116 Then { t }
            tok_type := TOK_CONST;
      If (ToLower(tok_str[0]) = 119) And (ToLower(tok_str[1]) = 104) Then { wh }
        If (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 108) Then { il }
          If ToLower(tok_str[4]) = 101 Then { e }
            tok_type := TOK_WHILE;
      If (ToLower(tok_str[0]) = 117) And (ToLower(tok_str[1]) = 110) Then { un }
        If (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 105) Then { ti }
          If ToLower(tok_str[4]) = 108 Then { l }
            tok_type := TOK_UNTIL;
      If (ToLower(tok_str[0]) = 97) And (ToLower(tok_str[1]) = 114) Then { ar }
        If (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 97) Then { ra }
          If ToLower(tok_str[4]) = 121 Then { y }
            tok_type := TOK_ARRAY;
      If (ToLower(tok_str[0]) = 102) And (ToLower(tok_str[1]) = 97) Then { fa }
        If (ToLower(tok_str[2]) = 108) And (ToLower(tok_str[3]) = 115) Then { ls }
          If ToLower(tok_str[4]) = 101 Then { e }
            tok_type := TOK_FALSE
    End;
    If tok_len = 6 Then
    Begin
      If (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) Then { re }
        If (ToLower(tok_str[2]) = 112) And (ToLower(tok_str[3]) = 101) Then { pe }
          If (ToLower(tok_str[4]) = 97) And (ToLower(tok_str[5]) = 116) Then { at }
            tok_type := TOK_REPEAT;
      If (ToLower(tok_str[0]) = 100) And (ToLower(tok_str[1]) = 111) Then { Do }
        If (ToLower(tok_str[2]) = 119) And (ToLower(tok_str[3]) = 110) Then { wn }
          If (ToLower(tok_str[4]) = 116) And (ToLower(tok_str[5]) = 111) Then { To }
            tok_type := TOK_DOWNTO;
      If (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) Then { re }
        If (ToLower(tok_str[2]) = 97) And (ToLower(tok_str[3]) = 100) Then { ad }
          If (ToLower(tok_str[4]) = 108) And (ToLower(tok_str[5]) = 110) Then { ln }
            tok_type := TOK_READLN;
      If (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 116) Then { st }
        If (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 105) Then { ri }
          If (ToLower(tok_str[4]) = 110) And (ToLower(tok_str[5]) = 103) Then { ng }
            tok_type := TOK_STRING_TYPE;
      If (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) Then { re }
        If (ToLower(tok_str[2]) = 99) And (ToLower(tok_str[3]) = 111) Then { co }
          If (ToLower(tok_str[4]) = 114) And (ToLower(tok_str[5]) = 100) Then { rd }
            tok_type := TOK_RECORD
    End;
    If tok_len = 7 Then
    Begin
      If (ToLower(tok_str[0]) = 105) And (ToLower(tok_str[1]) = 110) Then { In }
        If (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 101) Then { te }
          If (ToLower(tok_str[4]) = 103) And (ToLower(tok_str[5]) = 101) Then { ge }
            If ToLower(tok_str[6]) = 114 Then { r }
              tok_type := TOK_INTEGER_TYPE;
      If (ToLower(tok_str[0]) = 98) And (ToLower(tok_str[1]) = 111) Then { bo }
        If (ToLower(tok_str[2]) = 111) And (ToLower(tok_str[3]) = 108) Then { ol }
          If (ToLower(tok_str[4]) = 101) And (ToLower(tok_str[5]) = 97) Then { ea }
            If ToLower(tok_str[6]) = 110 Then { n }
              tok_type := TOK_BOOLEAN_TYPE;
      If (ToLower(tok_str[0]) = 102) And (ToLower(tok_str[1]) = 111) Then { fo }
        If (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 119) Then { rw }
          If (ToLower(tok_str[4]) = 97) And (ToLower(tok_str[5]) = 114) Then { ar }
            If ToLower(tok_str[6]) = 100 Then { d }
              tok_type := TOK_FORWARD
    End;
    If tok_len = 4 Then
    Begin
      If (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 104) Then { ch }
        If (ToLower(tok_str[2]) = 97) And (ToLower(tok_str[3]) = 114) Then { ar }
          tok_type := TOK_CHAR_TYPE;
      If (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) Then { re }
        If (ToLower(tok_str[2]) = 97) And (ToLower(tok_str[3]) = 100) Then { ad }
          tok_type := TOK_READ;
      If (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) Then { re }
        If (ToLower(tok_str[2]) = 97) And (ToLower(tok_str[3]) = 108) Then { al }
          tok_type := TOK_REAL_TYPE;
      If (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 121) Then { ty }
        If (ToLower(tok_str[2]) = 112) And (ToLower(tok_str[3]) = 101) Then { pe }
          tok_type := TOK_TYPE_KW;
      If (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 97) Then { ca }
        If (ToLower(tok_str[2]) = 115) And (ToLower(tok_str[3]) = 101) Then { se }
          tok_type := TOK_CASE;
      If (ToLower(tok_str[0]) = 119) And (ToLower(tok_str[1]) = 105) Then { wi }
        If (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 104) Then { th }
          tok_type := TOK_WITH;
      If (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 101) Then { te }
        If (ToLower(tok_str[2]) = 120) And (ToLower(tok_str[3]) = 116) Then { xt }
          tok_type := TOK_TEXT;
      If (ToLower(tok_str[0]) = 102) And (ToLower(tok_str[1]) = 105) Then { fi }
        If (ToLower(tok_str[2]) = 108) And (ToLower(tok_str[3]) = 101) Then { le }
          tok_type := TOK_FILE;
      If (ToLower(tok_str[0]) = 117) And (ToLower(tok_str[1]) = 110) Then { un }
        If (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 116) Then { it }
          tok_type := TOK_UNIT;
      If (ToLower(tok_str[0]) = 117) And (ToLower(tok_str[1]) = 115) Then { us }
        If (ToLower(tok_str[2]) = 101) And (ToLower(tok_str[3]) = 115) Then { es }
          tok_type := TOK_USES
    End;
    If tok_len = 9 Then
    Begin
      If (ToLower(tok_str[0]) = 112) And (ToLower(tok_str[1]) = 114) Then { pr }
        If (ToLower(tok_str[2]) = 111) And (ToLower(tok_str[3]) = 99) Then { oc }
          If (ToLower(tok_str[4]) = 101) And (ToLower(tok_str[5]) = 100) Then { ed }
            If (ToLower(tok_str[6]) = 117) And (ToLower(tok_str[7]) = 114) Then { ur }
              If ToLower(tok_str[8]) = 101 Then { e }
                tok_type := TOK_PROCEDURE;
      { Interface = 105,110,116,101,114,102,97,99,101 }
      If (ToLower(tok_str[0]) = 105) And (ToLower(tok_str[1]) = 110) Then { In }
        If (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 101) Then { te }
          If (ToLower(tok_str[4]) = 114) And (ToLower(tok_str[5]) = 102) Then { rf }
            If (ToLower(tok_str[6]) = 97) And (ToLower(tok_str[7]) = 99) Then { ac }
              If ToLower(tok_str[8]) = 101 Then { e }
                tok_type := TOK_INTERFACE
    End;
    If tok_len = 8 Then
      If (ToLower(tok_str[0]) = 102) And (ToLower(tok_str[1]) = 117) Then { fu }
        If (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 99) Then { nc }
          If (ToLower(tok_str[4]) = 116) And (ToLower(tok_str[5]) = 105) Then { ti }
            If (ToLower(tok_str[6]) = 111) And (ToLower(tok_str[7]) = 110) Then { on }
              tok_type := TOK_FUNCTION;
    { Implementation = 105,109,112,108,101,109,101,110,116,97,116,105,111,110 }
    If tok_len = 14 Then
      If (ToLower(tok_str[0]) = 105) And (ToLower(tok_str[1]) = 109) Then { im }
        If (ToLower(tok_str[2]) = 112) And (ToLower(tok_str[3]) = 108) Then { pl }
          If (ToLower(tok_str[4]) = 101) And (ToLower(tok_str[5]) = 109) Then { em }
            If (ToLower(tok_str[6]) = 101) And (ToLower(tok_str[7]) = 110) Then { en }
              If (ToLower(tok_str[8]) = 116) And (ToLower(tok_str[9]) = 97) Then { ta }
                If (ToLower(tok_str[10]) = 116) And (ToLower(tok_str[11]) = 105) Then { ti }
                  If (ToLower(tok_str[12]) = 111) And (ToLower(tok_str[13]) = 110) Then { on }
                    tok_type := TOK_IMPLEMENTATION
  End
  Else If ch = 39 Then  { single quote - String }
  Begin
    tok_type := TOK_STRING;
    tok_len := 0;
    NextChar;
    While (ch <> 39) And (ch <> -1) Do
    Begin
      If tok_len < 255 Then
      Begin
        tok_str[tok_len] := ch;
        tok_len := tok_len + 1
      End;
      NextChar
    End;
    tok_str[tok_len] := 0;
    If ch = 39 Then
      NextChar
  End
  Else If ch = 43 Then  { + }
  Begin
    tok_type := TOK_PLUS;
    NextChar
  End
  Else If ch = 45 Then  { - }
  Begin
    tok_type := TOK_MINUS;
    NextChar
  End
  Else If ch = 42 Then  { * }
  Begin
    tok_type := TOK_STAR;
    NextChar
  End
  Else If ch = 47 Then  { / }
  Begin
    tok_type := TOK_SLASH;
    NextChar
  End
  Else If ch = 61 Then  { = }
  Begin
    tok_type := TOK_EQ;
    NextChar
  End
  Else If ch = 60 Then  { < }
  Begin
    NextChar;
    If ch = 62 Then  { <> }
    Begin
      tok_type := TOK_NEQ;
      NextChar
    End
    Else If ch = 61 Then  { <= }
    Begin
      tok_type := TOK_LE;
      NextChar
    End
    Else
      tok_type := TOK_LT
  End
  Else If ch = 62 Then  { > }
  Begin
    NextChar;
    If ch = 61 Then  { >= }
    Begin
      tok_type := TOK_GE;
      NextChar
    End
    Else
      tok_type := TOK_GT
  End
  Else If ch = 40 Then  { ( }
  Begin
    tok_type := TOK_LPAREN;
    NextChar
  End
  Else If ch = 41 Then  { ) }
  Begin
    tok_type := TOK_RPAREN;
    NextChar
  End
  Else If ch = 91 Then  { [ }
  Begin
    tok_type := TOK_LBRACKET;
    NextChar
  End
  Else If ch = 93 Then  { ] }
  Begin
    tok_type := TOK_RBRACKET;
    NextChar
  End
  Else If ch = 58 Then  { : }
  Begin
    NextChar;
    If ch = 61 Then  { := }
    Begin
      tok_type := TOK_ASSIGN;
      NextChar
    End
    Else
      tok_type := TOK_COLON
  End
  Else If ch = 59 Then  { ; }
  Begin
    tok_type := TOK_SEMICOLON;
    NextChar
  End
  Else If ch = 44 Then  { , }
  Begin
    tok_type := TOK_COMMA;
    NextChar
  End
  Else If ch = 46 Then  { . }
  Begin
    NextChar;
    If ch = 46 Then  { .. }
    Begin
      tok_type := TOK_DOTDOT;
      NextChar
    End
    Else
      tok_type := TOK_DOT
  End
  Else If ch = 94 Then  { ^ (caret) }
  Begin
    tok_type := TOK_CARET;
    NextChar
  End
  Else If ch = 64 Then  { @ }
  Begin
    tok_type := TOK_AT;
    NextChar
  End
  Else
  Begin
    Error(1);  { unexpected character }
    NextChar
  End
End;

{ ----- Symbol Table ----- }

Procedure CopyTokenToSym(idx: Integer);
Var
  i: Integer;
  base: Integer;
Begin
  { sym_name is flattened: base = idx * 32 }
  base := idx * 32;
  i := 0;
  While i < tok_len Do
  Begin
    sym_name[base + i] := tok_str[i];
    i := i + 1
  End;
  sym_name[base + tok_len] := 0
End;

Function SymLookup: Integer;
Var
  i: Integer;
  found: Integer;
Begin
  { Search backwards To find most recent definition }
  i := sym_count - 1;
  found := -1;
  While (i >= 0) And (found = -1) Do
  Begin
    If StrEqual(i) = 1 Then
      found := i;
    i := i - 1
  End;
  SymLookup := found
End;

Function SymAdd(kind, typ, level, offset: Integer): Integer;
Begin
  CopyTokenToSym(sym_count);
  sym_kind[sym_count] := kind;
  sym_type[sym_count] := typ;
  sym_level[sym_count] := level;
  sym_offset[sym_count] := offset;
  sym_label[sym_count] := 0;
  sym_const_val[sym_count] := 0;
  sym_is_var_param[sym_count] := 0;
  sym_var_param_flags[sym_count] := 0;
  sym_unit_idx[sym_count] := -1;  { -1 = local symbol, >= 0 = imported from Unit }
  sym_count := sym_count + 1;
  SymAdd := sym_count - 1
End;

Procedure PopScope(level: Integer);
Begin
  While (sym_count > 0) And (sym_level[sym_count - 1] >= level) Do
    sym_count := sym_count - 1
End;

{ Check If parameter position i is marked as Var In flags bitmap }
Function IsVarParam(flags, i: Integer): Integer;
Var
  bit_val, result: Integer;
Begin
  If i = 0 Then bit_val := 1
  Else If i = 1 Then bit_val := 2
  Else If i = 2 Then bit_val := 4
  Else If i = 3 Then bit_val := 8
  Else If i = 4 Then bit_val := 16
  Else If i = 5 Then bit_val := 32
  Else If i = 6 Then bit_val := 64
  Else bit_val := 128;
  result := (flags Div bit_val) Mod 2;
  IsVarParam := result
End;

{ Find a field In a Record Type, returns field index Or -1 }
Function FindField(type_idx: Integer): Integer;
Var
  i, j, base, match: Integer;
  first_fld: Integer;
Begin
  FindField := -1;
  first_fld := sym_const_val[type_idx];
  i := first_fld;
  While (i < field_count) And (field_rec_idx[i] = type_idx) Do
  Begin
    { Compare field name With current token }
    base := i * 32;
    match := 1;
    j := 0;
    While (j < tok_len) And (match = 1) Do
    Begin
      If ToLower(field_name[base + j]) <> ToLower(tok_str[j]) Then
        match := 0;
      j := j + 1
    End;
    If (match = 1) And (field_name[base + tok_len] = 0) Then
    Begin
      FindField := i;
      i := field_count  { Exit loop }
    End
    Else
      i := i + 1
  End
End;

{ ----- Output Helpers ----- }

Procedure EmitIndent;
Begin
  Write('    ')
End;

Procedure EmitNL;
Begin
  WriteLn
End;

Procedure EmitGlobl;
Begin
  WriteLn('.globl _main')
End;

Procedure EmitAlign4;
Begin
  WriteLn('.align 4')
End;

Procedure EmitMain;
Begin
  WriteLn('_main:')
End;

Procedure EmitLabel(n: Integer);
Begin
  Write('L'); Write(n); WriteLn(':')
End;

Function NewLabel: Integer;
Begin
  NewLabel := label_count;
  label_count := label_count + 1
End;

Procedure EmitStp;
Begin
  WriteLn('    stp x29, x30, [sp, #-16]!')
End;

Procedure EmitMovFP;
Begin
  WriteLn('    mov x29, sp')
End;

Procedure EmitLdp;
Begin
  WriteLn('    ldp x29, x30, [sp], #16')
End;

Procedure EmitRet;
Begin
  WriteLn('    ret')
End;

Procedure EmitStoreStaticLink;
Begin
  WriteLn('    stur x9, [x29, #-8]')
End;

Procedure EmitStaticLink(sym_level, cur_level: Integer);
Var
  i: Integer;
Begin
  WriteLn('    mov x9, x29');
  For i := cur_level DownTo sym_level + 1 Do
    WriteLn('    ldur x9, [x9, #-8]')
End;

Procedure EmitMovX0(val: Integer);
Var
  lo, hi: Integer;
  neg: Integer;
Begin
  neg := 0;
  If val < 0 Then
  Begin
    neg := 1;
    val := 0 - val
  End;
  If val > 65535 Then
  Begin
    lo := val Mod 65536;
    hi := val Div 65536;
    Write('    movz x0, #'); WriteLn(lo);
    Write('    movk x0, #'); Write(hi); WriteLn(', lsl #16')
  End
  Else
  Begin
    Write('    mov x0, #'); WriteLn(val)
  End;
  If neg = 1 Then
    WriteLn('    neg x0, x0')
End;

Procedure EmitMovX16(val: Integer);
Var
  lo, hi: Integer;
Begin
  If val > 65535 Then
  Begin
    lo := val Mod 65536;
    hi := val Div 65536;
    Write('    movz x16, #'); WriteLn(lo);
    Write('    movk x16, #'); Write(hi); WriteLn(', lsl #16')
  End
  Else
  Begin
    Write('    mov x16, #'); WriteLn(val)
  End
End;

Procedure EmitMovX8(val: Integer);
Var
  lo, hi: Integer;
  neg: Integer;
Begin
  neg := 0;
  If val < 0 Then
  Begin
    neg := 1;
    val := 0 - val
  End;
  If val > 65535 Then
  Begin
    lo := val Mod 65536;
    hi := val Div 65536;
    Write('    movz x8, #'); WriteLn(lo);
    Write('    movk x8, #'); Write(hi); WriteLn(', lsl #16')
  End
  Else
  Begin
    Write('    mov x8, #'); WriteLn(val)
  End;
  If neg = 1 Then
    WriteLn('    neg x8, x8')
End;

Procedure EmitSubLargeOffset(dest, src, offset: Integer);
Var
  lo, hi: Integer;
Begin
  If offset <= 4095 Then
  Begin
    Write('    sub x'); Write(dest); Write(', x'); Write(src); Write(', #'); WriteLn(offset)
  End
  Else
  Begin
    lo := offset Mod 65536;
    hi := offset Div 65536;
    Write('    movz x10, #'); WriteLn(lo);
    If hi > 0 Then
    Begin
      Write('    movk x10, #'); Write(hi); WriteLn(', lsl #16')
    End;
    Write('    sub x'); Write(dest); Write(', x'); Write(src); WriteLn(', x10')
  End
End;

Procedure EmitSvc;
Begin
  WriteLn('    svc #0x80')
End;

Procedure EmitPushX0;
Begin
  WriteLn('    str x0, [sp, #-16]!')
End;

Procedure EmitPopX0;
Begin
  WriteLn('    ldr x0, [sp], #16')
End;

Procedure EmitPopX1;
Begin
  WriteLn('    ldr x1, [sp], #16')
End;

Procedure EmitPushX1;
Begin
  WriteLn('    str x1, [sp, #-16]!')
End;

Procedure EmitAdd;
Begin
  WriteLn('    add x0, x1, x0')
End;

Procedure EmitSub;
Begin
  WriteLn('    sub x0, x1, x0')
End;

Procedure EmitMul;
Begin
  WriteLn('    mul x0, x1, x0')
End;

Procedure EmitSDiv;
Begin
  WriteLn('    sdiv x0, x1, x0')
End;

Procedure EmitMovX0X20;
Begin
  WriteLn('    mov x0, x20')
End;

Procedure EmitBranchLabel(lbl: Integer);
Begin
  Write('    b L'); WriteLn(lbl)
End;

Procedure EmitBranchLabelZ(lbl: Integer);
Begin
  Write('    cbz x0, L'); WriteLn(lbl)
End;

Procedure EmitBranchLabelNZ(lbl: Integer);
Begin
  Write('    cbnz x0, L'); WriteLn(lbl)
End;

Procedure EmitBL(lbl: Integer);
Begin
  Write('    bl L'); WriteLn(lbl)
End;

Procedure EmitCmpX0X1;
Begin
  WriteLn('    cmp x1, x0')
End;

Procedure EmitCset(cond: Integer);
Begin
  Write('    cset x0, ');
  If cond = 0 Then WriteLn('eq')
  Else If cond = 1 Then WriteLn('ne')
  Else If cond = 2 Then WriteLn('lt')
  Else If cond = 3 Then WriteLn('le')
  Else If cond = 4 Then WriteLn('gt')
  Else WriteLn('ge')
End;

Procedure EmitLdurX0(offset: Integer);
Begin
  If (offset >= -255) And (offset <= 255) Then
  Begin
    Write('    ldur x0, [x29, #'); Write(offset); WriteLn(']')
  End
  Else
  Begin
    EmitMovX8(offset);
    WriteLn('    add x8, x29, x8');
    WriteLn('    ldr x0, [x8]')
  End
End;

Procedure EmitLdurX0Outer(offset, sym_level, cur_level: Integer);
Var
  i: Integer;
Begin
  WriteLn('    mov x8, x29');
  For i := cur_level DownTo sym_level + 1 Do
    WriteLn('    ldur x8, [x8, #-8]');
  If (offset >= -255) And (offset <= 255) Then
  Begin
    Write('    ldur x0, [x8, #'); Write(offset); WriteLn(']')
  End
  Else
  Begin
    WriteLn('    mov x9, x8');
    EmitMovX8(offset);
    WriteLn('    add x8, x9, x8');
    WriteLn('    ldr x0, [x8]')
  End
End;

Procedure EmitFollowChain(sym_level, cur_level: Integer);
Var
  i: Integer;
Begin
  WriteLn('    mov x8, x29');
  For i := cur_level DownTo sym_level + 1 Do
    WriteLn('    ldur x8, [x8, #-8]')
End;

Procedure EmitVarAddr(var_idx, cur_scope: Integer);
Var
  offset, var_level, i: Integer;
Begin
  offset := sym_offset[var_idx];
  var_level := sym_level[var_idx];

  If var_level < cur_scope Then
  Begin
    WriteLn('    mov x8, x29');
    For i := cur_scope DownTo var_level + 1 Do
      WriteLn('    ldur x8, [x8, #-8]');
    If offset < 0 Then
      EmitSubLargeOffset(0, 8, 0 - offset)
    Else
    Begin
      If offset <= 4095 Then
      Begin
        Write('    add x0, x8, #'); WriteLn(offset)
      End
      Else
      Begin
        WriteLn('    mov x9, x8');
        EmitMovX8(offset);
        WriteLn('    add x0, x9, x8')
      End
    End
  End
  Else
  Begin
    If offset < 0 Then
      EmitSubLargeOffset(0, 29, 0 - offset)
    Else
    Begin
      If offset <= 4095 Then
      Begin
        Write('    add x0, x29, #'); WriteLn(offset)
      End
      Else
      Begin
        EmitMovX8(offset);
        WriteLn('    add x0, x29, x8')
      End
    End
  End
End;

Procedure EmitSturX0Outer(offset, sym_level, cur_level: Integer);
Var
  i: Integer;
Begin
  EmitPushX0;
  WriteLn('    mov x8, x29');
  For i := cur_level DownTo sym_level + 1 Do
    WriteLn('    ldur x8, [x8, #-8]');
  EmitPopX0;
  If (offset >= -255) And (offset <= 255) Then
  Begin
    Write('    stur x0, [x8, #'); Write(offset); WriteLn(']')
  End
  Else
  Begin
    WriteLn('    mov x9, x8');
    EmitPushX0;
    EmitMovX8(offset);
    WriteLn('    add x8, x9, x8');
    EmitPopX0;
    WriteLn('    str x0, [x8]')
  End
End;

Procedure EmitSturX0(offset: Integer);
Begin
  If (offset >= -255) And (offset <= 255) Then
  Begin
    Write('    stur x0, [x29, #'); Write(offset); WriteLn(']')
  End
  Else
  Begin
    EmitMovX8(offset);
    WriteLn('    add x8, x29, x8');
    WriteLn('    str x0, [x8]')
  End
End;

Procedure EmitSubSP(n: Integer);
Begin
  If n <= 4095 Then
  Begin
    Write('    sub sp, sp, #'); WriteLn(n)
  End
  Else
  Begin
    EmitMovX8(n);
    WriteLn('    sub sp, sp, x8')
  End
End;

Procedure EmitAddSP(n: Integer);
Begin
  If n <= 4095 Then
  Begin
    Write('    add sp, sp, #'); WriteLn(n)
  End
  Else
  Begin
    EmitMovX8(n);
    WriteLn('    add sp, sp, x8')
  End
End;

Procedure EmitNeg;
Begin
  WriteLn('    neg x0, x0')
End;

Procedure EmitMsub;
Begin
  WriteLn('    msub x0, x0, x2, x1')
End;

Procedure EmitMovX2X0;
Begin
  WriteLn('    mov x2, x0')
End;

Procedure EmitAndX0X1;
Begin
  WriteLn('    And x0, x1, x0')
End;

Procedure EmitOrrX0X1;
Begin
  WriteLn('    orr x0, x1, x0')
End;

Procedure EmitAndImm(val: Integer);
Begin
  Write('    And x0, x0, #'); WriteLn(val)
End;

Procedure EmitEorX0(val: Integer);
Begin
  Write('    eor x0, x0, #'); WriteLn(val)
End;

{ ----- Floating Point Emitters ----- }

Procedure EmitPushD0;
Begin
  WriteLn('    str d0, [sp, #-16]!')
End;

Procedure EmitPopD0;
Begin
  WriteLn('    ldr d0, [sp], #16')
End;

Procedure EmitPopD1;
Begin
  WriteLn('    ldr d1, [sp], #16')
End;

Procedure EmitFAdd;
Begin
  WriteLn('    fadd d0, d1, d0')
End;

Procedure EmitFSub;
Begin
  WriteLn('    fsub d0, d1, d0')
End;

Procedure EmitFMul;
Begin
  WriteLn('    fmul d0, d1, d0')
End;

Procedure EmitFDiv;
Begin
  WriteLn('    fdiv d0, d1, d0')
End;

Procedure EmitFNeg;
Begin
  WriteLn('    fneg d0, d0')
End;

Procedure EmitFCmp;
Begin
  WriteLn('    fcmp d1, d0')
End;

Procedure EmitScvtfD0X0;
Begin
  WriteLn('    scvtf d0, x0')
End;

Procedure EmitScvtfD1X1;
Begin
  WriteLn('    scvtf d1, x1')
End;

Procedure EmitFcvtzsX0D0;
Begin
  WriteLn('    fcvtzs x0, d0')
End;

Procedure EmitFmovD0X0;
Begin
  WriteLn('    fmov d0, x0')
End;

Procedure EmitFmovX0D0;
Begin
  WriteLn('    fmov x0, d0')
End;

Procedure EmitLdurD0(offset: Integer);
Begin
  Write('    ldur d0, [x29, #'); Write(offset); WriteLn(']')
End;

Procedure EmitSturD0(offset: Integer);
Begin
  Write('    stur d0, [x29, #'); Write(offset); WriteLn(']')
End;

Procedure EmitLdurD0Outer(offset, sym_level, cur_level: Integer);
Var
  i: Integer;
Begin
  WriteLn('    mov x8, x29');
  For i := cur_level DownTo sym_level + 1 Do
    WriteLn('    ldur x8, [x8, #-8]');
  Write('    ldur d0, [x8, #'); Write(offset); WriteLn(']')
End;

Procedure EmitSturD0Outer(offset, sym_level, cur_level: Integer);
Var
  i: Integer;
Begin
  EmitPushD0;
  WriteLn('    mov x8, x29');
  For i := cur_level DownTo sym_level + 1 Do
    WriteLn('    ldur x8, [x8, #-8]');
  EmitPopD0;
  Write('    stur d0, [x8, #'); Write(offset); WriteLn(']')
End;

{ ----- Unit Symbol Emitters ----- }

Procedure WriteSymName(sym_idx: Integer);
Var
  base, i, c: Integer;
Begin
  base := sym_idx * 32;
  i := 0;
  c := sym_name[base];
  While c <> 0 Do
  Begin
    WriteChar(c);
    i := i + 1;
    c := sym_name[base + i]
  End
End;

Procedure WriteCurrentUnitName;
Var
  i: Integer;
Begin
  For i := 0 To current_unit_len - 1 Do
    WriteChar(current_unit_name[i])
End;

Procedure WriteLoadedUnitName(unit_idx: Integer);
Var
  base, i, c: Integer;
Begin
  base := unit_idx * 32;
  i := 0;
  c := loaded_units[base];
  While c <> 0 Do
  Begin
    WriteChar(c);
    i := i + 1;
    c := loaded_units[base + i]
  End
End;

Procedure EmitGloblCurrentUnit(sym_idx: Integer);
Begin
  Write('.globl _');
  WriteCurrentUnitName;
  Write('_');
  WriteSymName(sym_idx);
  WriteLn
End;

Procedure EmitUnitLabel(sym_idx: Integer);
Begin
  Write('_');
  WriteCurrentUnitName;
  Write('_');
  WriteSymName(sym_idx);
  WriteLn(':')
End;

Procedure EmitBLUnitProc(unit_idx, sym_idx: Integer);
Begin
  Write('    bl _');
  WriteLoadedUnitName(unit_idx);
  Write('_');
  WriteSymName(sym_idx);
  WriteLn
End;

Procedure EmitGloblUnitInit;
Begin
  Write('.globl _');
  WriteCurrentUnitName;
  WriteLn('_init')
End;

Procedure EmitUnitInitLabel;
Begin
  Write('_');
  WriteCurrentUnitName;
  WriteLn('_init:')
End;

Procedure EmitBLUnitInit(unit_idx: Integer);
Begin
  Write('    bl _');
  WriteLoadedUnitName(unit_idx);
  WriteLn('_init')
End;

{ ----- Print Runtime ----- }

Procedure EmitPrintIntRuntime;
Var
  loop_lbl, done_lbl, neg_lbl, print_lbl: Integer;
Begin
  { Runtime routine To print Integer In x0 }
  EmitLabel(rt_print_int);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { Save value }
  EmitSturX0(-24);

  { Handle negative }
  neg_lbl := NewLabel;
  done_lbl := NewLabel;
  WriteLn('    cmp x0, #0');

  Write('    b.ge L'); WriteLn(neg_lbl);

  { Print minus sign }
  EmitMovX0(1);
  EmitSturX0(-32);
  EmitMovX0(45);  { '-' }
  EmitSturX0(-8);
  EmitMovX16(33554436); { 0x2000004 }
  EmitMovX0X20;
  WriteLn('    sub x1, x29, #8');
  WriteLn('    mov x2, #1');
  EmitSvc;

  { Negate }
  EmitLdurX0(-24);
  EmitNeg;
  EmitSturX0(-24);

  EmitLabel(neg_lbl);

  { Convert To String (digits In reverse) }
  EmitMovX0(0);
  EmitSturX0(-40);  { digit count }

  loop_lbl := NewLabel;
  print_lbl := NewLabel;

  EmitLabel(loop_lbl);
  EmitLdurX0(-24);
  EmitBranchLabelZ(print_lbl);

  { val % 10 }
  EmitLdurX0(-24);
  EmitPushX0;
  EmitMovX0(10);
  EmitPopX1;
  EmitSDiv;
  EmitMovX2X0;
  EmitLdurX0(-24);
  EmitPushX0;
  EmitMovX0(10);
  EmitPopX1;
  EmitMsub;

  { Store digit }
  WriteLn('    add x0, x0, #48');

  WriteLn('    ldur x1, [x29, #-40]');

  WriteLn('    sub x2, x29, #48');

  WriteLn('    strb w0, [x2, x1]');

  { digit count++ }
  WriteLn('    add x1, x1, #1');

  WriteLn('    stur x1, [x29, #-40]');

  { val /= 10 }
  EmitLdurX0(-24);
  EmitPushX0;
  EmitMovX0(10);
  EmitPopX1;
  EmitSDiv;
  EmitSturX0(-24);

  EmitBranchLabel(loop_lbl);

  EmitLabel(print_lbl);

  { Handle zero }
  EmitLdurX0(-40);
  EmitBranchLabelNZ(done_lbl);
  EmitMovX0(48);  { '0' }
  EmitSturX0(-48);
  EmitMovX0(1);
  EmitSturX0(-40);

  EmitLabel(done_lbl);

  { Print digits In reverse order }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop_lbl);
  EmitLdurX0(-40);
  EmitBranchLabelZ(done_lbl);

  { digit count-- }
  WriteLn('    sub x0, x0, #1');
  EmitSturX0(-40);

  { Load digit }
  WriteLn('    sub x1, x29, #48');

  WriteLn('    ldrb w0, [x1, x0]');

  { Print Char }
  EmitSturX0(-8);
  EmitMovX16(33554436);
  EmitMovX0X20;
  WriteLn('    sub x1, x29, #8');
  WriteLn('    mov x2, #1');
  EmitSvc;

  EmitBranchLabel(loop_lbl);

  { Exit label }
  EmitLabel(done_lbl);

  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitNewlineRuntime;
Begin
  { Newline routine - print Chr(10) }
  EmitLabel(rt_newline);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  EmitMovX0(10);
  EmitSturX0(-9);
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;
  WriteLn('    sub x1, x29, #9');
  WriteLn('    mov x2, #1');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitReadcharRuntime;
Begin
  { ReadChar routine - Read one Char, return In x0 (-1 For EOF) }
  { Uses x19 as input file descriptor (0=stdin, Or opened file) }
  EmitLabel(rt_readchar);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read }
  EmitSvc;
  { Check If Read returned >= 1 }
  WriteLn('    cmp x0, #1');
  Write('    b.ge L'); WriteLn(label_count);
  EmitMovX0(-1);  { EOF }
  EmitBranchLabel(label_count + 1);
  EmitLabel(label_count);
  label_count := label_count + 1;
  WriteLn('    ldrb w0, [sp]');
  EmitLabel(label_count);
  label_count := label_count + 1;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitPrintCharRuntime;
Begin
  { Print Char routine - print Char In x0 }
  EmitLabel(rt_print_char);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  WriteLn('    strb w0, [sp]');
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitWriteCharFdRuntime;
Begin
  { Write Char To fd routine - x0=fd, x1=Char }
  EmitLabel(rt_write_char_fd);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store Char on stack }
  WriteLn('    strb w1, [sp]');
  { x0 already has fd, Set up rest Of syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitPrintStringRuntime;
Var
  loop_lbl, done_lbl: Integer;
Begin
  { Print String routine - x0 = address Of pascal String (Length byte + chars) }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(rt_print_string);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);
  { Save base address To [x29, #-8] }
  WriteLn('    stur x0, [x29, #-8]');
  { Load Length from [x0] into x1 And save To [x29, #-16] }
  WriteLn('    ldrb w1, [x0]');
  WriteLn('    stur x1, [x29, #-16]');
  { Initialize index To 0 at [x29, #-24] }
  WriteLn('    mov x2, #0');
  WriteLn('    stur x2, [x29, #-24]');
  { Loop label }
  EmitLabel(loop_lbl);
  { Load index And Length, compare }
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    cmp x2, x1');
  { b.ge done_lbl }
  Write('    b.ge L'); WriteLn(done_lbl);
  { Load Char at [base + index + 1] }
  WriteLn('    ldur x0, [x29, #-8]');
  WriteLn('    add x0, x0, x2');
  WriteLn('    add x0, x0, #1');
  WriteLn('    ldrb w0, [x0]');
  { Call print_char }
  EmitBL(rt_print_char);
  { Increment index }
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    add x2, x2, #1');
  WriteLn('    stur x2, [x29, #-24]');
  { Branch back To loop }
  EmitBranchLabel(loop_lbl);
  { Done label }
  EmitLabel(done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitReadIntRuntime;
Var
  skip_ws_lbl, read_digit_lbl, done_lbl, neg_lbl, not_neg_lbl, skip_neg_lbl: Integer;
Begin
  { Read Integer routine - reads from x19 (input fd), returns In x0 }
  { Skips whitespace, handles optional minus sign, reads digits }
  EmitLabel(rt_read_int);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  { x21 = accumulated value, x22 = negative flag }
  WriteLn('    mov x21, #0');
  WriteLn('    mov x22, #0');

  { Skip whitespace loop }
  skip_ws_lbl := NewLabel;
  EmitLabel(skip_ws_lbl);
  { Read one Char }
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read }
  EmitSvc;
  { Check If Read failed }
  WriteLn('    cmp x0, #1');
  done_lbl := NewLabel;
  Write('    b.lt L'); WriteLn(done_lbl);
  { Load Char into x23 }
  WriteLn('    ldrb w23, [sp]');
  { Check If space (32), tab (9), newline (10), Or carriage return (13) }
  WriteLn('    cmp x23, #32');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);
  WriteLn('    cmp x23, #9');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);
  WriteLn('    cmp x23, #10');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);
  WriteLn('    cmp x23, #13');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);

  { Check For minus sign (45) }
  neg_lbl := NewLabel;
  not_neg_lbl := NewLabel;
  WriteLn('    cmp x23, #45');
  Write('    b.ne L'); WriteLn(not_neg_lbl);
  { Set negative flag }
  WriteLn('    mov x22, #1');
  EmitBranchLabel(neg_lbl);
  EmitLabel(not_neg_lbl);
  { Not a minus, so it should be a digit - process it }
  WriteLn('    sub x23, x23, #48');
  { Check If valid digit (0-9) }
  WriteLn('    cmp x23, #9');
  Write('    b.hi L'); WriteLn(done_lbl);
  { Add To accumulated value: x21 = x21 * 10 + x23 }
  WriteLn('    mov x24, #10');
  WriteLn('    mul x21, x21, x24');
  WriteLn('    add x21, x21, x23');

  { Read digit loop }
  EmitLabel(neg_lbl);
  read_digit_lbl := NewLabel;
  EmitLabel(read_digit_lbl);
  { Read one Char }
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read }
  EmitSvc;
  { Check If Read failed }
  WriteLn('    cmp x0, #1');
  Write('    b.lt L'); WriteLn(done_lbl);
  { Load Char into x23 }
  WriteLn('    ldrb w23, [sp]');
  { Save original Char To x18 For pushback }
  WriteLn('    mov x18, x23');
  { Convert To digit }
  WriteLn('    sub x23, x23, #48');
  { Check If valid digit (0-9) }
  WriteLn('    cmp x23, #9');
  Write('    b.hi L'); WriteLn(done_lbl);
  { Add To accumulated value: x21 = x21 * 10 + x23 }
  WriteLn('    mov x24, #10');
  WriteLn('    mul x21, x21, x24');
  WriteLn('    add x21, x21, x23');
  EmitBranchLabel(read_digit_lbl);

  { Done - apply negative If needed }
  EmitLabel(done_lbl);
  skip_neg_lbl := NewLabel;
  Write('    cbz x22, L'); WriteLn(skip_neg_lbl);
  WriteLn('    neg x21, x21');
  EmitLabel(skip_neg_lbl);
  { Move result To x0 }
  WriteLn('    mov x0, x21');
  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitSkipLineRuntime;
Var
  loop_lbl, done_lbl, check_pb_lbl: Integer;
Begin
  { Skip To End Of line routine - reads chars Until newline Or EOF }
  { Uses x18 as pushback character from read_int (-1 means none) }
  EmitLabel(rt_skip_line);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);

  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  check_pb_lbl := NewLabel;

  { First check If pushback character is available }
  WriteLn('    cmp x18, #0');
  Write('    b.lt L'); WriteLn(loop_lbl);
  { Check If pushback is newline }
  WriteLn('    cmp x18, #10');
  { Clear pushback }
  WriteLn('    mov x18, #-1');
  Write('    b.eq L'); WriteLn(done_lbl);

  EmitLabel(loop_lbl);
  { Read one Char }
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read }
  EmitSvc;
  { Check If Read failed }
  WriteLn('    cmp x0, #1');
  Write('    b.lt L'); WriteLn(done_lbl);
  { Load Char }
  WriteLn('    ldrb w0, [sp]');
  { Check If newline (10) }
  WriteLn('    cmp x0, #10');
  Write('    b.ne L'); WriteLn(loop_lbl);

  EmitLabel(done_lbl);
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitPrintRealRuntime;
Var
  neg_lbl, skip_neg_lbl, print_frac_lbl, frac_loop_lbl: Integer;
Begin
  { Print Real In d0 - format: Integer.fraction (6 decimal places) }
  EmitLabel(rt_print_real);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);

  { Save original value To [x29, #-16] as double }
  WriteLn('    stur d0, [x29, #-16]');

  { Check For negative }
  neg_lbl := NewLabel;
  skip_neg_lbl := NewLabel;
  { fcmp d0, #0.0 }
  WriteLn('    fcmp d0, #0.0');
  { b.ge skip_neg }
  Write('    b.ge L'); WriteLn(neg_lbl);

  { Print '-' And negate }
  EmitMovX0(45);  { '-' }
  EmitBL(rt_print_char);
  { fneg d0, d0 }
  WriteLn('    ldur d0, [x29, #-16]');
  EmitFNeg;
  WriteLn('    stur d0, [x29, #-16]');

  EmitLabel(neg_lbl);

  { Load value And get Integer part }
  WriteLn('    ldur d0, [x29, #-16]');

  { fcvtzs x0, d0 - truncate To Integer }
  EmitFcvtzsX0D0;

  { Save Integer part To [x29, #-24] }
  WriteLn('    stur x0, [x29, #-24]');

  { Print Integer part }
  EmitBL(rt_print_int);

  { Print '.' }
  EmitMovX0(46);  { '.' }
  EmitBL(rt_print_char);

  { Calculate fractional part: (original - int_part) * 1000000 }
  WriteLn('    ldur d0, [x29, #-16]');

  { Load Integer part And convert To float }
  WriteLn('    ldur x0, [x29, #-24]');

  { scvtf d1, x0 }
  WriteLn('    scvtf d1, x0');

  { fsub d0, d0, d1 - fractional part (d0 = original - int_part) }
  { EmitFSub does d0=d1-d0, so emit inline For d0=d0-d1 }
  WriteLn('    fsub d0, d0, d1');

  { Multiply by 1000000 }
  EmitMovX0(1000000);
  EmitScvtfD0X0;  { d0 = 1000000.0 }
  EmitPushD0;
  WriteLn('    ldur d0, [x29, #-16]');
  WriteLn('    ldur x0, [x29, #-24]');
  WriteLn('    scvtf d1, x0');
  { fsub d0, d0, d1 - d0 = frac part (original - int_part) }
  { EmitFSub does d0=d1-d0, so emit inline For d0=d0-d1 }
  WriteLn('    fsub d0, d0, d1');
  EmitPopD1;  { d1 = 1000000.0 }
  EmitFMul;  { d0 = frac * 1000000 }

  { Convert To Integer }
  EmitFcvtzsX0D0;

  { Save fractional digits To [x29, #-32] }
  WriteLn('    stur x0, [x29, #-32]');

  { Print fractional part With leading zeros (6 digits) }
  { Count digits needed }
  frac_loop_lbl := NewLabel;
  print_frac_lbl := NewLabel;

  { Print leading zeros: If frac < 100000, print '0', etc }
  WriteLn('    ldur x0, [x29, #-32]');

  { x1 = 100000 - use movz since 100000 > 65535 }
  { movz x1, #34464; movk x1, #1, lsl #16 }
  WriteLn('    movz x1, #34464');
  WriteLn('    movk x1, #1, lsl #16');

  EmitLabel(frac_loop_lbl);
  { cmp x1, #10 }
  WriteLn('    cmp x1, #10');
  { b.lt print_frac }
  Write('    b.lt L'); WriteLn(print_frac_lbl);
  { cmp x0, x1 }
  WriteLn('    cmp x0, x1');
  { b.ge print_frac }
  Write('    b.ge L'); WriteLn(print_frac_lbl);
  { Print '0' }
  EmitPushX0;
  EmitPushX1;
  EmitMovX0(48);
  EmitBL(rt_print_char);
  EmitPopX1;
  EmitPopX0;
  { x1 = x1 / 10 }
  WriteLn('    mov x2, #10');
  WriteLn('    udiv x1, x1, x2');
  EmitBranchLabel(frac_loop_lbl);

  EmitLabel(print_frac_lbl);
  { Load And print the fractional value }
  WriteLn('    ldur x0, [x29, #-32]');
  { Only print If non-zero }
  EmitBranchLabelZ(label_count);
  EmitBL(rt_print_int);
  EmitLabel(label_count);
  label_count := label_count + 1;

  EmitAddSP(64);
  EmitLdp;
  EmitRet
End;

Procedure EmitReadRealRuntime;
Var
  skip_ws_lbl, read_int_lbl, read_frac_lbl, done_lbl, neg_lbl, not_neg_lbl, skip_neg_lbl: Integer;
Begin
  { Read Real from input, return In d0 }
  EmitLabel(rt_read_real);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);

  { x21 = Integer part, x22 = fractional part (scaled), x23 = neg flag, x24 = frac scale }
  WriteLn('    mov x21, #0');
  WriteLn('    mov x22, #0');
  WriteLn('    mov x23, #0');
  WriteLn('    mov x24, #1');

  { Skip whitespace }
  skip_ws_lbl := NewLabel;
  EmitLabel(skip_ws_lbl);
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read }
  EmitSvc;
  done_lbl := NewLabel;
  WriteLn('    cmp x0, #1');
  Write('    b.lt L'); WriteLn(done_lbl);
  { Load Char }
  WriteLn('    ldrb w25, [sp]');
  { Check whitespace }
  WriteLn('    cmp x25, #32');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);
  WriteLn('    cmp x25, #9');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);
  WriteLn('    cmp x25, #10');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);
  WriteLn('    cmp x25, #13');
  Write('    b.eq L'); WriteLn(skip_ws_lbl);

  { Check For minus }
  neg_lbl := NewLabel;
  not_neg_lbl := NewLabel;
  WriteLn('    cmp x25, #45');
  Write('    b.ne L'); WriteLn(not_neg_lbl);
  WriteLn('    mov x23, #1');
  EmitBranchLabel(neg_lbl);
  EmitLabel(not_neg_lbl);

  { First Char is a digit - process it }
  WriteLn('    sub x25, x25, #48');
  WriteLn('    cmp x25, #9');
  Write('    b.hi L'); WriteLn(done_lbl);
  { x21 = x21 * 10 + x25 }
  WriteLn('    mov x26, #10');
  WriteLn('    mul x21, x21, x26');
  WriteLn('    add x21, x21, x25');

  { Read Integer part loop }
  EmitLabel(neg_lbl);
  read_int_lbl := NewLabel;
  read_frac_lbl := NewLabel;
  EmitLabel(read_int_lbl);
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read }
  EmitSvc;
  WriteLn('    cmp x0, #1');
  Write('    b.lt L'); WriteLn(done_lbl);
  WriteLn('    ldrb w25, [sp]');

  { Check For '.' }
  WriteLn('    cmp x25, #46');
  Write('    b.eq L'); WriteLn(read_frac_lbl);

  { Check If digit }
  WriteLn('    sub x25, x25, #48');
  WriteLn('    cmp x25, #9');
  Write('    b.hi L'); WriteLn(done_lbl);
  { x21 = x21 * 10 + x25 }
  WriteLn('    mov x26, #10');
  WriteLn('    mul x21, x21, x26');
  WriteLn('    add x21, x21, x25');
  EmitBranchLabel(read_int_lbl);

  { Read fractional part }
  EmitLabel(read_frac_lbl);
  skip_neg_lbl := NewLabel;
  EmitLabel(skip_neg_lbl);
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read }
  EmitSvc;
  WriteLn('    cmp x0, #1');
  Write('    b.lt L'); WriteLn(done_lbl);
  WriteLn('    ldrb w25, [sp]');

  { Check If digit }
  WriteLn('    sub x25, x25, #48');
  WriteLn('    cmp x25, #9');
  Write('    b.hi L'); WriteLn(done_lbl);
  { x22 = x22 * 10 + x25, x24 = x24 * 10 }
  WriteLn('    mov x26, #10');
  WriteLn('    mul x22, x22, x26');
  WriteLn('    add x22, x22, x25');
  WriteLn('    mul x24, x24, x26');
  EmitBranchLabel(skip_neg_lbl);

  { Done - combine Integer And fractional parts }
  EmitLabel(done_lbl);
  { d0 = x21 (Integer part) }
  WriteLn('    scvtf d0, x21');
  { d1 = x22 (fractional part) }
  WriteLn('    scvtf d1, x22');
  { d2 = x24 (scale) }
  WriteLn('    scvtf d2, x24');
  { d1 = d1 / d2 }
  WriteLn('    fdiv d1, d1, d2');
  { d0 = d0 + d1 }
  EmitFAdd;

  { Apply negative If needed }
  skip_neg_lbl := NewLabel;
  Write('    cbz x23, L'); WriteLn(skip_neg_lbl);
  EmitFNeg;
  EmitLabel(skip_neg_lbl);

  EmitAddSP(64);
  EmitLdp;
  EmitRet
End;

Procedure EmitReadStringRuntime;
Var
  loop_lbl, done_lbl, store_len_lbl: Integer;
Begin
  { Read String from input (x19), String buffer address passed In x0 }
  { String format: byte 0 = Length, bytes 1-255 = characters }
  { Reads Until newline Or max 255 chars }
  EmitLabel(rt_read_string);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save String buffer address In x21 }
  WriteLn('    mov x21, x0');

  { x22 = character count (starts at 0) }
  WriteLn('    mov x22, #0');

  { Read loop }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop_lbl);

  { Check If count >= 255 }
  WriteLn('    cmp x22, #255');
  Write('    b.ge L'); WriteLn(done_lbl);

  { Read one character: Read(x19, sp, 1) }
  WriteLn('    mov x0, x19');
  WriteLn('    mov x1, sp');
  WriteLn('    mov x2, #1');
  EmitMovX16(33554435);  { 0x2000003 = Read syscall }
  EmitSvc;

  { Check If Read failed Or EOF (x0 < 1) }
  WriteLn('    cmp x0, #1');
  Write('    b.lt L'); WriteLn(done_lbl);

  { Load character into x23 }
  WriteLn('    ldrb w23, [sp]');

  { Check If newline (10) Or carriage return (13) }
  WriteLn('    cmp x23, #10');
  Write('    b.eq L'); WriteLn(done_lbl);
  WriteLn('    cmp x23, #13');
  Write('    b.eq L'); WriteLn(done_lbl);

  { Store character at buffer[count+1] }
  { x24 = x21 + x22 + 1 }
  WriteLn('    add x24, x21, x22');
  WriteLn('    add x24, x24, #1');
  WriteLn('    strb w23, [x24]');

  { Increment count }
  WriteLn('    add x22, x22, #1');

  { Loop back }
  Write('    b L'); WriteLn(loop_lbl);

  { Done - store Length at buffer[0] }
  EmitLabel(done_lbl);
  WriteLn('    strb w22, [x21]');

  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitFileOpenInit;
Var
  skip_input_lbl, skip_output_lbl: Integer;
Begin
  { Initialize x19 (input fd) And x20 (output fd) from command line }
  { On entry: x0 = argc, x1 = argv }
  { Usage: tpcv2 input.pas output.s }
  skip_input_lbl := NewLabel;
  skip_output_lbl := NewLabel;

  { Save argc And argv To callee-saved registers }
  WriteLn('    mov x21, x0');
  WriteLn('    mov x22, x1');

  { Default: x19 = 0 (stdin), x20 = 1 (stdout), x18 = -1 (no pushback) }
  WriteLn('    mov x19, #0');
  WriteLn('    mov x20, #1');
  WriteLn('    mov x18, #-1');

  { If argc < 2, skip input file open }
  WriteLn('    cmp x21, #2');
  Write('    b.lt L'); WriteLn(skip_input_lbl);

  { Load argv[1] into x0 (input filename) }
  WriteLn('    ldr x0, [x22, #8]');

  { Open input file: open(filename, O_RDONLY, 0) }
  WriteLn('    mov x1, #0');
  WriteLn('    mov x2, #0');
  EmitMovX16(33554437);  { 0x2000005 = open }
  EmitSvc;

  { Move input fd To x19 }
  WriteLn('    mov x19, x0');

  { If argc < 4, skip output file open (need: prog input.pas -o output.s) }
  WriteLn('    cmp x21, #4');
  Write('    b.lt L'); WriteLn(skip_output_lbl);

  { Check If argv[2] == "-o": load argv[2], check first two bytes }
  WriteLn('    ldr x0, [x22, #16]');
  { Load first byte, check For '-' (45) }
  WriteLn('    ldrb w1, [x0]');
  WriteLn('    cmp w1, #45');
  Write('    b.ne L'); WriteLn(skip_output_lbl);
  { Load second byte, check For 'o' (111) }
  WriteLn('    ldrb w1, [x0, #1]');
  WriteLn('    cmp w1, #111');
  Write('    b.ne L'); WriteLn(skip_output_lbl);

  { Load argv[3] into x0 (output filename) }
  WriteLn('    ldr x0, [x22, #24]');

  { Open output file: open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0644) }
  { O_WRONLY=1, O_CREAT=0x200, O_TRUNC=0x400 => 0x601 = 1537 }
  WriteLn('    mov x1, #1537');
  { mode 0644 = 420 decimal }
  WriteLn('    mov x2, #420');
  EmitMovX16(33554437);  { 0x2000005 = open }
  EmitSvc;

  { Move output fd To x20 }
  WriteLn('    mov x20, x0');

  EmitLabel(skip_output_lbl);
  EmitLabel(skip_input_lbl)
End;

Procedure EmitHeapInitRuntime;
Begin
  { Initialize heap using mmap syscall }
  { Allocates 1MB Of memory For heap, stores base In x21 }
  { Initializes free list head In x22 pointing To entire block }
  EmitLabel(rt_heap_init);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);

  { mov x0, #0  - addr = NULL (let kernel choose) }
  WriteLn('    mov x0, #0');

  { mov x1, #1048576  - Length = 1MB (0x100000) }
  { Need movz + movk since 1048576 > 65535 }
  WriteLn('    movz x1, #0');
  WriteLn('    movk x1, #16, lsl #16');

  { mov x2, #3  - PROT_READ | PROT_WRITE }
  WriteLn('    mov x2, #3');

  { mov x3, #4098  - MAP_PRIVATE | MAP_ANON (0x1002) }
  WriteLn('    mov x3, #4098');

  { mov x4, #-1  - fd = -1 }
  WriteLn('    movn x4, #0');

  { mov x5, #0  - offset = 0 }
  WriteLn('    mov x5, #0');

  { mmap syscall: 0x20000C5 }
  WriteLn('    movz x16, #0xC5');
  WriteLn('    movk x16, #0x200, lsl #16');

  EmitSvc;

  { mov x21, x0  - store heap base In x21 }
  WriteLn('    mov x21, x0');

  { Initialize free list: x22 = x21 (free list head points To heap base) }
  WriteLn('    mov x22, x21');

  { Store block size (1MB) at [x21]: first free block header }
  { movz x1, #0; movk x1, #16, lsl #16 = 1048576 }
  WriteLn('    movz x1, #0');
  WriteLn('    movk x1, #16, lsl #16');
  { str x1, [x21] - store size }
  WriteLn('    str x1, [x21]');

  { Store next=0 at [x21, #8]: no next free block }
  WriteLn('    str xzr, [x21, #8]');

  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitAllocRuntime;
Var
  loop_lbl, found_lbl, split_lbl, no_split_lbl, update_head_lbl, done_lbl, oom_lbl: Integer;
Begin
  { Allocate memory from free list With block splitting }
  { Input: x0 = requested size }
  { Output: x0 = pointer To user data, Or 0 If OOM }
  loop_lbl := NewLabel;
  found_lbl := NewLabel;
  split_lbl := NewLabel;
  no_split_lbl := NewLabel;
  update_head_lbl := NewLabel;
  done_lbl := NewLabel;
  oom_lbl := NewLabel;

  EmitLabel(rt_alloc);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);

  { Add 16 For header And align To 16 bytes: x0 = (x0 + 31) & ~15 }
  WriteLn('    add x0, x0, #31');
  { And x0, x0, #-16 }
  WriteLn('    And x0, x0, #-16');
  { Save required size To x3 }
  WriteLn('    mov x3, x0');

  { x1 = prev (0 initially), x2 = curr (x22 = free list head) }
  WriteLn('    mov x1, #0');
  WriteLn('    mov x2, x22');

  { Loop: walk free list looking For big enough block }
  EmitLabel(loop_lbl);
  { cbz x2, oom - End Of list }
  Write('    cbz x2, L'); WriteLn(oom_lbl);
  { ldr x4, [x2] - x4 = block size }
  WriteLn('    ldr x4, [x2]');
  { cmp x4, x3 - compare block size To required }
  WriteLn('    cmp x4, x3');
  { b.ge found }
  Write('    b.ge L'); WriteLn(found_lbl);
  { Not big enough - move To next }
  { mov x1, x2 - prev = curr }
  WriteLn('    mov x1, x2');
  { ldr x2, [x2, #8] - curr = curr->next }
  WriteLn('    ldr x2, [x2, #8]');
  EmitBranchLabel(loop_lbl);

  { Found a big enough block - check If we can split it }
  EmitLabel(found_lbl);
  { x2 = block addr, x3 = required size, x4 = block size }
  { ldr x5, [x2, #8] - x5 = found->next }
  WriteLn('    ldr x5, [x2, #8]');
  { Check If block can be split: x4 - x3 >= 32 }
  { sub x6, x4, x3 - x6 = remainder size }
  WriteLn('    sub x6, x4, x3');
  { cmp x6, #32 }
  WriteLn('    cmp x6, #32');
  { b.lt no_split - If remainder < 32, don't split }
  Write('    b.lt L'); WriteLn(no_split_lbl);

  { Split the block }
  EmitLabel(split_lbl);
  { x6 = remainder size, x7 = remainder block address = x2 + x3 }
  { add x7, x2, x3 }
  WriteLn('    add x7, x2, x3');
  { str x6, [x7] - remainder->size = x6 }
  WriteLn('    str x6, [x7]');
  { str x5, [x7, #8] - remainder->next = found->next }
  WriteLn('    str x5, [x7, #8]');
  { str x3, [x2] - found->size = required size }
  WriteLn('    str x3, [x2]');
  { mov x5, x7 - use remainder as New "next" For unlinking }
  WriteLn('    mov x5, x7');

  { Unlink found block from free list (And link remainder In its place) }
  EmitLabel(no_split_lbl);
  { cbz x1, update_head - If prev==0, update head }
  Write('    cbz x1, L'); WriteLn(update_head_lbl);
  { str x5, [x1, #8] - prev->next = x5 (remainder Or found->next) }
  WriteLn('    str x5, [x1, #8]');
  EmitBranchLabel(done_lbl);

  EmitLabel(update_head_lbl);
  { mov x22, x5 - free list head = x5 (remainder Or found->next) }
  WriteLn('    mov x22, x5');

  EmitLabel(done_lbl);
  { Mark as allocated: str xzr, [x2, #8] - next = 0 }
  WriteLn('    str xzr, [x2, #8]');
  { Return user pointer: add x0, x2, #16 }
  WriteLn('    add x0, x2, #16');
  EmitAddSP(16);
  EmitLdp;
  EmitRet;

  { Out Of memory }
  EmitLabel(oom_lbl);
  EmitMovX0(0);
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitFreeRuntime;
Begin
  { Free memory back To free list }
  { Input: x0 = pointer To user data }
  EmitLabel(rt_free);
  { Get block header: sub x0, x0, #16 }
  WriteLn('    sub x0, x0, #16');
  { Link into free list: str x22, [x0, #8] - block->next = free_head }
  WriteLn('    str x22, [x0, #8]');
  { Update free list head: mov x22, x0 }
  WriteLn('    mov x22, x0');
  EmitRet
End;

Procedure EmitStrCopyRuntime;
Var
  loop_lbl, done_lbl: Integer;
Begin
  { Copy String from x1 (source) To x0 (dest) }
  { Pascal strings: byte 0 = Length, bytes 1..Length = chars }
  EmitLabel(rt_str_copy);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save dest And source addresses }
  { stur x0, [x29, #-8] - dest }
  WriteLn('    stur x0, [x29, #-8]');
  { stur x1, [x29, #-16] - source }
  WriteLn('    stur x1, [x29, #-16]');

  { Load Length from source [x1] into x2 }
  WriteLn('    ldrb w2, [x1]');
  { Store Length To dest [x0] }
  WriteLn('    strb w2, [x0]');
  { Save Length To [x29, #-24] }
  WriteLn('    stur x2, [x29, #-24]');

  { Initialize index To 0 }
  EmitMovX0(0);
  EmitSturX0(-32);

  { Loop: copy bytes 1..Length }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop_lbl);

  { Load index }
  EmitLdurX0(-32);
  { Load Length }
  WriteLn('    ldur x2, [x29, #-24]');
  { cmp x0, x2 - If index >= Length, done }
  WriteLn('    cmp x0, x2');
  { b.ge done }
  Write('    b.ge L'); WriteLn(done_lbl);

  { x3 = index + 1 (offset into String) }
  WriteLn('    add x3, x0, #1');

  { Load source Char: ldrb w4, [x1, x3] where x1 = source }
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w4, [x1, x3]');

  { Store To dest Char: strb w4, [x5, x3] where x5 = dest }
  WriteLn('    ldur x5, [x29, #-8]');
  WriteLn('    strb w4, [x5, x3]');

  { Increment index }
  EmitLdurX0(-32);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-32);
  EmitBranchLabel(loop_lbl);

  EmitLabel(done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitStrCompareRuntime;
Var
  loop_lbl, not_equal_lbl, done_lbl: Integer;
Begin
  { Compare strings at x0 And x1, return 1 If equal, 0 If Not equal In x0 }
  EmitLabel(rt_str_compare);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save addresses }
  EmitSturX0(-8);  { String 1 }
  { stur x1, [x29, #-16] }
  WriteLn('    stur x1, [x29, #-16]');

  { Load lengths }
  WriteLn('    ldrb w2, [x0]');
  WriteLn('    ldrb w3, [x1]');

  { Compare lengths first }
  not_equal_lbl := NewLabel;
  done_lbl := NewLabel;
  WriteLn('    cmp x2, x3');
  { b.ne not_equal }
  Write('    b.ne L'); WriteLn(not_equal_lbl);

  { Save Length To [x29, #-24] }
  WriteLn('    stur x2, [x29, #-24]');

  { Initialize index To 0 }
  EmitMovX0(0);
  EmitSturX0(-32);

  { Loop: compare each byte }
  loop_lbl := NewLabel;
  EmitLabel(loop_lbl);

  { Load index }
  EmitLdurX0(-32);
  { Load Length }
  WriteLn('    ldur x2, [x29, #-24]');
  { cmp x0, x2 - If index >= Length, all equal }
  WriteLn('    cmp x0, x2');
  { b.ge equal (return 1) }
  Write('    b.ge L'); WriteLn(done_lbl);

  { x3 = index + 1 }
  WriteLn('    add x3, x0, #1');

  { Load chars from both strings }
  EmitLdurX0(-8);  { String 1 addr }
  WriteLn('    ldrb w4, [x0, x3]');

  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w5, [x1, x3]');

  { Compare chars }
  WriteLn('    cmp x4, x5');
  { b.ne not_equal }
  Write('    b.ne L'); WriteLn(not_equal_lbl);

  { Increment index }
  WriteLn('    ldur x0, [x29, #-32]');
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-32);
  EmitBranchLabel(loop_lbl);

  { Equal - return 1 }
  EmitLabel(done_lbl);
  EmitMovX0(1);
  EmitBranchLabel(label_count);

  { Not equal - return 0 }
  EmitLabel(not_equal_lbl);
  EmitMovX0(0);

  EmitLabel(label_count);
  label_count := label_count + 1;
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitStrConcatRuntime;
Var
  loop1_lbl, loop2_lbl, done_lbl: Integer;
Begin
  { Concatenate strings: x0 = dest, x1 = string1, x2 = string2 }
  { Result Length = len1 + len2 (capped at 255) }
  EmitLabel(rt_str_concat);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  { Save addresses }
  EmitSturX0(-8);   { dest }
  { stur x1, [x29, #-16] - String 1 }
  WriteLn('    stur x1, [x29, #-16]');
  { stur x2, [x29, #-24] - String 2 }
  WriteLn('    stur x2, [x29, #-24]');

  { Load lengths }
  WriteLn('    ldrb w3, [x1]');
  WriteLn('    ldrb w4, [x2]');

  { Calculate total Length (capped at 255) }
  WriteLn('    add x5, x3, x4');
  { cmp x5, #255 }
  WriteLn('    cmp x5, #255');
  { csel x5, x5, x6, le - If x5 <= 255, keep it; Else use 255 }
  WriteLn('    mov x6, #255');
  WriteLn('    csel x5, x5, x6, le');

  { Store total Length To dest }
  EmitLdurX0(-8);  { dest }
  WriteLn('    strb w5, [x0]');

  { Save len1 To [x29, #-32] }
  WriteLn('    stur x3, [x29, #-32]');

  { Initialize index To 0 }
  EmitMovX0(0);
  EmitSturX0(-40);

  { Loop 1: copy string1 chars }
  loop1_lbl := NewLabel;
  loop2_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(loop1_lbl);

  { Load index And len1 }
  EmitLdurX0(-40);
  WriteLn('    ldur x3, [x29, #-32]');
  { cmp x0, x3 }
  WriteLn('    cmp x0, x3');
  { b.ge loop2 }
  Write('    b.ge L'); WriteLn(loop2_lbl);

  { x7 = index + 1 }
  WriteLn('    add x7, x0, #1');

  { Load source1 Char }
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w8, [x1, x7]');

  { Store To dest }
  EmitLdurX0(-8);
  WriteLn('    strb w8, [x0, x7]');

  { Increment index }
  EmitLdurX0(-40);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-40);
  EmitBranchLabel(loop1_lbl);

  { Loop 2: copy string2 chars }
  EmitLabel(loop2_lbl);
  { Reset index To 0 For string2 }
  EmitMovX0(0);
  EmitSturX0(-40);

  { Load len2 into x4 }
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    ldrb w4, [x2]');
  { Save len2 To [x29, #-48] }
  WriteLn('    stur x4, [x29, #-48]');

  { Loop 2 body label }
  EmitLabel(label_count);
  label_count := label_count + 1;

  { Load index And len2 }
  EmitLdurX0(-40);
  WriteLn('    ldur x4, [x29, #-48]');
  { cmp x0, x4 }
  WriteLn('    cmp x0, x4');
  { b.ge done }
  Write('    b.ge L'); WriteLn(done_lbl);

  { x7 = index + 1 (source offset) }
  WriteLn('    add x7, x0, #1');

  { Load source2 Char }
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    ldrb w8, [x2, x7]');

  { Calculate dest offset: len1 + index + 1 }
  EmitLdurX0(-40);  { index }
  WriteLn('    ldur x3, [x29, #-32]');
  WriteLn('    add x7, x0, x3');
  WriteLn('    add x7, x7, #1');

  { Store To dest }
  EmitLdurX0(-8);
  WriteLn('    strb w8, [x0, x7]');

  { Increment index }
  EmitLdurX0(-40);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-40);
  EmitBranchLabel(label_count - 1);

  EmitLabel(done_lbl);
  { Return dest address In x0 }
  EmitLdurX0(-8);
  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitStrCmpRuntime;
{ Lexicographic String comparison - returns -1 If x0<x1, 0 If x0=x1, 1 If x0>x1 }
{ Input: x0 = string1 addr, x1 = string2 addr }
{ Output: x0 = -1/0/1 }
Var
  loop_lbl, done_lbl, less_lbl, greater_lbl, check_len_lbl: Integer;
Begin
  EmitLabel(rt_str_cmp);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);
  { stur x0, [x29, #-8]  - string1 }
  EmitSturX0(-8);
  { stur x1, [x29, #-16] - string2 }
  WriteLn('    stur x1, [x29, #-16]');

  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  less_lbl := NewLabel;
  greater_lbl := NewLabel;
  check_len_lbl := NewLabel;

  { index = 0 }
  EmitMovX0(0);
  EmitSturX0(-24);

  EmitLabel(loop_lbl);

  { Load lengths }
  EmitLdurX0(-8);    { x0 = &s1 }
  WriteLn('    ldrb w2, [x0]');

  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w3, [x1]');

  { Load index }
  EmitLdurX0(-24);   { x0 = index }

  { If index >= min(len1, len2), check Length }
  WriteLn('    cmp x0, x2');
  Write('    b.ge L'); WriteLn(check_len_lbl);
  WriteLn('    cmp x0, x3');
  Write('    b.ge L'); WriteLn(check_len_lbl);

  { Compare chars at index+1 }
  { x4 = index + 1 }
  WriteLn('    add x4, x0, #1');

  { Load Char from s1 }
  EmitLdurX0(-8);
  WriteLn('    ldrb w5, [x0, x4]');

  { Load Char from s2 }
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w6, [x1, x4]');

  { Compare chars }
  WriteLn('    cmp x5, x6');
  Write('    b.lt L'); WriteLn(less_lbl);
  Write('    b.gt L'); WriteLn(greater_lbl);

  { Chars equal, increment index }
  EmitLdurX0(-24);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-24);
  EmitBranchLabel(loop_lbl);

  { Check lengths when all compared chars are equal }
  EmitLabel(check_len_lbl);
  EmitLdurX0(-8);
  WriteLn('    ldrb w2, [x0]');
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w3, [x1]');
  WriteLn('    cmp x2, x3');
  Write('    b.lt L'); WriteLn(less_lbl);
  Write('    b.gt L'); WriteLn(greater_lbl);
  { Equal }
  EmitMovX0(0);
  EmitBranchLabel(done_lbl);

  EmitLabel(less_lbl);
  EmitMovX0(0);
  WriteLn('    sub x0, x0, #1');
  EmitBranchLabel(done_lbl);

  EmitLabel(greater_lbl);
  EmitMovX0(1);

  EmitLabel(done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitStrPosRuntime;
{ Find substring position - returns position (1-based) Or 0 If Not found }
{ Input: x0 = substring addr, x1 = String addr }
{ Output: x0 = position (1-based) Or 0 }
Var
  outer_lbl, inner_lbl, done_lbl, found_lbl, not_found_lbl, next_pos_lbl: Integer;
Begin
  EmitLabel(rt_str_pos);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { [x29-8] = substr, [x29-16] = String, [x29-24] = outer idx, [x29-32] = inner idx }
  EmitSturX0(-8);
  WriteLn('    stur x1, [x29, #-16]');

  outer_lbl := NewLabel;
  inner_lbl := NewLabel;
  done_lbl := NewLabel;
  found_lbl := NewLabel;
  not_found_lbl := NewLabel;
  next_pos_lbl := NewLabel;

  { If substr is empty, return 1 }
  EmitLdurX0(-8);
  WriteLn('    ldrb w2, [x0]');
  Write('    cbz x2, L'); WriteLn(found_lbl);
  { x2 = substr len }
  WriteLn('    stur x2, [x29, #-40]');

  { Load String Length }
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w3, [x1]');
  { x3 = String len }

  { outer_idx = 0 (will be 1-based position - 1) }
  EmitMovX0(0);
  EmitSturX0(-24);

  EmitLabel(outer_lbl);
  { Check If outer_idx + substr_len > string_len }
  EmitLdurX0(-24);  { outer_idx }
  WriteLn('    ldur x2, [x29, #-40]');
  WriteLn('    add x4, x0, x2');
  { x4 = outer_idx + substr_len }
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w3, [x1]');
  WriteLn('    cmp x4, x3');
  Write('    b.gt L'); WriteLn(not_found_lbl);

  { inner_idx = 0 }
  EmitMovX0(0);
  EmitSturX0(-32);

  EmitLabel(inner_lbl);
  { If inner_idx >= substr_len, found! }
  EmitLdurX0(-32);
  WriteLn('    ldur x2, [x29, #-40]');
  WriteLn('    cmp x0, x2');
  Write('    b.ge L'); WriteLn(found_lbl);

  { Compare substr[inner_idx+1] With String[outer_idx+inner_idx+1] }
  EmitLdurX0(-8);  { substr addr }
  WriteLn('    ldur x4, [x29, #-32]');
  WriteLn('    add x4, x4, #1');
  WriteLn('    ldrb w5, [x0, x4]');
  { x5 = substr[inner_idx+1] }

  WriteLn('    ldur x1, [x29, #-16]');
  EmitLdurX0(-24);  { outer_idx }
  WriteLn('    ldur x4, [x29, #-32]');
  WriteLn('    add x4, x0, x4');
  WriteLn('    add x4, x4, #1');
  WriteLn('    ldrb w6, [x1, x4]');
  { x6 = String[outer_idx+inner_idx+1] }

  WriteLn('    cmp x5, x6');
  Write('    b.ne L'); WriteLn(next_pos_lbl);

  { Chars match, increment inner_idx }
  EmitLdurX0(-32);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-32);
  EmitBranchLabel(inner_lbl);

  EmitLabel(next_pos_lbl);
  { Chars don't match, try next outer position }
  EmitLdurX0(-24);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-24);
  EmitBranchLabel(outer_lbl);

  EmitLabel(found_lbl);
  { Return outer_idx + 1 (1-based position) }
  EmitLdurX0(-24);
  WriteLn('    add x0, x0, #1');
  EmitBranchLabel(done_lbl);

  EmitLabel(not_found_lbl);
  EmitMovX0(0);

  EmitLabel(done_lbl);
  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitStrDeleteRuntime;
{ Delete chars from String In place }
{ Input: x0 = String addr, x1 = start (1-based), x2 = count }
Var
  loop_lbl, done_lbl: Integer;
Begin
  EmitLabel(rt_str_delete);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { [x29-8]=String, [x29-16]=start, [x29-24]=count, [x29-32]=len, [x29-40]=idx }
  EmitSturX0(-8);
  WriteLn('    stur x1, [x29, #-16]');
  WriteLn('    stur x2, [x29, #-24]');

  loop_lbl := NewLabel;
  done_lbl := NewLabel;

  { Load String Length }
  WriteLn('    ldrb w3, [x0]');
  WriteLn('    stur x3, [x29, #-32]');
  { x3 = len }

  { idx = start }
  WriteLn('    ldur x0, [x29, #-16]');
  EmitSturX0(-40);

  EmitLabel(loop_lbl);
  { If idx + count > len, done }
  EmitLdurX0(-40);  { idx }
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    add x4, x0, x2');
  WriteLn('    ldur x3, [x29, #-32]');
  WriteLn('    cmp x4, x3');
  Write('    b.gt L'); WriteLn(done_lbl);

  { Copy Char from idx+count To idx }
  EmitLdurX0(-8);  { String addr }
  EmitLdurX0(-40);  { idx }
  { RELOAD String addr since we overwrote x0 }
  WriteLn('    ldur x1, [x29, #-8]');
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    add x3, x0, x2');
  { x3 = idx + count (source position) }
  { Load Char from String[idx+count] }
  WriteLn('    ldrb w4, [x1, x3]');
  { Store To String[idx] }
  WriteLn('    strb w4, [x1, x0]');

  { idx++ }
  EmitLdurX0(-40);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-40);
  EmitBranchLabel(loop_lbl);

  EmitLabel(done_lbl);
  { Update String Length: new_len = old_len - count }
  WriteLn('    ldur x3, [x29, #-32]');
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    sub x0, x3, x2');
  EmitLdurX0(-8);
  { RELOAD x0 For store since we overwrote it }
  WriteLn('    ldur x3, [x29, #-32]');
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    sub x4, x3, x2');
  WriteLn('    ldur x1, [x29, #-8]');
  WriteLn('    strb w4, [x1]');

  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitStrInsertRuntime;
{ Insert String into another at position }
{ Input: x0 = source String, x1 = dest String, x2 = position (1-based) }
Var
  loop1_lbl, loop2_lbl, copy_lbl, done_lbl: Integer;
Begin
  EmitLabel(rt_str_insert);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);
  { [x29-8]=source, [x29-16]=dest, [x29-24]=pos, [x29-32]=src_len, [x29-40]=dst_len, [x29-48]=idx }
  EmitSturX0(-8);
  WriteLn('    stur x1, [x29, #-16]');
  WriteLn('    stur x2, [x29, #-24]');

  loop1_lbl := NewLabel;
  loop2_lbl := NewLabel;
  copy_lbl := NewLabel;
  done_lbl := NewLabel;

  { Load lengths }
  WriteLn('    ldrb w3, [x0]');
  WriteLn('    stur x3, [x29, #-32]');
  WriteLn('    ldrb w4, [x1]');
  WriteLn('    stur x4, [x29, #-40]');

  { Move existing chars from pos To End, shifting right by src_len }
  { idx = dst_len }
  WriteLn('    stur x4, [x29, #-48]');

  EmitLabel(loop1_lbl);
  { If idx < pos, done moving }
  EmitLdurX0(-48);  { idx }
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    cmp x0, x2');
  Write('    b.lt L'); WriteLn(loop2_lbl);

  { Copy dest[idx] To dest[idx+src_len] }
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldrb w5, [x1, x0]');
  WriteLn('    ldur x3, [x29, #-32]');
  WriteLn('    add x6, x0, x3');
  WriteLn('    strb w5, [x1, x6]');

  { idx-- }
  EmitLdurX0(-48);
  WriteLn('    sub x0, x0, #1');
  EmitSturX0(-48);
  EmitBranchLabel(loop1_lbl);

  EmitLabel(loop2_lbl);
  { Now copy source chars To position pos...pos+src_len-1 }
  { idx = 0 }
  EmitMovX0(0);
  EmitSturX0(-48);

  EmitLabel(copy_lbl);
  { If idx >= src_len, done }
  EmitLdurX0(-48);
  WriteLn('    ldur x3, [x29, #-32]');
  WriteLn('    cmp x0, x3');
  Write('    b.ge L'); WriteLn(done_lbl);

  { Copy source[idx+1] To dest[pos+idx] }
  WriteLn('    ldur x5, [x29, #-8]');
  WriteLn('    add x6, x0, #1');
  WriteLn('    ldrb w7, [x5, x6]');
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    ldur x2, [x29, #-24]');
  WriteLn('    add x6, x2, x0');
  WriteLn('    strb w7, [x1, x6]');

  { idx++ }
  EmitLdurX0(-48);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-48);
  EmitBranchLabel(copy_lbl);

  EmitLabel(done_lbl);
  { Update dest Length: new_len = dst_len + src_len }
  WriteLn('    ldur x3, [x29, #-32]');
  WriteLn('    ldur x4, [x29, #-40]');
  WriteLn('    add x0, x3, x4');
  WriteLn('    ldur x1, [x29, #-16]');
  WriteLn('    strb w0, [x1]');

  EmitAddSP(64);
  EmitLdp;
  EmitRet
End;

{ EmitIntToStrRuntime - Convert Integer To String }
{ x0 = Integer value, x1 = destination String address }
Procedure EmitIntToStrRuntime;
Var
  done_lbl, neg_lbl, pos_lbl, loop_lbl, rev_lbl, rev_done_lbl: Integer;
Begin
  EmitLabel(rt_int_to_str);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  done_lbl := NewLabel;
  neg_lbl := NewLabel;
  pos_lbl := NewLabel;
  loop_lbl := NewLabel;
  rev_lbl := NewLabel;
  rev_done_lbl := NewLabel;

  { Save dest String address }
  WriteLn('    stur x1, [x29, #-16]');

  { x2 = digit count, x3 = is_negative }
  WriteLn('    mov x2, #0');
  WriteLn('    mov x3, #0');

  { Check If value is negative }
  WriteLn('    cmp x0, #0');
  Write('    b.lt L'); WriteLn(neg_lbl);
  Write('    b L'); WriteLn(pos_lbl);

  { Handle negative }
  EmitLabel(neg_lbl);
  WriteLn('    neg x0, x0');
  WriteLn('    mov x3, #1');

  { Loop To extract digits (stored In reverse on stack) }
  EmitLabel(pos_lbl);
  EmitLabel(loop_lbl);
  { x4 = x0 / 10, x5 = x0 Mod 10 }
  WriteLn('    mov x6, #10');
  WriteLn('    udiv x4, x0, x6');
  WriteLn('    msub x5, x4, x6, x0');

  { Convert digit To ASCII And store on stack }
  WriteLn('    add x5, x5, #48');

  { Store digit at sp + x2 }
  WriteLn('    strb w5, [sp, x2]');

  { Increment digit count }
  WriteLn('    add x2, x2, #1');

  { x0 = x4 (quotient), Continue If x0 > 0 }
  WriteLn('    mov x0, x4');
  WriteLn('    cmp x0, #0');
  Write('    b.ne L'); WriteLn(loop_lbl);

  { Now reverse digits into destination String }
  { x1 = dest String, x4 = Write position (starts at 1 If no sign, 2 If negative) }
  WriteLn('    ldur x1, [x29, #-16]');

  { If negative, store '-' at position 1, start digits at 2 }
  WriteLn('    cmp x3, #0');
  Write('    b.eq L'); WriteLn(rev_lbl);

  { Store '-' sign }
  WriteLn('    mov w5, #45');
  WriteLn('    strb w5, [x1, #1]');

  { x4 = Write position (1 For positive, 2 For negative start) }
  EmitLabel(rev_lbl);
  WriteLn('    add x4, x3, #1');

  { x5 = Read position (digit count - 1, reading backwards) }
  WriteLn('    sub x5, x2, #1');

  { Reverse copy loop }
  EmitLabel(rev_done_lbl);
  WriteLn('    cmp x5, #0');
  Write('    b.lt L'); WriteLn(done_lbl);

  { Load digit from stack at position x5 }
  WriteLn('    ldrb w6, [sp, x5]');

  { Store at dest position x4 }
  WriteLn('    strb w6, [x1, x4]');

  WriteLn('    add x4, x4, #1');
  WriteLn('    sub x5, x5, #1');
  Write('    b L'); WriteLn(rev_done_lbl);

  { Store Length (x2 + x3 = digit count + sign) }
  EmitLabel(done_lbl);
  WriteLn('    add x0, x2, x3');
  WriteLn('    strb w0, [x1]');

  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

{ EmitStrToIntRuntime - Convert String To Integer }
{ x0 = source String address }
{ Returns: x0 = Integer value, x1 = error code (0 = success, position Of error otherwise) }
Procedure EmitStrToIntRuntime;
Var
  done_lbl, error_lbl, loop_lbl, neg_lbl, pos_lbl, skip_sign_lbl, exit_lbl: Integer;
Begin
  EmitLabel(rt_str_to_int);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  done_lbl := NewLabel;
  error_lbl := NewLabel;
  loop_lbl := NewLabel;
  neg_lbl := NewLabel;
  pos_lbl := NewLabel;
  skip_sign_lbl := NewLabel;
  exit_lbl := NewLabel;

  { x1 = Length, x2 = index (starts at 1), x3 = result, x4 = is_negative }
  WriteLn('    ldrb w1, [x0]');
  WriteLn('    mov x2, #1');
  WriteLn('    mov x3, #0');
  WriteLn('    mov x4, #0');

  { Check If empty String }
  WriteLn('    cmp x1, #0');
  Write('    b.eq L'); WriteLn(error_lbl);

  { Check first Char For sign }
  WriteLn('    ldrb w5, [x0, #1]');

  { Check For '-' (45) }
  WriteLn('    cmp x5, #45');
  Write('    b.eq L'); WriteLn(neg_lbl);

  { Check For '+' (43) }
  WriteLn('    cmp x5, #43');
  Write('    b.eq L'); WriteLn(pos_lbl);
  Write('    b L'); WriteLn(loop_lbl);

  EmitLabel(neg_lbl);
  WriteLn('    mov x4, #1');
  EmitLabel(pos_lbl);
  WriteLn('    add x2, x2, #1');

  { Main loop }
  EmitLabel(loop_lbl);
  WriteLn('    cmp x2, x1');
  Write('    b.gt L'); WriteLn(done_lbl);

  { Load Char at position x2 }
  WriteLn('    ldrb w5, [x0, x2]');

  { Check If digit (48-57) }
  WriteLn('    cmp x5, #48');
  Write('    b.lt L'); WriteLn(error_lbl);
  WriteLn('    cmp x5, #57');
  Write('    b.gt L'); WriteLn(error_lbl);

  { result = result * 10 + digit }
  WriteLn('    mov x6, #10');
  WriteLn('    mul x3, x3, x6');
  WriteLn('    sub x5, x5, #48');
  WriteLn('    add x3, x3, x5');

  { x2 := x2 + 1 }
  WriteLn('    add x2, x2, #1');
  Write('    b L'); WriteLn(loop_lbl);

  { Success }
  EmitLabel(done_lbl);
  { Apply sign If negative }
  WriteLn('    cmp x4, #0');
  Write('    b.eq L'); WriteLn(skip_sign_lbl);
  WriteLn('    neg x3, x3');

  EmitLabel(skip_sign_lbl);
  WriteLn('    mov x0, x3');
  WriteLn('    mov x1, #0');
  Write('    b L'); WriteLn(exit_lbl);

  { Error - return position In x1 }
  EmitLabel(error_lbl);
  WriteLn('    mov x0, #0');
  WriteLn('    mov x1, x2');

  EmitLabel(exit_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

{ EmitStrLtrimRuntime - Remove leading whitespace from String }
{ Input: x0 = source String addr }
{ Output: x0 = New trimmed String addr (allocated from heap) }
Procedure EmitStrLtrimRuntime;
Var
  loop_lbl, done_lbl, copy_lbl, copy_done_lbl: Integer;
Begin
  EmitLabel(rt_str_ltrim);
  EmitStp;
  EmitSubSP(32);

  { x1 = source addr, x2 = source Length, x3 = skip count }
  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  copy_lbl := NewLabel;
  copy_done_lbl := NewLabel;

  { Save source addr }
  WriteLn('    mov x1, x0');

  { x2 = source Length }
  WriteLn('    ldrb w2, [x1]');

  { x3 = 0 (skip count) }
  WriteLn('    mov x3, #0');

  { Loop: skip leading whitespace }
  EmitLabel(loop_lbl);
  { If x3 >= x2, done }
  WriteLn('    cmp x3, x2');
  Write('    b.ge L'); WriteLn(done_lbl);

  { x4 = Char at [x1 + x3 + 1] }
  WriteLn('    add x4, x3, #1');
  WriteLn('    ldrb w4, [x1, x4]');

  { If Char = 32 (space), skip }
  WriteLn('    cmp x4, #32');
  Write('    b.eq L'); WriteLn(label_count);

  { If Char = 9 (tab), skip }
  WriteLn('    cmp x4, #9');
  Write('    b.ne L'); WriteLn(done_lbl);

  EmitLabel(label_count);
  label_count := label_count + 1;

  { x3 := x3 + 1 }
  WriteLn('    add x3, x3, #1');
  Write('    b L'); WriteLn(loop_lbl);

  { Done scanning: x3 = number To skip, x2 = Length }
  EmitLabel(done_lbl);

  { Allocate New String from heap: x0 = x21 }
  WriteLn('    mov x0, x21');
  WriteLn('    add x21, x21, #256');

  { x5 = New Length = x2 - x3 }
  WriteLn('    sub x5, x2, x3');

  { Store New Length }
  WriteLn('    strb w5, [x0]');

  { x6 = copy index (0 To x5-1) }
  WriteLn('    mov x6, #0');

  { Copy loop }
  EmitLabel(copy_lbl);
  WriteLn('    cmp x6, x5');
  Write('    b.ge L'); WriteLn(copy_done_lbl);

  { x7 = x3 + x6 + 1 (source index) }
  WriteLn('    add x7, x3, x6');
  WriteLn('    add x7, x7, #1');

  { Load Char }
  WriteLn('    ldrb w8, [x1, x7]');

  { x7 = x6 + 1 (dest index) }
  WriteLn('    add x7, x6, #1');

  { Store Char }
  WriteLn('    strb w8, [x0, x7]');

  { x6 := x6 + 1 }
  WriteLn('    add x6, x6, #1');
  Write('    b L'); WriteLn(copy_lbl);

  EmitLabel(copy_done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

{ EmitStrRtrimRuntime - Remove trailing whitespace from String }
{ Input: x0 = source String addr }
{ Output: x0 = New trimmed String addr (allocated from heap) }
Procedure EmitStrRtrimRuntime;
Var
  loop_lbl, done_lbl, copy_lbl, copy_done_lbl: Integer;
Begin
  EmitLabel(rt_str_rtrim);
  EmitStp;
  EmitSubSP(32);

  loop_lbl := NewLabel;
  done_lbl := NewLabel;
  copy_lbl := NewLabel;
  copy_done_lbl := NewLabel;

  { x1 = source addr }
  WriteLn('    mov x1, x0');

  { x2 = source Length }
  WriteLn('    ldrb w2, [x1]');

  { x3 = x2 (scan from End) }
  WriteLn('    mov x3, x2');

  { Loop: find last non-whitespace }
  EmitLabel(loop_lbl);
  { If x3 <= 0, done }
  WriteLn('    cmp x3, #0');
  Write('    b.le L'); WriteLn(done_lbl);

  { x4 = Char at [x1 + x3] }
  WriteLn('    ldrb w4, [x1, x3]');

  { If Char = 32 (space), Continue }
  WriteLn('    cmp x4, #32');
  Write('    b.eq L'); WriteLn(label_count);

  { If Char = 9 (tab), Continue }
  WriteLn('    cmp x4, #9');
  Write('    b.ne L'); WriteLn(done_lbl);

  EmitLabel(label_count);
  label_count := label_count + 1;

  { x3 := x3 - 1 }
  WriteLn('    sub x3, x3, #1');
  Write('    b L'); WriteLn(loop_lbl);

  { Done: x3 = New Length }
  EmitLabel(done_lbl);

  { Allocate New String from heap }
  WriteLn('    mov x0, x21');
  WriteLn('    add x21, x21, #256');

  { Store New Length }
  WriteLn('    strb w3, [x0]');

  { x5 = copy index (0 To x3-1) }
  WriteLn('    mov x5, #0');

  { Copy loop }
  EmitLabel(copy_lbl);
  WriteLn('    cmp x5, x3');
  Write('    b.ge L'); WriteLn(copy_done_lbl);

  { x6 = x5 + 1 (index) }
  WriteLn('    add x6, x5, #1');

  { Load Char from source }
  WriteLn('    ldrb w7, [x1, x6]');

  { Store Char To dest }
  WriteLn('    strb w7, [x0, x6]');

  { x5 := x5 + 1 }
  WriteLn('    add x5, x5, #1');
  Write('    b L'); WriteLn(copy_lbl);

  EmitLabel(copy_done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

{ EmitStrTrimRuntime - Remove both leading And trailing whitespace }
{ Input: x0 = source String addr }
{ Output: x0 = New trimmed String addr }
Procedure EmitStrTrimRuntime;
Begin
  EmitLabel(rt_str_trim);
  EmitStp;
  EmitSubSP(16);

  { Call ltrim first }
  EmitBL(rt_str_ltrim);

  { Then call rtrim on result }
  EmitBL(rt_str_rtrim);

  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

{ ----- Screen/Terminal Control Routines ----- }

Procedure EmitStrbAtOffset(offset: Integer);
{ Emit: sturb w0, [x29, #offset] - stores low byte Of w0 at x29+offset }
Begin
  Write('    sturb w0, [x29, #'); Write(offset); WriteLn(']');
End;

Procedure EmitClrScrRuntime;
{ Emits code To clear screen And home cursor: ESC[2J ESC[H }
Begin
  EmitLabel(rt_clrscr);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store escape sequence on stack: ESC[2J ESC[H = 27,91,50,74,27,91,72 }
  { Use sturb To store individual bytes }
  EmitMovX0(27);       { ESC }
  EmitStrbAtOffset(-15);
  EmitMovX0(91);       { [ }
  EmitStrbAtOffset(-14);
  EmitMovX0(50);       { 2 }
  EmitStrbAtOffset(-13);
  EmitMovX0(74);       { J }
  EmitStrbAtOffset(-12);
  EmitMovX0(27);       { ESC }
  EmitStrbAtOffset(-11);
  EmitMovX0(91);       { [ }
  EmitStrbAtOffset(-10);
  EmitMovX0(72);       { H }
  EmitStrbAtOffset(-9);
  { Write syscall: x0=fd, x1=buf, x2=count }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #15 }
  WriteLn('    sub x1, x29, #15');
  { mov x2, #7 }
  WriteLn('    mov x2, #7');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitGotoXYRuntime;
{ Emits code To move cursor: ESC[y;xH }
{ x1=x (column), x0=y (row) }
Var
  loop1, done1, loop2, done2, end_lbl: Integer;
Begin
  EmitLabel(rt_gotoxy);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);
  { Save x And y To registers first To avoid memory corruption }
  { x11 = y (row), x12 = x (column) - using higher regs To avoid conflicts With division }
  WriteLn('    mov x11, x0');
  WriteLn('    mov x12, x1');
  { Build escape sequence at stack offset -20 onwards (leave room For digits) }
  { Format: ESC [ y ; x H }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-20);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-19);
  { x8 = pointer To next byte (start at -18) }
  WriteLn('    sub x8, x29, #18');
  { Convert y To decimal digits (y is In x11) }
  { mov x0, x11 }
  WriteLn('    mov x0, x11');
  { If y >= 10, output tens digit }
  loop1 := NewLabel;
  done1 := NewLabel;
  WriteLn('    cmp x0, #10');
  Write('    b.lt L'); WriteLn(done1);
  { Divide by 10: x1 = x0 / 10, x2 = x0 Mod 10 }
  WriteLn('    mov x9, #10');
  WriteLn('    udiv x1, x0, x9');
  WriteLn('    msub x0, x1, x9, x0');
  { x1=tens, x0=units - store tens digit }
  WriteLn('    add x1, x1, #48');
  { strb w1, [x8], #1 }
  WriteLn('    strb w1, [x8], #1');
  EmitLabel(done1);
  { Store units digit }
  WriteLn('    add x0, x0, #48');
  { strb w0, [x8], #1 }
  WriteLn('    strb w0, [x8], #1');
  { Store semicolon }
  EmitMovX0(59);  { ; }
  { strb w0, [x8], #1 }
  WriteLn('    strb w0, [x8], #1');
  { Convert x To decimal digits (x is In x12) }
  { mov x0, x12 }
  WriteLn('    mov x0, x12');
  done2 := NewLabel;
  WriteLn('    cmp x0, #10');
  Write('    b.lt L'); WriteLn(done2);
  { Divide by 10 }
  WriteLn('    mov x9, #10');
  WriteLn('    udiv x1, x0, x9');
  WriteLn('    msub x0, x1, x9, x0');
  { Store tens digit }
  WriteLn('    add x1, x1, #48');
  { strb w1, [x8], #1 }
  WriteLn('    strb w1, [x8], #1');
  EmitLabel(done2);
  { Store units digit }
  WriteLn('    add x0, x0, #48');
  { strb w0, [x8], #1 }
  WriteLn('    strb w0, [x8], #1');
  { Store H terminator }
  EmitMovX0(72);  { H }
  { strb w0, [x8] }
  WriteLn('    strb w0, [x8]');
  { Calculate Length: x8 points past last byte, buffer starts at x29-20 }
  { add x8, x8, #1 (point past H) }
  WriteLn('    add x8, x8, #1');
  { x2 = x8 - (x29-20) = x8 - x29 + 20 }
  { sub x2, x8, x29 }
  WriteLn('    sub x2, x8, x29');
  { add x2, x2, #20 }
  WriteLn('    add x2, x2, #20');
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #20 }
  WriteLn('    sub x1, x29, #20');
  EmitSvc;
  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitClrEolRuntime;
{ Emits code To clear To End Of line: ESC[K }
Begin
  EmitLabel(rt_clreol);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[K = 27,91,75 }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-11);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-10);
  EmitMovX0(75);  { K }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #11 }
  WriteLn('    sub x1, x29, #11');
  { mov x2, #3 }
  WriteLn('    mov x2, #3');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitTextColorRuntime;
{ Emits code To Set foreground color: ESC[3Xm where X=x0 (0-7) }
Begin
  EmitLabel(rt_textcolor);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Save color parameter (x0) To x9 }
  WriteLn('    mov x9, x0');
  { Store ESC[3Xm = 27,91,51,X,109 (5 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-13);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-12);
  EmitMovX0(51);  { 3 }
  EmitStrbAtOffset(-11);
  { Store color digit: x9 + 48 }
  WriteLn('    add x0, x9, #48');
  EmitStrbAtOffset(-10);
  { Store 'm' }
  EmitMovX0(109);  { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #13 }
  WriteLn('    sub x1, x29, #13');
  { mov x2, #5 }
  WriteLn('    mov x2, #5');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitTextBackgroundRuntime;
{ Emits code To Set background color: ESC[4Xm where X=x0 (0-7) }
Begin
  EmitLabel(rt_textbackground);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Save color parameter (x0) To x9 }
  WriteLn('    mov x9, x0');
  { Store ESC[4Xm = 27,91,52,X,109 (5 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-13);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-12);
  EmitMovX0(52);  { 4 }
  EmitStrbAtOffset(-11);
  { Store color digit: x9 + 48 }
  WriteLn('    add x0, x9, #48');
  EmitStrbAtOffset(-10);
  { Store 'm' }
  EmitMovX0(109);  { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #13 }
  WriteLn('    sub x1, x29, #13');
  { mov x2, #5 }
  WriteLn('    mov x2, #5');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitNormVideoRuntime;
{ Emits code To reset attributes: ESC[0m }
Begin
  EmitLabel(rt_normvideo);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[0m = 27,91,48,109 (4 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-12);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-11);
  EmitMovX0(48);  { 0 }
  EmitStrbAtOffset(-10);
  EmitMovX0(109); { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #12 }
  WriteLn('    sub x1, x29, #12');
  { mov x2, #4 }
  WriteLn('    mov x2, #4');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitHighVideoRuntime;
{ Emits code To enable bold: ESC[1m }
Begin
  EmitLabel(rt_highvideo);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[1m = 27,91,49,109 (4 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-12);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-11);
  EmitMovX0(49);  { 1 }
  EmitStrbAtOffset(-10);
  EmitMovX0(109); { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #12 }
  WriteLn('    sub x1, x29, #12');
  { mov x2, #4 }
  WriteLn('    mov x2, #4');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitLowVideoRuntime;
{ Emits code To enable dim: ESC[2m }
Begin
  EmitLabel(rt_lowvideo);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[2m = 27,91,50,109 (4 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-12);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-11);
  EmitMovX0(50);  { 2 }
  EmitStrbAtOffset(-10);
  EmitMovX0(109); { m }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #12 }
  WriteLn('    sub x1, x29, #12');
  { mov x2, #4 }
  WriteLn('    mov x2, #4');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitHideCursorRuntime;
{ Emits code To hide cursor: ESC[?25l }
Begin
  EmitLabel(rt_hidecursor);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[?25l = 27,91,63,50,53,108 (6 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-14);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-13);
  EmitMovX0(63);  { ? }
  EmitStrbAtOffset(-12);
  EmitMovX0(50);  { 2 }
  EmitStrbAtOffset(-11);
  EmitMovX0(53);  { 5 }
  EmitStrbAtOffset(-10);
  EmitMovX0(108); { l }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #14 }
  WriteLn('    sub x1, x29, #14');
  { mov x2, #6 }
  WriteLn('    mov x2, #6');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitShowCursorRuntime;
{ Emits code To show cursor: ESC[?25h }
Begin
  EmitLabel(rt_showcursor);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);
  { Store ESC[?25h = 27,91,63,50,53,104 (6 bytes) }
  EmitMovX0(27);  { ESC }
  EmitStrbAtOffset(-14);
  EmitMovX0(91);  { [ }
  EmitStrbAtOffset(-13);
  EmitMovX0(63);  { ? }
  EmitStrbAtOffset(-12);
  EmitMovX0(50);  { 2 }
  EmitStrbAtOffset(-11);
  EmitMovX0(53);  { 5 }
  EmitStrbAtOffset(-10);
  EmitMovX0(104); { h }
  EmitStrbAtOffset(-9);
  { Write syscall }
  EmitMovX16(33554436);  { 0x2000004 = Write }
  EmitMovX0X20;          { fd from x20 }
  { sub x1, x29, #14 }
  WriteLn('    sub x1, x29, #14');
  { mov x2, #6 }
  WriteLn('    mov x2, #6');
  EmitSvc;
  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitSleepRuntime;
{ Emits code To sleep For x0 milliseconds using select syscall }
{ x0 = milliseconds }
{ select(0, NULL, NULL, NULL, &timeval) With nfds=0, all fd_sets=NULL }
{ struct timeval: tv_sec (8 bytes), tv_usec (8 bytes) }
Begin
  EmitLabel(rt_sleep);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);  { 16 bytes For timeval + alignment }

  { x10 = ms (save original) }
  WriteLn('    mov x10, x0');

  { x11 = 1000 }
  WriteLn('    mov x11, #1000');

  { x0 = ms / 1000 (seconds) }
  WriteLn('    udiv x0, x10, x11');

  { x1 = ms Mod 1000 (remainder): msub x1, x0, x11, x10 = x10 - (x0 * x11) }
  WriteLn('    msub x1, x0, x11, x10');

  { x1 = x1 * 1000 (microseconds, Not nanoseconds For timeval) }
  WriteLn('    mul x1, x1, x11');

  { Store timeval at sp: [sp] = tv_sec, [sp+8] = tv_usec }
  WriteLn('    str x0, [sp]');

  WriteLn('    str x1, [sp, #8]');

  { select(nfds=0, readfds=NULL, writefds=NULL, exceptfds=NULL, timeout=sp) }
  { x0 = 0 (nfds) }
  WriteLn('    mov x0, #0');

  { x1 = NULL }
  WriteLn('    mov x1, #0');

  { x2 = NULL }
  WriteLn('    mov x2, #0');

  { x3 = NULL }
  WriteLn('    mov x3, #0');

  { x4 = pointer To timeval (sp) }
  WriteLn('    mov x4, sp');

  { x16 = syscall number For select: 0x2000000 + 93 = 33554525 }
  EmitMovX16(33554525);
  EmitSvc;

  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitKeyPressedRuntime;
{ Check If a key is available on stdin using select With 0 timeout }
{ Returns 1 In x0 If key available, 0 otherwise }
Begin
  EmitLabel(rt_keypressed);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);  { 8 bytes For fd_set + 16 bytes For timeval + padding }

  { Clear the fd_set at sp }
  WriteLn('    mov x0, #0');
  WriteLn('    str x0, [sp]');

  { Set bit 0 In fd_set For stdin (fd 0) }
  WriteLn('    mov x0, #1');
  WriteLn('    str x0, [sp]');

  { Set timeval To 0,0 (no wait) at sp+16 }
  WriteLn('    mov x0, #0');
  WriteLn('    str x0, [sp, #16]');
  WriteLn('    str x0, [sp, #24]');

  { select(nfds=1, readfds=sp, writefds=NULL, exceptfds=NULL, timeout=sp+16) }
  { x0 = 1 (nfds) }
  WriteLn('    mov x0, #1');

  { x1 = sp (readfds) }
  WriteLn('    mov x1, sp');

  { x2 = NULL }
  WriteLn('    mov x2, #0');

  { x3 = NULL }
  WriteLn('    mov x3, #0');

  { x4 = sp + 16 (timeout) }
  WriteLn('    add x4, sp, #16');

  { x16 = syscall number For select: 0x2000000 + 93 = 33554525 }
  EmitMovX16(33554525);
  EmitSvc;

  { select returns number Of ready fds In x0, Or -1 on error }
  { If x0 > 0, key is available; convert To 0 Or 1 }
  WriteLn('    cmp x0, #0');
  WriteLn('    cset x0, gt');

  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitInitKeyboardRuntime;
{ Set terminal To raw mode For immediate key reading }
{ Uses ioctl TIOCGETA To get, Then TIOCSETA To Set With ICANON And ECHO cleared }
Begin
  EmitLabel(rt_initkeyboard);
  EmitStp;
  EmitMovFP;
  EmitSubSP(80);  { Space For termios structure (72 bytes aligned To 80) }

  { First get current terminal settings: ioctl(0, TIOCGETA, sp) }
  { x0 = 0 (stdin) }
  WriteLn('    mov x0, #0');

  { x1 = TIOCGETA = 0x40487413 }
  { movz x1, #0x7413 }
  WriteLn('    movz x1, #0x7413');
  { movk x1, #0x4048, lsl #16 }
  WriteLn('    movk x1, #0x4048, lsl #16');

  { x2 = sp (pointer To termios buffer) }
  WriteLn('    mov x2, sp');

  { ioctl syscall: 0x2000000 + 54 = 33554486 }
  EmitMovX16(33554486);
  EmitSvc;

  { Save original c_lflag (at offset 24) To x23 (callee-saved) For later restore }
  WriteLn('    ldr x23, [sp, #24]');

  { Clear ICANON (0x100 = 256) And ECHO (0x8) from c_lflag }
  { Load current c_lflag into x10 }
  WriteLn('    mov x10, x23');

  { x11 = 0x108 (ICANON | ECHO) }
  WriteLn('    mov x11, #0x108');

  { bic x10, x10, x11 (clear bits) }
  WriteLn('    bic x10, x10, x11');

  { Store modified c_lflag back }
  WriteLn('    str x10, [sp, #24]');

  { Set VMIN (c_cc[16]) To 1 And VTIME (c_cc[17]) To 0 }
  { c_cc starts at offset 32, so VMIN is at 32+16=48, VTIME at 32+17=49 }
  WriteLn('    mov x10, #1');
  WriteLn('    strb w10, [sp, #48]');
  WriteLn('    mov x10, #0');
  WriteLn('    strb w10, [sp, #49]');

  { Now Set the modified settings: ioctl(0, TIOCSETA, sp) }
  { x0 = 0 (stdin) }
  WriteLn('    mov x0, #0');

  { x1 = TIOCSETA = 0x80487414 }
  { movz x1, #0x7414 }
  WriteLn('    movz x1, #0x7414');
  { movk x1, #0x8048, lsl #16 }
  WriteLn('    movk x1, #0x8048, lsl #16');

  { x2 = sp }
  WriteLn('    mov x2, sp');

  EmitMovX16(33554486);
  EmitSvc;

  EmitAddSP(80);
  EmitLdp;
  EmitRet
End;

Procedure EmitDoneKeyboardRuntime;
{ Restore terminal To normal (cooked) mode }
Begin
  EmitLabel(rt_donekeyboard);
  EmitStp;
  EmitMovFP;
  EmitSubSP(80);

  { Get current settings first }
  WriteLn('    mov x0, #0');

  { x1 = TIOCGETA = 0x40487413 }
  WriteLn('    movz x1, #0x7413');
  WriteLn('    movk x1, #0x4048, lsl #16');

  WriteLn('    mov x2, sp');

  EmitMovX16(33554486);
  EmitSvc;

  { Restore original c_lflag from x23 }
  WriteLn('    str x23, [sp, #24]');

  { Set the restored settings }
  WriteLn('    mov x0, #0');

  { x1 = TIOCSETA = 0x80487414 }
  WriteLn('    movz x1, #0x7414');
  WriteLn('    movk x1, #0x8048, lsl #16');

  WriteLn('    mov x2, sp');

  EmitMovX16(33554486);
  EmitSvc;

  EmitAddSP(80);
  EmitLdp;
  EmitRet
End;

Procedure EmitSinRuntime;
Begin
  { sin(x) using Taylor series: x - x/6 + x/120 - x/5040 + x/362880 - x/39916800 }
  { Input: d0 = x, Output: d0 = sin(x) }
  EmitLabel(rt_sin);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  { Save x To [x29, #-16] }
  EmitSturD0(-16);

  { Compute x And save To [x29, #-24] }
  { fmul d1, d0, d0 }
  WriteLn('    fmul d1, d0, d0');
  { stur d1, [x29, #-24] }
  WriteLn('    stur d1, [x29, #-24]');

  { result = x (d0 already has x) }
  { Compute x = x * x into d2 }
  { fmul d2, d1, d0 }
  WriteLn('    fmul d2, d1, d0');

  { Term 2: -x/6 }
  EmitMovX0(6);
  EmitScvtfD0X0;
  { fdiv d3, d2, d0 - d3 = x/6 }
  WriteLn('    fdiv d3, d2, d0');
  { Load x into d0 }
  EmitLdurD0(-16);
  { fsub d0, d0, d3 - result = x - x/6 }
  WriteLn('    fsub d0, d0, d3');
  { Save result }
  EmitSturD0(-32);

  { Term 3: +x/120 - multiply d3 by x, divide by 20 }
  { ldur d1, [x29, #-24] - reload x }
  WriteLn('    ldur d1, [x29, #-24]');
  { fmul d3, d3, d1 - d3 = x/6 }
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(20);
  EmitScvtfD0X0;
  { fdiv d3, d3, d0 }
  WriteLn('    fdiv d3, d3, d0');
  { Load result And add }
  EmitLdurD0(-32);
  { fadd d0, d0, d3 }
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-32);

  { Term 4: -x/5040 }
  WriteLn('    ldur d1, [x29, #-24]');
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(42);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-32);
  WriteLn('    fsub d0, d0, d3');
  EmitSturD0(-32);

  { Term 5: +x/362880 }
  WriteLn('    ldur d1, [x29, #-24]');
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(72);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-32);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-32);

  { Term 6: -x/39916800 }
  WriteLn('    ldur d1, [x29, #-24]');
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(110);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-32);
  WriteLn('    fsub d0, d0, d3');

  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitCosRuntime;
Begin
  { cos(x) using Taylor series: 1 - x/2 + x/24 - x/720 + x/40320 - x/3628800 }
  { Input: d0 = x, Output: d0 = cos(x) }
  EmitLabel(rt_cos);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  { Save x To [x29, #-16] }
  EmitSturD0(-16);

  { Compute x And save To [x29, #-24] }
  { fmul d1, d0, d0 }
  WriteLn('    fmul d1, d0, d0');
  { stur d1, [x29, #-24] }
  WriteLn('    stur d1, [x29, #-24]');

  { Start With result = 1.0 }
  EmitMovX0(1);
  EmitScvtfD0X0;
  { d3 = x (current term numerator starts as x) }
  { fmov d3, d1 }
  WriteLn('    fmov d3, d1');

  { Term 2: -x/2 }
  EmitPushD0;
  EmitMovX0(2);
  EmitScvtfD0X0;
  { fdiv d3, d3, d0 }
  WriteLn('    fdiv d3, d3, d0');
  EmitPopD0;
  { fsub d0, d0, d3 }
  WriteLn('    fsub d0, d0, d3');
  EmitSturD0(-32);

  { Term 3: +x/24 }
  { ldur d1, [x29, #-24] }
  WriteLn('    ldur d1, [x29, #-24]');
  { fmul d3, d3, d1 }
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(12);  { 24/2 = 12 }
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-32);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-32);

  { Term 4: -x/720 }
  WriteLn('    ldur d1, [x29, #-24]');
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(30);  { 720/24 = 30 }
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-32);
  WriteLn('    fsub d0, d0, d3');
  EmitSturD0(-32);

  { Term 5: +x/40320 }
  WriteLn('    ldur d1, [x29, #-24]');
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(56);  { 40320/720 = 56 }
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-32);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-32);

  { Term 6: -x/3628800 }
  WriteLn('    ldur d1, [x29, #-24]');
  WriteLn('    fmul d3, d3, d1');
  EmitMovX0(90);  { 3628800/40320 = 90 }
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-32);
  WriteLn('    fsub d0, d0, d3');

  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitTanRuntime;
Begin
  { tan(x) = sin(x) / cos(x) }
  { Input: d0 = x, Output: d0 = tan(x) }
  EmitLabel(rt_tan);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save x }
  EmitSturD0(-16);

  { Call sin(x) }
  EmitBL(rt_sin);
  { Save sin result }
  EmitSturD0(-24);

  { Load x again }
  EmitLdurD0(-16);
  { Call cos(x) }
  EmitBL(rt_cos);

  { d0 = cos(x), load sin(x) To d1 }
  WriteLn('    ldur d1, [x29, #-24]');

  { fdiv d0, d1, d0 - tan = sin/cos }
  WriteLn('    fdiv d0, d1, d0');

  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitExpRuntime;
Var
  pos_lbl, neg_lbl, scale_lbl, scale_done_lbl, done_lbl: Integer;
Begin
  { exp(x) using range reduction + Taylor series }
  { Input: d0 = x, Output: d0 = exp(x) }
  { Range reduction: exp(x) = 2^n * exp(r) where n = round(x/ln(2)), r = x - n*ln(2) }
  EmitLabel(rt_exp);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);

  { Save x To [x29, #-16] }
  EmitSturD0(-16);
  { [x29, #-24] = n (Integer), [x29, #-32] = r (reduced x), [x29, #-40] = result }

  { Load 1/ln(2) = 1.4426950408889634 into d1 }
  { IEEE 754: 0x3FF71547652B82FE }
  { movz x0, #0x82FE }
  WriteLn('    movz x0, #0x82FE');
  { movk x0, #0x652B, lsl #16 }
  WriteLn('    movk x0, #0x652B, lsl #16');
  { movk x0, #0x7154, lsl #32 }
  WriteLn('    movk x0, #0x7154, lsl #32');
  { movk x0, #0x3FF7, lsl #48 }
  WriteLn('    movk x0, #0x3FF7, lsl #48');
  { fmov d1, x0 }
  WriteLn('    fmov d1, x0');

  { d0 = x, d1 = 1/ln(2) }
  { d0 = x / ln(2) = x * (1/ln(2)) }
  EmitLdurD0(-16);
  WriteLn('    fmul d0, d0, d1');

  { n = round(x/ln(2)) using fcvtas (round To nearest) }
  { fcvtas x0, d0 }
  WriteLn('    fcvtas x0, d0');
  EmitSturX0(-24);

  { Load ln(2) into d1 }
  { IEEE 754: 0x3FE62E42FEFA39EF }
  { movz x1, #0x39EF }
  WriteLn('    movz x1, #0x39EF');
  { movk x1, #0xFEFA, lsl #16 }
  WriteLn('    movk x1, #0xFEFA, lsl #16');
  { movk x1, #0x62E4, lsl #32 }
  WriteLn('    movk x1, #0x62E4, lsl #32');
  { movk x1, #0x3FE6, lsl #48 }
  WriteLn('    movk x1, #0x3FE6, lsl #48');
  { fmov d1, x1 }
  WriteLn('    fmov d1, x1');

  { r = x - n * ln(2) }
  { scvtf d0, x0 - convert n To float }
  EmitScvtfD0X0;
  { fmul d0, d0, d1 - d0 = n * ln(2) }
  WriteLn('    fmul d0, d0, d1');
  { fmov d2, d0 - save n*ln(2) In d2 }
  WriteLn('    fmov d2, d0');
  { d0 = x }
  EmitLdurD0(-16);
  { fsub d0, d0, d2 - r = x - n*ln(2) }
  WriteLn('    fsub d0, d0, d2');
  { Save r To [x29, #-32] }
  WriteLn('    stur d0, [x29, #-32]');

  { Now compute exp(r) using Taylor series }
  { r is small (|r| < ln(2)/2  0.35), so series converges fast }
  { exp(r) = 1 + r + r/2 + r/6 + r/24 + r/120 + r/720 + r/5040 + r/40320 }
  { d3 = current term, d0 = r }
  { fmov d3, d0 }
  WriteLn('    fmov d3, d0');
  { d0 = 1.0 }
  EmitPushD0;
  EmitMovX0(1);
  EmitScvtfD0X0;
  EmitPopD1;
  { fadd d0, d0, d1 - result = 1 + r }
  WriteLn('    fadd d0, d0, d1');
  EmitSturD0(-40);

  { Term 3: r/2 }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  { fmul d3, d3, d0 }
  WriteLn('    fmul d3, d3, d0');
  EmitMovX0(2);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-40);

  { Term 4: r/6 }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  WriteLn('    fmul d3, d3, d0');
  EmitMovX0(3);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-40);

  { Term 5: r/24 }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  WriteLn('    fmul d3, d3, d0');
  EmitMovX0(4);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-40);

  { Term 6: r/120 }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  WriteLn('    fmul d3, d3, d0');
  EmitMovX0(5);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-40);

  { Term 7: r/720 }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  WriteLn('    fmul d3, d3, d0');
  EmitMovX0(6);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-40);

  { Term 8: r/5040 }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  WriteLn('    fmul d3, d3, d0');
  EmitMovX0(7);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d3');
  EmitSturD0(-40);

  { Term 9: r/40320 }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  WriteLn('    fmul d3, d3, d0');
  EmitMovX0(8);
  EmitScvtfD0X0;
  WriteLn('    fdiv d3, d3, d0');
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d3');

  { d0 = exp(r), now multiply by 2^n }
  { Store exp(r) In [x29, #-48] temporarily }
  WriteLn('    stur d0, [x29, #-48]');

  { Load n }
  EmitLdurX0(-24);
  { If n = 0, skip scaling }
  WriteLn('    cmp x0, #0');
  done_lbl := NewLabel;
  pos_lbl := NewLabel;
  scale_lbl := NewLabel;
  Write('    b.eq L'); WriteLn(done_lbl);
  { If n > 0, multiply by 2 repeatedly }
  Write('    b.gt L'); WriteLn(pos_lbl);
  { n < 0, divide by 2 repeatedly }
  { neg x0, x0 }
  WriteLn('    neg x0, x0');
  EmitSturX0(-56);
  { Load 0.5 into d1 }
  { IEEE 754 For 0.5 = 0x3FE0000000000000 }
  WriteLn('    movz x1, #0x3FE0, lsl #48');
  { fmov d1, x1 }
  WriteLn('    fmov d1, x1');
  EmitBranchLabel(scale_lbl);

  EmitLabel(pos_lbl);
  EmitSturX0(-56);
  { Load 2.0 into d1 }
  EmitMovX0(2);
  EmitScvtfD0X0;
  { fmov d1, d0 }
  WriteLn('    fmov d1, d0');

  EmitLabel(scale_lbl);
  { d1 = scale factor (2.0 Or 0.5), [x29, #-56] = count, [x29, #-48] = result }
  { Load result }
  WriteLn('    ldur d0, [x29, #-48]');

  EmitLdurX0(-56);
  WriteLn('    cmp x0, #0');
  Write('    b.eq L'); WriteLn(done_lbl);
  { fmul d0, d0, d1 }
  WriteLn('    fmul d0, d0, d1');
  { Store result }
  WriteLn('    stur d0, [x29, #-48]');
  { Decrement count }
  WriteLn('    sub x0, x0, #1');
  EmitSturX0(-56);
  EmitBranchLabel(scale_lbl);

  EmitLabel(done_lbl);
  { Load final result }
  WriteLn('    ldur d0, [x29, #-48]');

  EmitAddSP(64);
  EmitLdp;
  EmitRet
End;

Procedure EmitLnRuntime;
Var
  loop_lbl, done_lbl, reduce_lbl, reduce_up_lbl, iter_lbl, iter_done_lbl: Integer;
Begin
  { ln(x) using range reduction + Newton-Raphson }
  { Input: d0 = x, Output: d0 = ln(x) }
  { Range reduction: x = 2^n * m where 1 <= m < 2, so ln(x) = n*ln(2) + ln(m) }
  EmitLabel(rt_ln);
  EmitStp;
  EmitMovFP;
  EmitSubSP(64);

  { Save original x To [x29, #-16] }
  EmitSturD0(-16);
  { [x29, #-24] = count n (signed), [x29, #-32] = reduced x, [x29, #-40] = y estimate }
  { [x29, #-48] = iteration counter, [x29, #-56] = exp(y) temp }

  { Initialize count = 0 }
  EmitMovX0(0);
  EmitSturX0(-24);

  { Load x into d0 }
  EmitLdurD0(-16);
  { fmov d3, d0 - d3 = working copy Of x }
  WriteLn('    fmov d3, d0');

  { Load 2.0 into d1 And 1.0 into d2 For comparisons }
  EmitMovX0(2);
  EmitScvtfD0X0;
  { fmov d1, d0 }
  WriteLn('    fmov d1, d0');
  EmitMovX0(1);
  EmitScvtfD0X0;
  { fmov d2, d0 }
  WriteLn('    fmov d2, d0');
  { d1 = 2.0, d2 = 1.0, d3 = x }

  { Reduce While d3 >= 2: d3 = d3 / 2, count++ }
  reduce_lbl := NewLabel;
  reduce_up_lbl := NewLabel;
  done_lbl := NewLabel;
  EmitLabel(reduce_lbl);
  { fcmp d3, d1 }
  WriteLn('    fcmp d3, d1');
  { b.lt reduce_up_lbl - If d3 < 2, check If < 1 }
  Write('    b.lt L'); WriteLn(reduce_up_lbl);
  { d3 >= 2: divide by 2 }
  { fdiv d3, d3, d1 }
  WriteLn('    fdiv d3, d3, d1');
  { count++ }
  EmitLdurX0(-24);
  WriteLn('    add x0, x0, #1');
  EmitSturX0(-24);
  EmitBranchLabel(reduce_lbl);

  { Check If d3 < 1: multiply by 2, count-- }
  EmitLabel(reduce_up_lbl);
  { fcmp d3, d2 }
  WriteLn('    fcmp d3, d2');
  { b.ge done_lbl - If d3 >= 1, we're In [1, 2) }
  Write('    b.ge L'); WriteLn(done_lbl);
  { d3 < 1: multiply by 2 }
  { fmul d3, d3, d1 }
  WriteLn('    fmul d3, d3, d1');
  { count-- }
  EmitLdurX0(-24);
  WriteLn('    sub x0, x0, #1');
  EmitSturX0(-24);
  EmitBranchLabel(reduce_up_lbl);

  EmitLabel(done_lbl);
  { Now d3 is In [1, 2), count is In [x29, #-24] }
  { Save reduced x To [x29, #-32] }
  WriteLn('    stur d3, [x29, #-32]');

  { Initial guess: y = d3 - 1 (will be In [0, 1)) }
  { fsub d0, d3, d2 }
  WriteLn('    fsub d0, d3, d2');
  EmitSturD0(-40);

  { Iterate 15 times For convergence }
  EmitMovX0(15);
  EmitSturX0(-48);

  iter_lbl := NewLabel;
  iter_done_lbl := NewLabel;
  EmitLabel(iter_lbl);

  { Check counter }
  EmitLdurX0(-48);
  { cmp x0, #0 }
  WriteLn('    cmp x0, #0');
  { b.eq iter_done }
  Write('    b.eq L'); WriteLn(iter_done_lbl);

  { Decrement counter }
  WriteLn('    sub x0, x0, #1');
  EmitSturX0(-48);

  { Load y }
  EmitLdurD0(-40);
  { Calculate exp(y) }
  EmitBL(rt_exp);
  { Save exp(y) To [x29, #-56] }
  WriteLn('    stur d0, [x29, #-56]');

  { d0 = reduced x, d1 = exp(y) }
  { ldur d0, [x29, #-32] }
  WriteLn('    ldur d0, [x29, #-32]');
  { ldur d1, [x29, #-56] }
  WriteLn('    ldur d1, [x29, #-56]');

  { d2 = x - exp(y) }
  WriteLn('    fsub d2, d0, d1');

  { d3 = x + exp(y) }
  WriteLn('    fadd d3, d0, d1');

  { d2 = d2 / d3 = (x - exp(y))/(x + exp(y)) }
  WriteLn('    fdiv d2, d2, d3');

  { d2 = 2 * d2 }
  EmitMovX0(2);
  EmitScvtfD0X0;
  WriteLn('    fmul d2, d2, d0');

  { y = y + d2 }
  EmitLdurD0(-40);
  WriteLn('    fadd d0, d0, d2');
  EmitSturD0(-40);

  { Loop }
  EmitBranchLabel(iter_lbl);

  EmitLabel(iter_done_lbl);
  { d0 = ln(reduced_x), now add n * ln(2) }
  { ln(2) = 0.693147180559945 }
  { IEEE 754: 0x3FE62E42FEFA39EF }
  EmitLdurD0(-40);
  { Save ln(reduced_x) }
  EmitPushD0;

  { Load ln(2) into d1 }
  { movz x0, #0x39EF }
  WriteLn('    movz x0, #0x39EF');
  { movk x0, #0xFEFA, lsl #16 }
  WriteLn('    movk x0, #0xFEFA, lsl #16');
  { movk x0, #0x62E4, lsl #32 }
  WriteLn('    movk x0, #0x62E4, lsl #32');
  { movk x0, #0x3FE6, lsl #48 }
  WriteLn('    movk x0, #0x3FE6, lsl #48');
  { fmov d1, x0 }
  WriteLn('    fmov d1, x0');

  { Load count into d0, convert To float }
  EmitLdurX0(-24);
  { scvtf d0, x0 }
  EmitScvtfD0X0;

  { d0 = count * ln(2) }
  { fmul d0, d0, d1 }
  WriteLn('    fmul d0, d0, d1');

  { d0 = count*ln(2) + ln(reduced_x) }
  EmitPopD1;
  WriteLn('    fadd d0, d0, d1');

  EmitAddSP(64);
  EmitLdp;
  EmitRet
End;

Procedure EmitRandomRuntime;
Begin
  { random - return random 64-bit Integer In x0 using LCG PRNG }
  { Uses x27 as seed (preserved across calls) }
  { LCG: seed = seed * 6364136223846793005 + 1442695040888963407 }
  { Output: x0 = random Integer }
  EmitLabel(rt_random);
  EmitStp;
  EmitMovFP;

  { Load seed from x27 }
  WriteLn('    mov x0, x27');

  { If seed is 0, initialize With a default value }
  { cbnz x0, Lxxx }
  Write('    cbnz x0, L'); WriteLn(label_count);
  { Initialize seed To 0x5DEECE66D }
  WriteLn('    movz x0, #0xE66D');
  WriteLn('    movk x0, #0xECE5, lsl #16');
  WriteLn('    movk x0, #0xDE, lsl #32');
  WriteLn('    movk x0, #0x5, lsl #48');

  EmitLabel(label_count);
  label_count := label_count + 1;

  { Load multiplier 6364136223846793005 = 0x5851F42D4C957F2D into x1 }
  WriteLn('    movz x1, #0x7F2D');
  WriteLn('    movk x1, #0x4C95, lsl #16');
  WriteLn('    movk x1, #0xF42D, lsl #32');
  WriteLn('    movk x1, #0x5851, lsl #48');

  { mul x0, x0, x1 }
  WriteLn('    mul x0, x0, x1');

  { Load increment 1442695040888963407 = 0x14057B7EF767814F into x1 }
  WriteLn('    movz x1, #0x814F');
  WriteLn('    movk x1, #0x7677, lsl #16');
  WriteLn('    movk x1, #0x7B7E, lsl #32');
  WriteLn('    movk x1, #0x1405, lsl #48');

  { add x0, x0, x1 }
  WriteLn('    add x0, x0, x1');

  { Store New seed In x27 }
  WriteLn('    mov x27, x0');

  EmitLdp;
  EmitRet
End;

Procedure EmitArctanRuntime;
Var
  use_identity_lbl, neg_lbl, done_lbl, compute_lbl: Integer;
Begin
  { arctan(x) using Taylor series For |x| <= 1 }
  { For |x| > 1: arctan(x) = pi/2 - arctan(1/x) If x > 0 }
  {              arctan(x) = -pi/2 - arctan(1/x) If x < 0 }
  { Input: d0 = x, Output: d0 = arctan(x) }
  EmitLabel(rt_arctan);
  EmitStp;
  EmitMovFP;
  EmitSubSP(48);

  { Save x To [x29, #-16] }
  EmitSturD0(-16);

  { Check If |x| > 1 }
  { fabs d1, d0 }
  WriteLn('    fabs d1, d0');
  { Load 1.0 into d2 }
  EmitMovX0(1);
  EmitScvtfD0X0;
  { fmov d2, d0 }
  WriteLn('    fmov d2, d0');
  { fcmp d1, d2 }
  WriteLn('    fcmp d1, d2');

  use_identity_lbl := NewLabel;
  compute_lbl := NewLabel;
  done_lbl := NewLabel;

  { b.le compute - If |x| <= 1, use direct Taylor series }
  Write('    b.le L'); WriteLn(compute_lbl);

  { |x| > 1: use identity arctan(x) = sign(x)*pi/2 - arctan(1/x) }
  { Compute 1/x }
  EmitLdurD0(-16);  { x }
  { fdiv d0, d2, d0 - d0 = 1/x (d2 still has 1.0) }
  WriteLn('    fdiv d0, d2, d0');
  { Save 1/x To [x29, #-24] }
  EmitSturD0(-24);
  { Now compute arctan(1/x) recursively - but we're already In arctan! }
  { Let's just use Taylor series on 1/x since |1/x| < 1 }
  EmitBranchLabel(compute_lbl);

  EmitLabel(compute_lbl);
  { Taylor series: arctan(x) = x - x/3 + x/5 - x/7 + x/9 }
  { Use d0=x, d3=current term, d4=x, d5=result }
  EmitLdurD0(-16);  { x }

  { Check If we used identity (|x| > 1), Then use 1/x instead }
  { Actually, let's simplify - compute arctan using the argument already In d0 }
  { If we came from the identity path, d0 has 1/x }
  { For now, just compute Taylor series on whatever is In d0 }

  { Save x To d5 as running result }
  { fmov d5, d0 }
  WriteLn('    fmov d5, d0');

  { d4 = x }
  WriteLn('    fmul d4, d0, d0');

  { d3 = x (current power) }
  { fmov d3, d0 }
  WriteLn('    fmov d3, d0');

  { Term 2: -x/3 }
  { d3 = d3 * d4 = x }
  WriteLn('    fmul d3, d3, d4');
  EmitMovX0(3);
  EmitScvtfD0X0;
  { fdiv d6, d3, d0 }
  WriteLn('    fdiv d6, d3, d0');
  { d5 = d5 - d6 }
  WriteLn('    fsub d5, d5, d6');

  { Term 3: +x/5 }
  WriteLn('    fmul d3, d3, d4');
  EmitMovX0(5);
  EmitScvtfD0X0;
  WriteLn('    fdiv d6, d3, d0');
  WriteLn('    fadd d5, d5, d6');

  { Term 4: -x/7 }
  WriteLn('    fmul d3, d3, d4');
  EmitMovX0(7);
  EmitScvtfD0X0;
  WriteLn('    fdiv d6, d3, d0');
  WriteLn('    fsub d5, d5, d6');

  { Term 5: +x/9 }
  WriteLn('    fmul d3, d3, d4');
  EmitMovX0(9);
  EmitScvtfD0X0;
  WriteLn('    fdiv d6, d3, d0');
  WriteLn('    fadd d5, d5, d6');

  { Term 6: -x/11 }
  WriteLn('    fmul d3, d3, d4');
  EmitMovX0(11);
  EmitScvtfD0X0;
  WriteLn('    fdiv d6, d3, d0');
  WriteLn('    fsub d5, d5, d6');

  { Result In d5, move To d0 }
  { fmov d0, d5 }
  WriteLn('    fmov d0, d5');

  EmitAddSP(48);
  EmitLdp;
  EmitRet
End;

Procedure EmitArcsinRuntime;
Var
  pos_one_lbl, neg_one_lbl, normal_lbl, done_lbl: Integer;
Begin
  { arcsin(x) = arctan(x / sqrt(1 - x)) }
  { Special cases: arcsin(1) = pi/2, arcsin(-1) = -pi/2 }
  { Input: d0 = x, Output: d0 = arcsin(x) }
  EmitLabel(rt_arcsin);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Save x To [x29, #-16] }
  EmitSturD0(-16);

  pos_one_lbl := NewLabel;
  neg_one_lbl := NewLabel;
  normal_lbl := NewLabel;
  done_lbl := NewLabel;

  { Check For x = 1 Or x = -1 }
  { Load 1.0 into d1 }
  EmitMovX0(1);
  EmitScvtfD0X0;
  { fmov d1, d0 }
  WriteLn('    fmov d1, d0');
  { Load x back }
  EmitLdurD0(-16);
  { fcmp d0, d1 - compare x With 1.0 }
  WriteLn('    fcmp d0, d1');
  { b.eq pos_one_lbl }
  Write('    b.eq L'); WriteLn(pos_one_lbl);
  { fneg d1, d1 - d1 = -1.0 }
  WriteLn('    fneg d1, d1');
  { fcmp d0, d1 - compare x With -1.0 }
  WriteLn('    fcmp d0, d1');
  { b.eq neg_one_lbl }
  Write('    b.eq L'); WriteLn(neg_one_lbl);
  { Fall through To normal Case }
  EmitBranchLabel(normal_lbl);

  { x = 1: return pi/2 }
  EmitLabel(pos_one_lbl);
  { Load pi/2 = 1.5707963267948966 }
  { IEEE 754: 0x3FF921FB54442D18 }
  WriteLn('    movz x0, #0x2D18');
  WriteLn('    movk x0, #0x5444, lsl #16');
  WriteLn('    movk x0, #0x21FB, lsl #32');
  WriteLn('    movk x0, #0x3FF9, lsl #48');
  { fmov d0, x0 }
  WriteLn('    fmov d0, x0');
  EmitBranchLabel(done_lbl);

  { x = -1: return -pi/2 }
  EmitLabel(neg_one_lbl);
  { Load -pi/2 = -1.5707963267948966 }
  { IEEE 754: 0xBFF921FB54442D18 }
  WriteLn('    movz x0, #0x2D18');
  WriteLn('    movk x0, #0x5444, lsl #16');
  WriteLn('    movk x0, #0x21FB, lsl #32');
  WriteLn('    movk x0, #0xBFF9, lsl #48');
  { fmov d0, x0 }
  WriteLn('    fmov d0, x0');
  EmitBranchLabel(done_lbl);

  EmitLabel(normal_lbl);
  { Normal Case: arcsin(x) = arctan(x / sqrt(1 - x)) }
  EmitLdurD0(-16);
  { Compute 1 - x }
  { d1 = x }
  WriteLn('    fmul d1, d0, d0');
  { Load 1.0 }
  EmitMovX0(1);
  EmitScvtfD0X0;
  { d0 = 1 - x }
  WriteLn('    fsub d0, d0, d1');

  { d0 = sqrt(1 - x) }
  WriteLn('    fsqrt d0, d0');

  { d0 = x / sqrt(1 - x) }
  WriteLn('    ldur d1, [x29, #-16]');
  WriteLn('    fdiv d0, d1, d0');

  { d0 = arctan(x / sqrt(1 - x)) }
  EmitBL(rt_arctan);

  EmitLabel(done_lbl);
  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;

Procedure EmitArccosRuntime;
Begin
  { arccos(x) = pi/2 - arcsin(x) }
  { Input: d0 = x, Output: d0 = arccos(x) }
  EmitLabel(rt_arccos);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);

  { Compute arcsin(x) }
  EmitBL(rt_arcsin);
  { Save arcsin(x) }
  EmitSturD0(-16);

  { Load pi/2 = 1.5707963267948966 }
  { IEEE 754: 0x3FF921FB54442D18 }
  WriteLn('    movz x0, #0x2D18');
  WriteLn('    movk x0, #0x5444, lsl #16');
  WriteLn('    movk x0, #0x21FB, lsl #32');
  WriteLn('    movk x0, #0x3FF9, lsl #48');
  EmitFmovD0X0;

  { d0 = pi/2 - arcsin(x) }
  EmitLdurD0(-16);
  WriteLn('    fmov d1, d0');
  { Reload pi/2 }
  WriteLn('    movz x0, #0x2D18');
  WriteLn('    movk x0, #0x5444, lsl #16');
  WriteLn('    movk x0, #0x21FB, lsl #32');
  WriteLn('    movk x0, #0x3FF9, lsl #48');
  EmitFmovD0X0;
  { fsub d0, d0, d1 }
  WriteLn('    fsub d0, d0, d1');

  EmitAddSP(16);
  EmitLdp;
  EmitRet
End;

Procedure EmitParamStrRuntime;
Var
  loop_lbl, done_lbl, copy_lbl, copy_done_lbl, empty_lbl: Integer;
Begin
  { paramstr(n) - convert argv[n] To Pascal String }
  { Input: x0 = n (index into argv) }
  { Output: x0 = pointer To Pascal String allocated from heap }
  { Uses x25 = argc, x26 = argv (saved at Program start) }
  { Uses x21 = heap pointer For allocation }
  EmitLabel(rt_paramstr);
  EmitStp;
  EmitMovFP;
  EmitSubSP(32);

  { Allocate String buffer from heap: x8 = x21, x21 += 256 }
  { Save dest addr In x8 }
  WriteLn('    mov x8, x21');
  { Advance heap pointer }
  WriteLn('    add x21, x21, #256');

  done_lbl := NewLabel;
  empty_lbl := NewLabel;
  loop_lbl := NewLabel;
  copy_lbl := NewLabel;
  copy_done_lbl := NewLabel;

  { Check bounds: If n >= argc, return empty String }
  { cmp x0, x25 }
  WriteLn('    cmp x0, x25');
  { b.ge empty }
  Write('    b.ge L'); WriteLn(empty_lbl);

  { Check For negative index }
  { cmp x0, #0 }
  WriteLn('    cmp x0, #0');
  { b.lt empty }
  Write('    b.lt L'); WriteLn(empty_lbl);

  { Load argv[n] pointer: x1 = argv[n] = *(x26 + n*8) }
  { ldr x1, [x26, x0, lsl #3] }
  WriteLn('    ldr x1, [x26, x0, lsl #3]');

  { Check If argv[n] is null }
  { cbz x1, empty }
  Write('    cbz x1, L'); WriteLn(empty_lbl);

  { x1 = pointer To C String, x8 = dest buffer }
  { First count Length (max 255) }
  { mov x2, #0 - Length counter }
  WriteLn('    mov x2, #0');
  { mov x3, x1 - save String pointer }
  WriteLn('    mov x3, x1');

  EmitLabel(loop_lbl);
  { ldrb w4, [x1], #1 - load byte And increment }
  WriteLn('    ldrb w4, [x1], #1');
  { cbz w4, copy_start - If null terminator, start copying }
  Write('    cbz w4, L'); WriteLn(copy_lbl);
  { add x2, x2, #1 - increment Length }
  WriteLn('    add x2, x2, #1');
  { cmp x2, #255 - max Length }
  WriteLn('    cmp x2, #255');
  { b.lt loop }
  Write('    b.lt L'); WriteLn(loop_lbl);

  EmitLabel(copy_lbl);
  { x2 = Length, x3 = source pointer, x8 = dest buffer }
  { Store Length byte at [x8] }
  { strb w2, [x8] }
  WriteLn('    strb w2, [x8]');
  { x0 = x8 + 1 (dest For chars), x1 = x3 (source) }
  WriteLn('    add x0, x8, #1');
  { mov x1, x3 - restore source pointer }
  WriteLn('    mov x1, x3');

  { Copy loop }
  EmitLabel(copy_done_lbl);
  { cbz x2, done - If count = 0, done }
  Write('    cbz x2, L'); WriteLn(done_lbl);
  { ldrb w4, [x1], #1 }
  WriteLn('    ldrb w4, [x1], #1');
  { strb w4, [x0], #1 }
  WriteLn('    strb w4, [x0], #1');
  { sub x2, x2, #1 }
  WriteLn('    sub x2, x2, #1');
  EmitBranchLabel(copy_done_lbl);

  { Empty String: store Length 0 }
  EmitLabel(empty_lbl);
  WriteLn('    strb wzr, [x8]');

  EmitLabel(done_lbl);
  { Return pointer To String buffer (x8) }
  { mov x0, x8 }
  WriteLn('    mov x0, x8');

  EmitAddSP(32);
  EmitLdp;
  EmitRet
End;


{ ----- Parser ----- }

Procedure ParseExpression; Forward;
Procedure ParseStatement; Forward;

Procedure Expect(t: Integer);
Begin
  If tok_type <> t Then
    Error(2);
  NextToken
End;

Function Match(t: Integer): Integer;
Begin
  If tok_type = t Then
  Begin
    NextToken;
    Match := 1
  End
  Else
    Match := 0
End;

Procedure ParseFactor;
Var
  idx, arg_count, i, lbl1, lbl2: Integer;
  var_flags, var_arg_idx: Integer;
Begin
  If tok_type = TOK_INTEGER Then
  Begin
    EmitMovX0(tok_int);
    expr_type := TYPE_INTEGER;
    NextToken
  End
  Else If tok_type = TOK_FLOAT_LITERAL Then
  Begin
    { Construct float at runtime: int_part + frac_part/1000000 }
    { Load Integer part And convert To float }
    EmitMovX0(tok_float_int);
    EmitScvtfD0X0;
    { Load fractional part And convert To float }
    EmitPushD0;
    EmitMovX0(tok_float_frac);
    EmitScvtfD0X0;
    { Divide by 1000000 }
    EmitPushD0;
    EmitMovX0(1000000);
    EmitScvtfD0X0;
    EmitPopD1;
    EmitFDiv;  { d0 = d1 / d0 = frac / 1000000 }
    { Add Integer part }
    EmitPopD1;
    EmitFAdd;  { d0 = d1 + d0 = int + frac }
    expr_type := TYPE_REAL;
    NextToken
  End
  Else If tok_type = TOK_TRUE Then
  Begin
    EmitMovX0(1);
    expr_type := TYPE_INTEGER;
    NextToken
  End
  Else If tok_type = TOK_FALSE Then
  Begin
    EmitMovX0(0);
    expr_type := TYPE_INTEGER;
    NextToken
  End
  Else If tok_type = TOK_LPAREN Then
  Begin
    NextToken;
    ParseExpression;
    Expect(TOK_RPAREN)
    { expr_type is already Set by ParseExpression }
  End
  Else If tok_type = TOK_NOT Then
  Begin
    NextToken;
    ParseFactor;
    EmitEorX0(1);
    expr_type := TYPE_INTEGER  { Not always returns Boolean/int }
  End
  Else If tok_type = TOK_LBRACKET Then
  Begin
    { Set constructor: [1, 3, 5] Or [1..5] Or ['a'..'z'] }
    NextToken;
    EmitMovX0(0);  { start With empty Set }
    If tok_type <> TOK_RBRACKET Then
    Begin
      Repeat
        If tok_type = TOK_COMMA Then NextToken;
        { Save Set so far }
        EmitPushX0;
        { Parse first value }
        ParseExpression;
        If tok_type = TOK_DOTDOT Then
        Begin
          { Range: lo..hi - create mask For all bits from lo To hi }
          EmitPushX0;  { save lo }
          NextToken;
          ParseExpression;  { hi In x0 }
          { x0 = hi, need To Set bits from lo To hi inclusive }
          { Algorithm: create mask With bits Set from lo To hi }
          { For simplicity, use a loop: For i := lo To hi Do Set |= (1 << i) }
          WriteLn('    mov x2, x0');
          EmitPopX1;  { x1 = lo }
          EmitPopX0;  { x0 = Set so far }
          { Loop: While x1 <= x2 Do x0 |= (1 << x1); x1++ }
          lbl1 := NewLabel;
          lbl2 := NewLabel;
          EmitLabel(lbl1);
          { cmp x1, x2 }
          WriteLn('    cmp x1, x2');
          { b.gt done }
          Write('    b.gt L'); WriteLn(lbl2);
          { x3 = 1 << x1 }
          WriteLn('    mov x3, #1');
          WriteLn('    lsl x3, x3, x1');
          { x0 |= x3 }
          WriteLn('    orr x0, x0, x3');
          { x1++ }
          WriteLn('    add x1, x1, #1');
          EmitBranchLabel(lbl1);
          EmitLabel(lbl2)
        End
        Else
        Begin
          { Single element: Set the bit }
          { x0 has the element value, stack has Set so far }
          { mask = 1 << x0, Then Or With saved Set }
          WriteLn('    mov x1, #1');
          WriteLn('    lsl x1, x1, x0');
          EmitPopX0;  { saved Set }
          EmitOrrX0X1  { Set | (1 << element) }
        End
      Until tok_type = TOK_RBRACKET
    End;
    NextToken;
    expr_type := TYPE_SET
  End
  Else If tok_type = TOK_NIL Then
  Begin
    EmitMovX0(0);  { Nil = 0 }
    expr_type := TYPE_POINTER;
    NextToken
  End
  Else If tok_type = TOK_STRING Then
  Begin
    { String literal In expression }
    If tok_len = 1 Then
    Begin
      { Single character - treat as Char/Integer }
      EmitMovX0(tok_str[0]);
      expr_type := TYPE_CHAR
    End
    Else
    Begin
      { Multi-Char String - allocate temp from heap And store String }
      { mov x8, x21 ; store String base To x8 }
      WriteLn('    mov x8, x21');
      { Store Length byte }
      EmitMovX0(tok_len);
      WriteLn('    strb w0, [x8]');
      { Store each character }
      For i := 0 To tok_len - 1 Do
      Begin
        EmitMovX0(tok_str[i]);
        Write('    strb w0, [x8, #'); Write(i + 1); WriteLn(']');
      End;
      { mov x0, x21 ; return String address }
      WriteLn('    mov x0, x21');
      { add x21, x21, #256 ; advance heap pointer }
      WriteLn('    add x21, x21, #256');
      expr_type := TYPE_STRING
    End;
    NextToken
  End
  Else If tok_type = TOK_AT Then
  Begin
    NextToken;
    If tok_type <> TOK_IDENT Then
      Error(6);  { expected identifier }
    idx := SymLookup;
    If idx < 0 Then
      Error(3);  { undefined identifier }
    NextToken;
    If (sym_type[idx] = TYPE_ARRAY) And (tok_type = TOK_LBRACKET) Then
    Begin
      { Address Of Array element: @arr[index] }
      NextToken;  { consume '[' }
      ParseExpression;  { index In x0 }
      Expect(TOK_RBRACKET);
      { Subtract low bound }
      EmitPushX0;
      EmitMovX0(sym_const_val[idx]);  { low bound }
      EmitPopX1;
      { x0 = x1 - x0 = index - low_bound }
      WriteLn('    sub x0, x1, x0');
      { Multiply by 8 (element size) using lsl #3 }
      WriteLn('    lsl x0, x0, #3');
      { Get base address }
      If sym_level[idx] < scope_level Then
      Begin
        EmitFollowChain(sym_level[idx], scope_level);
        EmitSubLargeOffset(1, 8, 0 - sym_offset[idx])
      End
      Else
        EmitSubLargeOffset(1, 29, 0 - sym_offset[idx]);
      { Address = base - element_offset }
      WriteLn('    sub x0, x1, x0');
    End
    Else
      EmitVarAddr(idx, scope_level);
    expr_type := TYPE_POINTER;
    ptr_base_type := sym_type[idx]
  End
  Else If tok_type = TOK_IDENT Then
  Begin
    { Check For built-In functions: ReadChar, keypressed, Ord, Chr }
    { ReadChar = 114,101,97,100,99,104,97,114 }
    If TokIs8(114, 101, 97, 100, 99, 104, 97, 114) = 1 Then
    Begin
      NextToken;
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        Expect(TOK_RPAREN)
      End;
      EmitBL(rt_readchar);
      expr_type := TYPE_INTEGER
    End
    { getinputfd = 103,101,116,105,110,112,117,116,102,100 (10 chars) }
    Else If (tok_len = 10) And (ToLower(tok_str[0]) = 103) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 105) And (ToLower(tok_str[4]) = 110) And
            (ToLower(tok_str[5]) = 112) And (ToLower(tok_str[6]) = 117) And (ToLower(tok_str[7]) = 116) And
            (ToLower(tok_str[8]) = 102) And (ToLower(tok_str[9]) = 100) Then
    Begin
      { getinputfd - returns current input file descriptor (x19) }
      NextToken;
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        Expect(TOK_RPAREN)
      End;
      { mov x0, x19 }
      WriteLn('    mov x0, x19');
      expr_type := TYPE_INTEGER
    End
    { getoutputfd = 103,101,116,111,117,116,112,117,116,102,100 (11 chars) }
    Else If (tok_len = 11) And (ToLower(tok_str[0]) = 103) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 111) And (ToLower(tok_str[4]) = 117) And
            (ToLower(tok_str[5]) = 116) And (ToLower(tok_str[6]) = 112) And (ToLower(tok_str[7]) = 117) And
            (ToLower(tok_str[8]) = 116) And (ToLower(tok_str[9]) = 102) And (ToLower(tok_str[10]) = 100) Then
    Begin
      { getoutputfd - returns current output file descriptor (x20) }
      NextToken;
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        Expect(TOK_RPAREN)
      End;
      { mov x0, x20 }
      WriteLn('    mov x0, x20');
      expr_type := TYPE_INTEGER
    End
    { readfd = 114,101,97,100,102,100 (6 chars) }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 97) And (ToLower(tok_str[3]) = 100) And (ToLower(tok_str[4]) = 102) And
            (ToLower(tok_str[5]) = 100) Then
    Begin
      { readfd(fd) - Read one Char from fd, returns Char Or -1 For EOF }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { x0 = fd, save it Then Do Read syscall }
      { sub sp, sp, #16; str x0, [sp] - allocate buffer And save fd }
      WriteLn('    sub sp, sp, #16');
      { mov x1, sp - buffer on stack }
      WriteLn('    mov x1, sp');
      { mov x2, #1 - Read 1 byte }
      WriteLn('    mov x2, #1');
      { Read syscall: x16 = 0x2000003 }
      WriteLn('    movz x16, #3');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { Check If Read returned >= 1 }
      { cmp x0, #1; b.ge got_char; mov x0, #-1; b done; got_char: ldrb w0, [sp]; done: }
      WriteLn('    cmp x0, #1');
      Write('    b.ge L'); WriteLn(label_count);
      EmitMovX0(-1);
      EmitBranchLabel(label_count + 1);
      EmitLabel(label_count);
      label_count := label_count + 1;
      { ldrb w0, [sp] }
      WriteLn('    ldrb w0, [sp]');
      EmitLabel(label_count);
      label_count := label_count + 1;
      { add sp, sp, #16 - restore stack }
      WriteLn('    add sp, sp, #16');
      expr_type := TYPE_INTEGER
    End
    { openfile = 111,112,101,110,102,105,108,101 (8 chars) }
    Else If TokIs8(111, 112, 101, 110, 102, 105, 108, 101) = 1 Then
    Begin
      { openfile(filename) - open file For reading, returns fd Or -1 on error }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { x0 = Pascal String address, need To skip Length byte For C String }
      { add x0, x0, #1 }
      WriteLn('    add x0, x0, #1');
      { open syscall: x0=path, x1=O_RDONLY(0), x2=mode(0) }
      WriteLn('    mov x1, #0');
      WriteLn('    mov x2, #0');
      { movz x16, #5; movk x16, #0x200, lsl #16 = 0x2000005 }
      WriteLn('    movz x16, #5');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { On macOS, carry flag Set on error - convert errno To -1 }
      { b.cc skip; mov x0, #-1; skip: }
      Write('    b.cc L'); WriteLn(label_count);
      EmitMovX0(-1);
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_INTEGER
    End
    { createfile = 99,114,101,97,116,101,102,105,108,101 (10 chars) }
    Else If (tok_len = 10) And (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 101) And (ToLower(tok_str[3]) = 97) And (ToLower(tok_str[4]) = 116) And
            (ToLower(tok_str[5]) = 101) And (ToLower(tok_str[6]) = 102) And (ToLower(tok_str[7]) = 105) And
            (ToLower(tok_str[8]) = 108) And (ToLower(tok_str[9]) = 101) Then
    Begin
      { createfile(filename) - create/open file For writing, returns fd Or -1 }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { x0 = Pascal String address, need To skip Length byte For C String }
      { add x0, x0, #1 }
      WriteLn('    add x0, x0, #1');
      { open syscall: x0=path, x1=O_WRONLY|O_CREAT|O_TRUNC(1537), x2=mode(420=0644) }
      { mov x1, #1537 }
      WriteLn('    mov x1, #1537');
      { mov x2, #420 }
      WriteLn('    mov x2, #420');
      { movz x16, #5; movk x16, #0x200, lsl #16 = 0x2000005 }
      WriteLn('    movz x16, #5');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { On macOS, carry flag Set on error - convert errno To -1 }
      Write('    b.cc L'); WriteLn(label_count);
      EmitMovX0(-1);
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_INTEGER
    End
    { keypressed = 107,101,121,112,114,101,115,115,101,100 (10 chars) }
    Else If (tok_len = 10) And (ToLower(tok_str[0]) = 107) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 121) And (ToLower(tok_str[3]) = 112) And (ToLower(tok_str[4]) = 114) And
            (ToLower(tok_str[5]) = 101) And (ToLower(tok_str[6]) = 115) And (ToLower(tok_str[7]) = 115) And
            (ToLower(tok_str[8]) = 101) And (ToLower(tok_str[9]) = 100) Then
    Begin
      NextToken;
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        Expect(TOK_RPAREN)
      End;
      EmitBL(rt_keypressed);
      expr_type := TYPE_BOOLEAN
    End
    { Ord = 111,114,100 }
    Else If TokIs8(111, 114, 100, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Ord() is identity For integers/chars }
      expr_type := TYPE_INTEGER
    End
    { Chr = 99,104,114 }
    Else If TokIs8(99, 104, 114, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Chr() is identity For integers/chars }
      expr_type := TYPE_INTEGER
    End
    { abs = 97,98,115 }
    Else If TokIs8(97, 98, 115, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { If x < 0, negate it }
      { cmp x0, #0; b.ge skip; neg x0, x0; skip: }
      WriteLn('    cmp x0, #0');
      Write('    b.ge L'); WriteLn(label_count);
      WriteLn('    neg x0, x0');
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_INTEGER
    End
    { odd = 111,100,100 }
    Else If TokIs8(111, 100, 100, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x And 1 }
      WriteLn('    And x0, x0, #1');
      expr_type := TYPE_BOOLEAN
    End
    { sqr = 115,113,114 }
    Else If TokIs8(115, 113, 114, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x * x }
      WriteLn('    mul x0, x0, x0');
      expr_type := TYPE_INTEGER
    End
    { sqrt = 115,113,114,116 }
    Else If TokIs8(115, 113, 114, 116, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Convert To Real If Integer }
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { fsqrt d0, d0 }
      WriteLn('    fsqrt d0, d0');
      expr_type := TYPE_REAL
    End
    { round = 114,111,117,110,100 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 117) And (ToLower(tok_str[3]) = 110) And (ToLower(tok_str[4]) = 100) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Convert To Real If Integer }
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { fcvtas x0, d0 - round To nearest With ties To away }
      WriteLn('    fcvtas x0, d0');
      expr_type := TYPE_INTEGER
    End
    { trunc = 116,114,117,110,99 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 117) And (ToLower(tok_str[3]) = 110) And (ToLower(tok_str[4]) = 99) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Convert To Real If Integer }
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { fcvtzs x0, d0 - truncate toward zero }
      WriteLn('    fcvtzs x0, d0');
      expr_type := TYPE_INTEGER
    End
    { sin = 115,105,110 }
    Else If TokIs8(115, 105, 110, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_sin);
      expr_type := TYPE_REAL
    End
    { cos = 99,111,115 }
    Else If TokIs8(99, 111, 115, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_cos);
      expr_type := TYPE_REAL
    End
    { tan = 116,97,110 }
    Else If TokIs8(116, 97, 110, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_tan);
      expr_type := TYPE_REAL
    End
    { exp = 101,120,112 }
    Else If TokIs8(101, 120, 112, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_exp);
      expr_type := TYPE_REAL
    End
    { ln = 108,110 }
    Else If (tok_len = 2) And (ToLower(tok_str[0]) = 108) And (ToLower(tok_str[1]) = 110) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_ln);
      expr_type := TYPE_REAL
    End
    { random = 114,97,110,100,111,109 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 97) And
            (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 100) And (ToLower(tok_str[4]) = 111) And
            (ToLower(tok_str[5]) = 109) Then
    Begin
      NextToken;
      If tok_type = TOK_LPAREN Then
      Begin
        { random(n) - returns 0..n-1 }
        NextToken;
        If tok_type <> TOK_RPAREN Then
        Begin
          ParseExpression;
          EmitPushX0;
          EmitBL(rt_random);
          EmitPopX1;
          { x0 Mod x1 using udiv And msub }
          WriteLn('    udiv x2, x0, x1');
          WriteLn('    msub x0, x2, x1, x0');
        End
        Else
        Begin
          { random() With no arg - return Real 0.0..1.0 }
          EmitBL(rt_random);
          { Convert To Real And divide by 2^64 }
          EmitScvtfD0X0;
          { Load 2^63 as divisor (since signed, use 2^63) }
          WriteLn('    movz x1, #0x8000, lsl #48');
          WriteLn('    scvtf d1, x1');
          WriteLn('    fdiv d0, d0, d1');
          { Make positive by using fabs }
          WriteLn('    fabs d0, d0');
          expr_type := TYPE_REAL
        End;
        Expect(TOK_RPAREN)
      End
      Else
      Begin
        { random With no parens - return Real 0.0..1.0 }
        EmitBL(rt_random);
        EmitScvtfD0X0;
        WriteLn('    movz x1, #0x8000, lsl #48');
        WriteLn('    scvtf d1, x1');
        WriteLn('    fdiv d0, d0, d1');
        WriteLn('    fabs d0, d0');
        expr_type := TYPE_REAL
      End;
      If expr_type <> TYPE_REAL Then
        expr_type := TYPE_INTEGER
    End
    { pi = 112,105 - returns 3.14159265358979 }
    Else If (tok_len = 2) And (ToLower(tok_str[0]) = 112) And (ToLower(tok_str[1]) = 105) Then
    Begin
      NextToken;
      { Load pi = 3.14159265358979323846 into d0 }
      { IEEE 754 double: 0x400921FB54442D18 }
      WriteLn('    movz x0, #0x2D18');
      WriteLn('    movk x0, #0x5444, lsl #16');
      WriteLn('    movk x0, #0x21FB, lsl #32');
      WriteLn('    movk x0, #0x4009, lsl #48');
      EmitFmovD0X0;
      expr_type := TYPE_REAL
    End
    { frac = 102,114,97,99 - fractional part }
    Else If TokIs8(102, 114, 97, 99, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { frac(x) = x - trunc(x) }
      { Save x To stack }
      EmitPushD0;
      { Truncate To Integer }
      EmitFcvtzsX0D0;
      { Convert back To float }
      EmitScvtfD0X0;
      { Pop original, now d1 = trunc(x) }
      WriteLn('    fmov d1, d0');
      EmitPopD0;
      { d0 = x - trunc(x) }
      WriteLn('    fsub d0, d0, d1');
      expr_type := TYPE_REAL
    End
    { int = 105,110,116 - Integer part as Real (different from trunc) }
    Else If TokIs8(105, 110, 116, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { int(x) = trunc(x) as float }
      { frintz d0, d0 - round toward zero (truncate) }
      WriteLn('    frintz d0, d0');
      expr_type := TYPE_REAL
    End
    { arctan = 97,114,99,116,97,110 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 97) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 99) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 97) And
            (ToLower(tok_str[5]) = 110) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_arctan);
      expr_type := TYPE_REAL
    End
    { arcsin = 97,114,99,115,105,110 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 97) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 99) And (ToLower(tok_str[3]) = 115) And (ToLower(tok_str[4]) = 105) And
            (ToLower(tok_str[5]) = 110) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_arcsin);
      expr_type := TYPE_REAL
    End
    { arccos = 97,114,99,99,111,115 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 97) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 99) And (ToLower(tok_str[3]) = 99) And (ToLower(tok_str[4]) = 111) And
            (ToLower(tok_str[5]) = 115) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitBL(rt_arccos);
      expr_type := TYPE_REAL
    End
    { log10 = 108,111,103,49,48 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 108) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 103) And (ToLower(tok_str[3]) = 49) And (ToLower(tok_str[4]) = 48) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { log10(x) = ln(x) / ln(10) }
      EmitBL(rt_ln);
      EmitPushD0;
      { Load ln(10) = 2.302585... into d0 }
      WriteLn('    movz x0, #0x634A');
      WriteLn('    movk x0, #0x9BFE, lsl #16');
      WriteLn('    movk x0, #0x66D3, lsl #32');
      WriteLn('    movk x0, #0x4002, lsl #48');
      EmitFmovD0X0;
      EmitPopD1;
      { d0 = ln(x) / ln(10) }
      WriteLn('    fdiv d0, d1, d0');
      expr_type := TYPE_REAL
    End
    { log2 = 108,111,103,50 }
    Else If TokIs8(108, 111, 103, 50, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { log2(x) = ln(x) / ln(2) }
      EmitBL(rt_ln);
      EmitPushD0;
      { Load ln(2) = 0.693147... into d0 }
      WriteLn('    movz x0, #0x39EF');
      WriteLn('    movk x0, #0xFEFA, lsl #16');
      WriteLn('    movk x0, #0x2E42, lsl #32');
      WriteLn('    movk x0, #0x3FE6, lsl #48');
      EmitFmovD0X0;
      EmitPopD1;
      { d0 = ln(x) / ln(2) }
      WriteLn('    fdiv d0, d1, d0');
      expr_type := TYPE_REAL
    End
    { power = 112,111,119,101,114 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 112) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 119) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 114) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;  { base }
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      EmitPushD0;
      Expect(TOK_COMMA);
      ParseExpression;  { exponent }
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;
      { d0 = exp, stack has base }
      { power(b, e) = exp(e * ln(b)) }
      { Move exp To d1, get base To d0, save exp on stack }
      EmitPushD0;       { stack = [exp, base] }
      EmitPopD1;        { d1 = exp, stack = [base] }
      EmitPopD0;        { d0 = base, stack = [] }
      { Push d1 (exp) To stack - str d1, [sp, #-16]! }
      WriteLn('    str d1, [sp, #-16]!');
      { d0 = base, stack = [exp] }
      EmitBL(rt_ln);    { d0 = ln(base), stack = [exp] }
      EmitPopD1;        { d1 = exp, stack = [] }
      { fmul d0, d0, d1 - d0 = ln(base) * exp }
      WriteLn('    fmul d0, d0, d1');
      EmitBL(rt_exp);   { d0 = exp(ln(base) * exp) = base^exp }
      Expect(TOK_RPAREN);
      expr_type := TYPE_REAL
    End
    { succ = 115,117,99,99 }
    Else If TokIs8(115, 117, 99, 99, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x + 1 }
      WriteLn('    add x0, x0, #1');
      expr_type := TYPE_INTEGER
    End
    { pred = 112,114,101,100 }
    Else If TokIs8(112, 114, 101, 100, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { Return x - 1 }
      WriteLn('    sub x0, x0, #1');
      expr_type := TYPE_INTEGER
    End
    { SizeOf = 115,105,122,101,111,102 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 105) And
            (ToLower(tok_str[2]) = 122) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 111) And
            (ToLower(tok_str[5]) = 102) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      { Check For Type name Or variable }
      If tok_type = TOK_INTEGER_TYPE Then
      Begin
        EmitMovX0(8);
        NextToken
      End
      Else If tok_type = TOK_CHAR_TYPE Then
      Begin
        EmitMovX0(1);
        NextToken
      End
      Else If tok_type = TOK_BOOLEAN_TYPE Then
      Begin
        EmitMovX0(1);
        NextToken
      End
      Else If tok_type = TOK_REAL_TYPE Then
      Begin
        EmitMovX0(8);
        NextToken
      End
      Else If tok_type = TOK_STRING_TYPE Then
      Begin
        EmitMovX0(256);
        NextToken
      End
      Else If tok_type = TOK_IDENT Then
      Begin
        { Look up identifier - could be variable Or Type name }
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_kind[idx] = SYM_TYPEDEF Then
        Begin
          { Type definition - get size from sym_label (Record size) }
          EmitMovX0(sym_label[idx])
        End
        Else If sym_type[idx] = TYPE_INTEGER Then
          EmitMovX0(8)
        Else If sym_type[idx] = TYPE_CHAR Then
          EmitMovX0(1)  { Logical size, Not storage size }
        Else If sym_type[idx] = TYPE_BOOLEAN Then
          EmitMovX0(1)  { Logical size, Not storage size }
        Else If sym_type[idx] = TYPE_REAL Then
          EmitMovX0(8)
        Else If sym_type[idx] = TYPE_STRING Then
          EmitMovX0(256)
        Else If sym_type[idx] = TYPE_POINTER Then
          EmitMovX0(8)
        Else If sym_type[idx] = TYPE_ARRAY Then
        Begin
          { Array: sym_label already contains total size In bytes }
          EmitMovX0(sym_label[idx])
        End
        Else If sym_type[idx] = TYPE_RECORD Then
        Begin
          { Record: sym_const_val has typedef index, get size from typedef's sym_label }
          EmitMovX0(sym_label[sym_const_val[idx]])
        End
        Else
          EmitMovX0(8);  { Default To 8 bytes }
        NextToken
      End
      Else
        Error(9);
      Expect(TOK_RPAREN);
      expr_type := TYPE_INTEGER
    End
    { upcase = 117,112,99,97,115,101 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 117) And (ToLower(tok_str[1]) = 112) And
            (ToLower(tok_str[2]) = 99) And (ToLower(tok_str[3]) = 97) And (ToLower(tok_str[4]) = 115) And
            (ToLower(tok_str[5]) = 101) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { If Char is 'a'-'z' (97-122), subtract 32 }
      { cmp x0, #97; b.lt skip; cmp x0, #122; b.gt skip; sub x0, x0, #32; skip: }
      WriteLn('    cmp x0, #97');
      Write('    b.lt L'); WriteLn(label_count);
      WriteLn('    cmp x0, #122');
      Write('    b.gt L'); WriteLn(label_count);
      WriteLn('    sub x0, x0, #32');
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_CHAR
    End
    { lowercase = 108,111,119,101,114,99,97,115,101 }
    Else If (tok_len = 9) And (ToLower(tok_str[0]) = 108) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 119) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 114) And
            (ToLower(tok_str[5]) = 99) And (ToLower(tok_str[6]) = 97) And (ToLower(tok_str[7]) = 115) And
            (ToLower(tok_str[8]) = 101) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { If Char is 'A'-'Z' (65-90), add 32 }
      { cmp x0, #65; b.lt skip; cmp x0, #90; b.gt skip; add x0, x0, #32; skip: }
      WriteLn('    cmp x0, #65');
      Write('    b.lt L'); WriteLn(label_count);
      WriteLn('    cmp x0, #90');
      Write('    b.gt L'); WriteLn(label_count);
      WriteLn('    add x0, x0, #32');
      EmitLabel(label_count);
      label_count := label_count + 1;
      expr_type := TYPE_CHAR
    End
    { Length = 108,101,110,103,116,104 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 108) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 103) And (ToLower(tok_str[4]) = 116) And
            (ToLower(tok_str[5]) = 104) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type = TOK_STRING Then
      Begin
        { String literal - emit constant Length }
        EmitMovX0(tok_len);
        NextToken
      End
      Else If tok_type = TOK_IDENT Then
      Begin
        { Must be a String variable }
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        { Load String address }
        EmitVarAddr(idx, scope_level);
        { Load Length byte from [x0] }
        WriteLn('    ldrb w0, [x0]');
      End
      Else
        Error(9);
      Expect(TOK_RPAREN);
      expr_type := TYPE_INTEGER
    End
    { eof = 101,111,102 }
    Else If (tok_len = 3) And (ToLower(tok_str[0]) = 101) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 102) Then
    Begin
      { eof(f) - check If at End Of file }
      { Uses lseek To compare current position With file size }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Get file fd And save For later }
      EmitVarAddr(idx, scope_level);
      { ldr x0, [x0] - load fd }
      WriteLn('    ldr x0, [x0]');
      { Save fd To x23 (callee-saved) }
      WriteLn('    mov x23, x0');
      { lseek(fd, 0, SEEK_CUR=1) To get current position }
      WriteLn('    mov x1, #0');
      WriteLn('    mov x2, #1');
      { lseek syscall: 0x20000C7 }
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { x0 = current position, save To x24 }
      WriteLn('    mov x24, x0');
      { lseek(fd, 0, SEEK_END=2) To get file size }
      WriteLn('    mov x0, x23');
      WriteLn('    mov x1, #0');
      WriteLn('    mov x2, #2');
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { x0 = file size, x24 = current position }
      { Restore file position: lseek(fd, current_pos, SEEK_SET=0) }
      WriteLn('    mov x25, x0');
      WriteLn('    mov x0, x23');
      WriteLn('    mov x1, x24');
      WriteLn('    mov x2, #0');
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { Compare: x24 = current_pos, x25 = file_size }
      { cmp x24, x25 }
      WriteLn('    cmp x24, x25');
      { cset x0, ge - x0 = 1 If current_pos >= file_size }
      WriteLn('    cset x0, ge');
      expr_type := TYPE_BOOLEAN
    End
    { filepos = 102,105,108,101,112,111,115 }
    Else If (tok_len = 7) And (ToLower(tok_str[0]) = 102) And (ToLower(tok_str[1]) = 105) And
            (ToLower(tok_str[2]) = 108) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 112) And
            (ToLower(tok_str[5]) = 111) And (ToLower(tok_str[6]) = 115) Then
    Begin
      { filepos(f) - get current position In file }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Get file fd }
      EmitVarAddr(idx, scope_level);
      { ldr x0, [x0] - load fd }
      WriteLn('    ldr x0, [x0]');
      { lseek(fd, 0, SEEK_CUR=1) To get current position }
      WriteLn('    mov x1, #0');
      WriteLn('    mov x2, #1');
      { lseek syscall: 0x20000C7 }
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { x0 = current position }
      expr_type := TYPE_INTEGER
    End
    { filesize = 102,105,108,101,115,105,122,101 }
    Else If (tok_len = 8) And (ToLower(tok_str[0]) = 102) And (ToLower(tok_str[1]) = 105) And
            (ToLower(tok_str[2]) = 108) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 115) And
            (ToLower(tok_str[5]) = 105) And (ToLower(tok_str[6]) = 122) And (ToLower(tok_str[7]) = 101) Then
    Begin
      { filesize(f) - get file size }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Get file fd And save For later }
      EmitVarAddr(idx, scope_level);
      { ldr x0, [x0] - load fd }
      WriteLn('    ldr x0, [x0]');
      { Save fd To x23 }
      WriteLn('    mov x23, x0');
      { lseek(fd, 0, SEEK_CUR=1) To get current position (To restore later) }
      WriteLn('    mov x1, #0');
      WriteLn('    mov x2, #1');
      { lseek syscall: 0x20000C7 }
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { x0 = current position, save To x24 }
      WriteLn('    mov x24, x0');
      { lseek(fd, 0, SEEK_END=2) To get file size }
      WriteLn('    mov x0, x23');
      WriteLn('    mov x1, #0');
      WriteLn('    mov x2, #2');
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { x0 = file size, save To x25 }
      WriteLn('    mov x25, x0');
      { Restore file position: lseek(fd, current_pos, SEEK_SET=0) }
      WriteLn('    mov x0, x23');
      WriteLn('    mov x1, x24');
      WriteLn('    mov x2, #0');
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { Move file size To x0 as return value }
      WriteLn('    mov x0, x25');
      expr_type := TYPE_INTEGER
    End
    { copy = 99,111,112,121 }
    Else If (tok_len = 4) And (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 112) And (ToLower(tok_str[3]) = 121) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: source String }
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { source addr In x0 }
        EmitPushX0
      End
      Else
        Error(9);
      Expect(TOK_COMMA);
      { Second arg: start index }
      ParseExpression;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Third arg: count }
      ParseExpression;  { count In x0 }
      { x0 = count, x1 = start, x2 = source addr }
      WriteLn('    mov x3, x0');
      EmitPopX1;  { start }
      EmitPopX0;  { source addr -> x2 }
      WriteLn('    mov x2, x0');
      { Allocate temp String from heap: x0 = x21, x21 += 256 }
      WriteLn('    mov x0, x21');
      WriteLn('    add x21, x21, #256');
      { Save dest addr }
      EmitPushX0;
      { Inline copy logic: copy from source[start] To dest, count bytes }
      { x0 = dest, x1 = start, x2 = source, x3 = count }
      { Store count as Length at dest[0] }
      WriteLn('    strb w3, [x0]');
      { Loop: copy count bytes from source[start+i] To dest[1+i] }
      lbl1 := NewLabel;
      WriteLn('    mov x4, #0');
      EmitLabel(lbl1);
      { cmp x4, x3 }
      WriteLn('    cmp x4, x3');
      { b.ge done }
      Write('    b.ge L'); WriteLn(label_count);
      { x5 = start + x4 (source index) }
      WriteLn('    add x5, x1, x4');
      { ldrb w6, [x2, x5] }
      WriteLn('    ldrb w6, [x2, x5]');
      { x5 = x4 + 1 (dest index) }
      WriteLn('    add x5, x4, #1');
      { strb w6, [x0, x5] }
      WriteLn('    strb w6, [x0, x5]');
      { x4 = x4 + 1 }
      WriteLn('    add x4, x4, #1');
      EmitBranchLabel(lbl1);
      EmitLabel(label_count);
      label_count := label_count + 1;
      { Restore dest addr To x0 }
      EmitPopX0;
      Expect(TOK_RPAREN);
      expr_type := TYPE_STRING
    End
    { concat = 99,111,110,99,97,116 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 99) And (ToLower(tok_str[4]) = 97) And
            (ToLower(tok_str[5]) = 116) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      { First String }
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { string1 addr In x0 }
        EmitPushX0
      End
      Else
        Error(9);
      Expect(TOK_COMMA);
      { Second String }
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { string2 addr In x0 }
        { x0 = string2, stack top = string1 }
        WriteLn('    mov x2, x0');
        EmitPopX1;  { string1 }
      End
      Else
        Error(9);
      { Allocate temp String from heap: x0 = x21, x21 += 256 }
      WriteLn('    mov x0, x21');
      WriteLn('    add x21, x21, #256');
      { Call rt_str_concat(x0=dest, x1=str1, x2=str2) }
      EmitBL(rt_str_concat);
      Expect(TOK_RPAREN);
      expr_type := TYPE_STRING
    End
    { trim = 116,114,105,109 }
    Else If (tok_len = 4) And (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 109) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      End
      Else
        Error(9);
      Expect(TOK_RPAREN);
      EmitBL(rt_str_trim);
      expr_type := TYPE_STRING
    End
    { ltrim = 108,116,114,105,109 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 108) And (ToLower(tok_str[1]) = 116) And
            (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 105) And (ToLower(tok_str[4]) = 109) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      End
      Else
        Error(9);
      Expect(TOK_RPAREN);
      EmitBL(rt_str_ltrim);
      expr_type := TYPE_STRING
    End
    { rtrim = 114,116,114,105,109 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 116) And
            (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 105) And (ToLower(tok_str[4]) = 109) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      End
      Else
        Error(9);
      Expect(TOK_RPAREN);
      EmitBL(rt_str_rtrim);
      expr_type := TYPE_STRING
    End
    { pos = 112,111,115 }
    Else If (tok_len = 3) And (ToLower(tok_str[0]) = 112) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 115) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: substring }
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);
        EmitPushX0
      End
      Else If tok_type = TOK_STRING Then
      Begin
        { String literal - allocate temp on heap }
        WriteLn('    mov x8, x21');
        EmitMovX0(tok_len);
        WriteLn('    strb w0, [x8]');
        For i := 0 To tok_len - 1 Do
        Begin
          EmitMovX0(tok_str[i]);
          Write('    strb w0, [x8, #'); Write(i + 1); WriteLn(']');
        End;
        WriteLn('    mov x0, x21');
        WriteLn('    add x21, x21, #256');
        EmitPushX0;
        NextToken
      End
      Else
        Error(9);
      Expect(TOK_COMMA);
      { Second arg: String To search In }
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);  { String addr In x0 }
        { mov x1, x0; pop x0 }
        WriteLn('    mov x1, x0');
        EmitPopX0  { substr In x0 }
      End
      Else
        Error(9);
      { Call rt_str_pos(x0=substr, x1=String) }
      EmitBL(rt_str_pos);
      Expect(TOK_RPAREN);
      expr_type := TYPE_INTEGER
    End
    { paramcount = 112,97,114,97,109,99,111,117,110,116 }
    Else If (tok_len = 10) And (ToLower(tok_str[0]) = 112) And (ToLower(tok_str[1]) = 97) And
            (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 97) And (ToLower(tok_str[4]) = 109) And
            (ToLower(tok_str[5]) = 99) And (ToLower(tok_str[6]) = 111) And (ToLower(tok_str[7]) = 117) And
            (ToLower(tok_str[8]) = 110) And (ToLower(tok_str[9]) = 116) Then
    Begin
      { paramcount - returns argc - 1 (number Of command-line parameters) }
      NextToken;
      { x25 holds argc, return argc - 1 }
      WriteLn('    sub x0, x25, #1');
      expr_type := TYPE_INTEGER
    End
    { paramstr = 112,97,114,97,109,115,116,114 }
    Else If (tok_len = 8) And (ToLower(tok_str[0]) = 112) And (ToLower(tok_str[1]) = 97) And
            (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 97) And (ToLower(tok_str[4]) = 109) And
            (ToLower(tok_str[5]) = 115) And (ToLower(tok_str[6]) = 116) And (ToLower(tok_str[7]) = 114) Then
    Begin
      { paramstr(n) - returns argv[n] as Pascal String }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;  { n In x0 }
      Expect(TOK_RPAREN);
      EmitBL(rt_paramstr);
      expr_type := TYPE_STRING
    End
    Else
    Begin
      { Check For With context - try To find identifier as a field }
      If with_rec_idx >= 0 Then
      Begin
        arg_count := FindField(with_rec_type);  { reuse arg_count For field_idx }
        If arg_count >= 0 Then
        Begin
          { Found field - generate access code }
          NextToken;
          { Compute address: base + field_offset }
          If sym_level[with_rec_idx] < scope_level Then
          Begin
            EmitFollowChain(sym_level[with_rec_idx], scope_level);
            { add x0, x8, #sym_offset + field_offset }
            WriteLn('    add x0, x8, #');
          End
          Else
          Begin
            { add x0, x29, #sym_offset + field_offset }
            WriteLn('    add x0, x29, #');
          End;
          { Load from computed address }
          If field_type[arg_count] = TYPE_REAL Then
          Begin
            WriteLn('    ldr d0, [x0]');
            expr_type := TYPE_REAL
          End
          Else
          Begin
            WriteLn('    ldr x0, [x0]');
            expr_type := field_type[arg_count]
          End
        End
        Else
        Begin
          { Field Not found, proceed With normal lookup }
          idx := SymLookup;
          If idx < 0 Then
            Error(3);  { undefined identifier }
          { Continue With the normal identifier handling below }
        End
      End
      Else
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);  { undefined identifier }
      End;
      { Skip If we already handled With field }
      If (with_rec_idx < 0) Or (arg_count < 0) Then
      Begin
      NextToken;
      If sym_kind[idx] = SYM_CONST Then
      Begin
        EmitMovX0(sym_const_val[idx]);
        expr_type := TYPE_INTEGER
      End
      Else If (sym_kind[idx] = SYM_VAR) Or (sym_kind[idx] = SYM_PARAM) Then
      Begin
        If (sym_type[idx] = TYPE_ARRAY) And (tok_type = TOK_LBRACKET) Then
        Begin
          { Array element access: arr[index] Or arr[index].field }
          NextToken;  { consume '[' }
          ParseExpression;  { index In x0 }
          Expect(TOK_RBRACKET);
          { Subtract low bound }
          EmitPushX0;
          EmitMovX0(sym_const_val[idx]);  { low bound }
          EmitPopX1;
          { x0 = x1 - x0 = index - low_bound }
          WriteLn('    sub x0, x1, x0');
          { Check If Array Of records }
          If sym_var_param_flags[idx] > 0 Then
          Begin
            { Array Of records - multiply by Record size }
            lbl1 := sym_label[sym_var_param_flags[idx] - 1];  { Record size }
            EmitPushX0;
            EmitMovX0(lbl1);
            EmitPopX1;
            { mul x0, x1, x0 }
            WriteLn('    mul x0, x1, x0');
          End
          Else
          Begin
            { Basic Type - multiply by 8 using lsl #3 }
            WriteLn('    lsl x0, x0, #3');
          End;
          { Get base address: frame + offset (offset is negative) }
          If sym_level[idx] < scope_level Then
          Begin
            EmitFollowChain(sym_level[idx], scope_level);
            EmitSubLargeOffset(1, 8, 0 - sym_offset[idx])
          End
          Else
            EmitSubLargeOffset(1, 29, 0 - sym_offset[idx]);
          { Compute element address: x1 - x0 }
          WriteLn('    sub x1, x1, x0');
          { Check For field access on Array Of records }
          If (sym_var_param_flags[idx] > 0) And (tok_type = TOK_DOT) Then
          Begin
            NextToken;  { consume '.' }
            arg_count := FindField(sym_var_param_flags[idx] - 1);
            If arg_count < 0 Then
              Error(11);
            NextToken;  { consume field name }
            { Add field offset: x1 = x1 + offset }
            If field_offset[arg_count] > 0 Then
            Begin
              WriteLn('    add x1, x1, #');
            End;
            { Load field value }
            If field_type[arg_count] = TYPE_REAL Then
            Begin
              WriteLn('    ldr d0, [x1]');
              expr_type := TYPE_REAL
            End
            Else
            Begin
              WriteLn('    ldr x0, [x1]');
              expr_type := field_type[arg_count]
            End
          End
          Else
          Begin
            { Load element value }
            WriteLn('    ldr x0, [x1]');
          End
        End
        Else If (sym_type[idx] = TYPE_RECORD) And (tok_type = TOK_DOT) Then
        Begin
          { Record field access: rec.field Or rec.field.subfield... }
          NextToken;  { consume '.' }
          If tok_type <> TOK_IDENT Then
            Error(11);
          { Find the field In the Record Type }
          arg_count := FindField(sym_const_val[idx]);  { reuse arg_count For field_idx }
          If arg_count < 0 Then
            Error(15);  { undefined field }
          { Compute address: base + field_offset }
          { Base is at [x29 + sym_offset] For local, field at positive offset from there }
          If sym_level[idx] < scope_level Then
          Begin
            EmitFollowChain(sym_level[idx], scope_level);
            { add x0, x8, #sym_offset + field_offset }
            WriteLn('    add x0, x8, #');
          End
          Else
          Begin
            { add x0, x29, #sym_offset + field_offset }
            WriteLn('    add x0, x29, #');
          End;
          NextToken;
          { Handle nested Record fields: x0 has address, check For more dots }
          While (field_type[arg_count] = TYPE_RECORD) And (tok_type = TOK_DOT) Do
          Begin
            NextToken;  { consume '.' }
            If tok_type <> TOK_IDENT Then
              Error(11);
            { Find sub-field In the nested Record Type }
            lbl1 := arg_count;  { save current field index }
            arg_count := FindField(field_rec_type[lbl1]);
            If arg_count < 0 Then
              Error(15);
            { Add sub-field offset To x0 }
            If field_offset[arg_count] > 0 Then
            Begin
              WriteLn('    add x0, x0, #');
            End;
            NextToken
          End;
          { Load from final computed address }
          If field_type[arg_count] = TYPE_REAL Then
          Begin
            WriteLn('    ldr d0, [x0]');
            expr_type := TYPE_REAL
          End
          Else If field_type[arg_count] = TYPE_RECORD Then
          Begin
            { Accessing a nested Record as a whole - keep address In x0 }
            expr_type := TYPE_RECORD
          End
          Else
          Begin
            WriteLn('    ldr x0, [x0]');
            expr_type := field_type[arg_count]
          End
        End
        Else
        Begin
          { Load variable value - check For Var param And Type }
          If sym_type[idx] = TYPE_REAL Then
          Begin
            If sym_level[idx] < scope_level Then
              EmitLdurD0Outer(sym_offset[idx], sym_level[idx], scope_level)
            Else
              EmitLdurD0(sym_offset[idx]);
            { If Var param, d0 contains address - dereference it }
            If sym_is_var_param[idx] = 1 Then
            Begin
              { fmov x0, d0; ldr d0, [x0] }
              EmitFmovX0D0;
              WriteLn('    ldr d0, [x0]');
            End;
            expr_type := TYPE_REAL
          End
          Else If sym_type[idx] = TYPE_STRING Then
          Begin
            { For strings, emit the address (strings are pass-by-reference) }
            EmitVarAddr(idx, scope_level);
            expr_type := TYPE_STRING;
            { Check For String indexing s[i] }
            If tok_type = TOK_LBRACKET Then
            Begin
              NextToken;  { consume '[' }
              EmitPushX0;  { save String base address }
              ParseExpression;  { index In x0 }
              Expect(TOK_RBRACKET);
              { x0 = index, stack has base address }
              EmitPopX1;  { x1 = base address }
              { Add index To base: x0 = x1 + x0 }
              WriteLn('    add x0, x1, x0');
              { Load byte at [x0]: ldrb w0, [x0] }
              WriteLn('    ldrb w0, [x0]');
              expr_type := TYPE_CHAR
            End
          End
          Else
          Begin
            If sym_level[idx] < scope_level Then
              EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            Else
              EmitLdurX0(sym_offset[idx]);
            { If Var param, x0 now contains address - dereference it }
            If sym_is_var_param[idx] = 1 Then
            Begin
              WriteLn('    ldr x0, [x0]');
            End;
            expr_type := sym_type[idx]
          End
        End;
        { Track pointer base Type If this is a pointer }
        If sym_type[idx] = TYPE_POINTER Then
          ptr_base_type := sym_const_val[idx];
        { Check For pointer dereference }
        If (sym_type[idx] = TYPE_POINTER) And (tok_type = TOK_CARET) Then
        Begin
          { Count consecutive ^ tokens }
          lbl1 := 0;  { deref count }
          While tok_type = TOK_CARET Do
          Begin
            lbl1 := lbl1 + 1;
            NextToken
          End;
          { lbl2 = remaining depth after derefs }
          lbl2 := ptr_depth[idx] - lbl1;
          { Emit dereference operations }
          { For pointer-To-Array, don't emit final deref - Array base is the pointer value }
          { For pointer-To-Record With field access, don't emit final deref - Record base is the pointer value }
          If (lbl2 = 0) And (ptr_ultimate_type[idx] = TYPE_ARRAY) Then
            arg_count := lbl1 - 1
          Else If (lbl2 = 0) And (ptr_ultimate_type[idx] = TYPE_RECORD) And (tok_type = TOK_DOT) Then
            arg_count := lbl1 - 1
          Else
            arg_count := lbl1;
          For i := 1 To arg_count Do
          Begin
            WriteLn('    ldr x0, [x0]');
          End;
          { Determine result Type }
          If lbl2 > 0 Then
          Begin
            { Still have pointer levels remaining }
            expr_type := TYPE_POINTER;
            ptr_base_type := TYPE_POINTER
          End
          Else If ptr_ultimate_type[idx] = TYPE_RECORD Then
          Begin
            { Reached Record - check For field access }
            If tok_type = TOK_DOT Then
            Begin
              NextToken;  { consume '.' }
              { Find field In the Record Type }
              arg_count := FindField(ptr_ultimate_rec[idx]);
              If arg_count < 0 Then
                Error(11);  { unknown field }
              NextToken;  { consume field name }
              { Add field offset To pointer: add x0, x0, #offset }
              If field_offset[arg_count] > 0 Then
              Begin
                WriteLn('    add x0, x0, #');
              End;
              { Handle nested Record fields }
              While (field_type[arg_count] = TYPE_RECORD) And (tok_type = TOK_DOT) Do
              Begin
                NextToken;  { consume '.' }
                If tok_type <> TOK_IDENT Then
                  Error(11);
                var_arg_idx := arg_count;  { save current field index }
                arg_count := FindField(field_rec_type[var_arg_idx]);
                If arg_count < 0 Then
                  Error(15);
                If field_offset[arg_count] > 0 Then
                Begin
                  WriteLn('    add x0, x0, #');
                End;
                NextToken
              End;
              { Load field value }
              If field_type[arg_count] = TYPE_REAL Then
              Begin
                WriteLn('    ldr d0, [x0]');
                expr_type := TYPE_REAL
              End
              Else If field_type[arg_count] = TYPE_RECORD Then
                expr_type := TYPE_RECORD
              Else
              Begin
                WriteLn('    ldr x0, [x0]');
                expr_type := field_type[arg_count]
              End
            End
            Else
            Begin
              { Just p^ without field access - address In x0 }
              expr_type := TYPE_RECORD
            End
          End
          Else If ptr_ultimate_type[idx] = TYPE_ARRAY Then
          Begin
            { Pointer To Array - check For indexing pa^[i] }
            If tok_type = TOK_LBRACKET Then
            Begin
              NextToken;  { consume '[' }
              EmitPushX0;  { save Array base address }
              ParseExpression;  { index In x0 }
              Expect(TOK_RBRACKET);
              { x0 = index, stack has base address }
              { Subtract low bound }
              arg_count := sym_label[idx];  { ptr_arr index }
              EmitPushX0;
              EmitMovX0(ptr_arr_lo[arg_count]);
              EmitPopX1;
              { x0 = x1 - x0 = index - low_bound }
              WriteLn('    sub x0, x1, x0');
              { Multiply by 8 using lsl #3 }
              WriteLn('    lsl x0, x0, #3');
              { Add To base: x1 = base + offset }
              EmitPopX1;  { x1 = base address }
              WriteLn('    add x0, x1, x0');
              { Load element value }
              If ptr_arr_elem[arg_count] = TYPE_REAL Then
              Begin
                WriteLn('    ldr d0, [x0]');
                expr_type := TYPE_REAL
              End
              Else
              Begin
                WriteLn('    ldr x0, [x0]');
                expr_type := ptr_arr_elem[arg_count]
              End
            End
            Else
              expr_type := TYPE_ARRAY  { Just pa^ without indexing }
          End
          Else If ptr_ultimate_type[idx] = TYPE_REAL Then
          Begin
            expr_type := TYPE_REAL
          End
          Else
          Begin
            expr_type := ptr_ultimate_type[idx]
          End
        End
      End
      Else If sym_kind[idx] = SYM_FUNCTION Then
      Begin
        { Function call - pass args In x0-x7 }
        arg_count := 0;
        var_flags := sym_var_param_flags[idx];
        If tok_type = TOK_LPAREN Then
        Begin
          NextToken;
          If tok_type <> TOK_RPAREN Then
          Begin
            { Evaluate all args And push To stack }
            Repeat
              If tok_type = TOK_COMMA Then NextToken;
              { Check If this is a Var parameter }
              If IsVarParam(var_flags, arg_count) = 1 Then
              Begin
                { Var param - pass address Of variable }
                If tok_type <> TOK_IDENT Then
                  Error(6);  { Var param requires variable }
                var_arg_idx := SymLookup;
                If var_arg_idx < 0 Then
                  Error(3);
                NextToken;
                { Check For Array element - pass address Of element }
                If (sym_type[var_arg_idx] = TYPE_ARRAY) And (tok_type = TOK_LBRACKET) Then
                Begin
                  NextToken;  { consume '[' }
                  ParseExpression;  { index In x0 }
                  Expect(TOK_RBRACKET);
                  { Compute element address }
                  EmitPushX0;
                  EmitMovX0(sym_const_val[var_arg_idx]);  { low bound }
                  EmitPopX1;
                  { x0 = x1 - x0 = index - low_bound }
                  WriteLn('    sub x0, x1, x0');
                  { Multiply by 8 using lsl #3 }
                  WriteLn('    lsl x0, x0, #3');
                  { Get base address And subtract element offset }
                  If sym_level[var_arg_idx] < scope_level Then
                  Begin
                    EmitFollowChain(sym_level[var_arg_idx], scope_level);
                    EmitSubLargeOffset(1, 8, 0 - sym_offset[var_arg_idx])
                  End
                  Else
                    EmitSubLargeOffset(1, 29, 0 - sym_offset[var_arg_idx]);
                  { Address = base - element_offset }
                  WriteLn('    sub x0, x1, x0');
                End
                Else
                  { Simple variable - emit address }
                  EmitVarAddr(var_arg_idx, scope_level)
              End
              Else
              Begin
                { Value param - evaluate expression }
                ParseExpression
              End;
              EmitPushX0;
              arg_count := arg_count + 1
            Until tok_type <> TOK_COMMA
          End;
          Expect(TOK_RPAREN)
        End;
        { Pop args from stack into registers In reverse order }
        For i := arg_count - 1 DownTo 0 Do
        Begin
          Write('    ldr x'); Write(i); WriteLn(', [sp], #16');
        End;
        { Set up static link For callee }
        EmitStaticLink(sym_level[idx], scope_level);
        { Check If calling imported Unit Procedure }
        If sym_unit_idx[idx] >= 0 Then
          EmitBLUnitProc(sym_unit_idx[idx], idx)
        Else
          EmitBL(sym_label[idx]);
        expr_type := sym_type[idx]  { Function return Type }
      End
      Else
        Error(4)
      End  { End Of If (with_rec_idx < 0) Or (arg_count < 0) }
    End  { End Of Else For non-builtin ident }
  End  { End Of Else If tok_type = TOK_IDENT }
  Else
    Error(5)
End;

Procedure ParseUnary;
Begin
  If tok_type = TOK_MINUS Then
  Begin
    NextToken;
    ParseFactor;
    If expr_type = TYPE_REAL Then
      EmitFNeg
    Else
      EmitNeg
  End
  Else If tok_type = TOK_PLUS Then
  Begin
    NextToken;
    ParseFactor
  End
  Else
    ParseFactor
End;

Procedure ParseTerm;
Var
  op, left_type, and_skip_label, had_and: Integer;
Begin
  ParseUnary;
  had_and := 0;
  and_skip_label := 0;
  While (tok_type = TOK_STAR) Or (tok_type = TOK_DIV) Or (tok_type = TOK_MOD) Or
        (tok_type = TOK_AND) Or (tok_type = TOK_SLASH) Do
  Begin
    op := tok_type;
    left_type := expr_type;
    NextToken;

    If op = TOK_AND Then
    Begin
      { Short-circuit And: If current value is 0, skip rest }
      If had_and = 0 Then
      Begin
        and_skip_label := NewLabel;
        had_and := 1
      End;
      { cbz x0, .Lskip - branch If zero }
      EmitBranchLabelZ(and_skip_label);
      ParseUnary;
      expr_type := TYPE_INTEGER
    End
    Else
    Begin
      { Regular operators - push left, eval right, pop, compute }
      If left_type = TYPE_REAL Then
        EmitPushD0
      Else
        EmitPushX0;
      ParseUnary;
      { right operand is now In x0 Or d0 depending on expr_type }

      If op = TOK_SLASH Then
      Begin
        { / always produces Real - convert both operands To float }
        If expr_type <> TYPE_REAL Then
          EmitScvtfD0X0;  { convert right To float }
        If left_type = TYPE_REAL Then
          EmitPopD1
        Else
        Begin
          EmitPopX1;
          EmitScvtfD1X1  { convert left To float }
        End;
        EmitFDiv;
        expr_type := TYPE_REAL
      End
      Else If (left_type = TYPE_REAL) Or (expr_type = TYPE_REAL) Then
      Begin
        { Mixed Or both Real - use float ops }
        If expr_type <> TYPE_REAL Then
          EmitScvtfD0X0;  { convert right To float }
        If left_type = TYPE_REAL Then
          EmitPopD1
        Else
        Begin
          EmitPopX1;
          EmitScvtfD1X1  { convert left To float }
        End;
        If op = TOK_STAR Then
          EmitFMul
        Else If op = TOK_DIV Then
        Begin
          { Div on floats - truncate result To Integer }
          EmitFDiv;
          EmitFcvtzsX0D0;
          expr_type := TYPE_INTEGER
        End
        Else If op = TOK_MOD Then
          Error(13);  { Mod Not supported For reals }
        If (op = TOK_STAR) Then
          expr_type := TYPE_REAL
      End
      Else If (left_type = TYPE_SET) Or (expr_type = TYPE_SET) Then
      Begin
        { Set intersection: x0 = x1 And x0 }
        EmitPopX1;
        WriteLn('    And x0, x1, x0');
        expr_type := TYPE_SET
      End
      Else
      Begin
        { Both integers - use Integer ops }
        EmitPopX1;
        If op = TOK_STAR Then
          EmitMul
        Else If op = TOK_DIV Then
          EmitSDiv
        Else If op = TOK_MOD Then
        Begin
          { x1 Mod x0: x1 - (x1 / x0) * x0 }
          EmitPushX0;
          EmitPushX1;
          EmitSDiv;
          EmitMovX2X0;
          EmitPopX1;
          EmitPopX0;
          EmitMsub
        End;
        expr_type := TYPE_INTEGER
      End
    End
  End;

  { Emit skip label For short-circuit And If we had any }
  If had_and = 1 Then
    EmitLabel(and_skip_label)
End;

Procedure ParseSimpleExpr;
Var
  op, left_type, left_ptr_base, or_true_label, or_end_label, had_or: Integer;
Begin
  ParseTerm;
  had_or := 0;
  or_true_label := 0;
  or_end_label := 0;
  While (tok_type = TOK_PLUS) Or (tok_type = TOK_MINUS) Or (tok_type = TOK_OR) Do
  Begin
    op := tok_type;
    left_type := expr_type;
    left_ptr_base := ptr_base_type;
    NextToken;

    If op = TOK_OR Then
    Begin
      { Short-circuit Or: If current value is non-zero, skip rest With result 1 }
      If had_or = 0 Then
      Begin
        or_true_label := NewLabel;
        or_end_label := NewLabel;
        had_or := 1
      End;
      { cbnz x0, .Ltrue - branch If Not zero }
      EmitBranchLabelNZ(or_true_label);
      ParseTerm;
      expr_type := TYPE_INTEGER
    End
    Else
    Begin
      { Regular operators (+, -) - push left, eval right, pop, compute }
      If left_type = TYPE_REAL Then
        EmitPushD0
      Else
        EmitPushX0;
      ParseTerm;

      If (left_type = TYPE_POINTER) And (op = TOK_PLUS) Then
    Begin
      { pointer + Integer: scale Integer by 8 And SUBTRACT (arrays grow downward) }
      EmitPopX1;  { pointer In x1 }
      { x0 has Integer offset, multiply by 8 using lsl #3 }
      WriteLn('    lsl x0, x0, #3');
      EmitSub;  { x0 = x1 - x0 (subtract because arrays grow downward) }
      expr_type := TYPE_POINTER;
      ptr_base_type := left_ptr_base
    End
    Else If (left_type = TYPE_POINTER) And (op = TOK_MINUS) Then
    Begin
      If expr_type = TYPE_POINTER Then
      Begin
        { pointer - pointer: returns Integer count (negated For downward growth) }
        EmitPopX1;  { left pointer In x1 }
        EmitSub;  { x0 = x1 - x0 }
        { Negate And divide by 8 For correct count }
        EmitNeg;  { x0 = -(x1 - x0) = x0 - x1 }
        { Divide by 8 (element size) using asr #3 }
        WriteLn('    asr x0, x0, #3');
        expr_type := TYPE_INTEGER
      End
      Else
      Begin
        { pointer - Integer: scale Integer by 8 And ADD (arrays grow downward) }
        EmitPopX1;  { pointer In x1 }
        { x0 has Integer offset, multiply by 8 using lsl #3 }
        WriteLn('    lsl x0, x0, #3');
        EmitAdd;  { x0 = x1 + x0 (add because arrays grow downward) }
        expr_type := TYPE_POINTER;
        ptr_base_type := left_ptr_base
      End
    End
    Else If (left_type = TYPE_STRING) And (expr_type = TYPE_STRING) And (op = TOK_PLUS) Then
    Begin
      { String concatenation: str1 + str2 }
      { x0 = string2 addr, stack top = string1 addr }
      WriteLn('    mov x2, x0');
      EmitPopX1;  { string1 addr }
      { Allocate temp String from heap }
      WriteLn('    mov x0, x21');
      WriteLn('    add x21, x21, #256');
      { Call rt_str_concat(x0=dest, x1=str1, x2=str2) }
      EmitBL(rt_str_concat);
      expr_type := TYPE_STRING
    End
    Else If (((left_type = TYPE_STRING) And (expr_type = TYPE_CHAR)) Or
             ((left_type = TYPE_CHAR) And (expr_type = TYPE_STRING))) And (op = TOK_PLUS) Then
    Begin
      { String + Char Or Char + String concatenation }
      { Need To convert Char To a single-character String, Then concatenate }
      If left_type = TYPE_STRING Then
      Begin
        { String + Char: x0 = Char, stack top = String addr }
        { Create single-Char String from x0 on heap }
        WriteLn('    mov x3, x0');
        WriteLn('    mov x2, x21');
        EmitMovX0(1);  { Length = 1 }
        WriteLn('    strb w0, [x2]');
        WriteLn('    strb w3, [x2, #1]');
        WriteLn('    add x21, x21, #256');
        EmitPopX1;  { string1 addr }
        { x2 = Char String, x1 = string1, allocate result on heap }
        WriteLn('    mov x0, x21');
        WriteLn('    add x21, x21, #256');
        EmitBL(rt_str_concat)
      End
      Else
      Begin
        { Char + String: x0 = String addr, stack top = Char }
        WriteLn('    mov x2, x0');
        EmitPopX0;  { x0 = Char }
        { Create single-Char String from x0 on heap }
        WriteLn('    mov x1, x21');
        WriteLn('    mov x3, x0');
        EmitMovX0(1);  { Length = 1 }
        WriteLn('    strb w0, [x1]');
        WriteLn('    strb w3, [x1, #1]');
        WriteLn('    add x21, x21, #256');
        { x1 = Char String, x2 = string2, allocate result on heap }
        WriteLn('    mov x0, x21');
        WriteLn('    add x21, x21, #256');
        EmitBL(rt_str_concat)
      End;
      expr_type := TYPE_STRING
    End
    Else If (left_type = TYPE_SET) Or (expr_type = TYPE_SET) Then
    Begin
      { Set operations: + is union, - is difference }
      EmitPopX1;  { left Set In x1 }
      If op = TOK_PLUS Then
      Begin
        { Union: x0 = x1 Or x0 }
        WriteLn('    orr x0, x1, x0');
      End
      Else If op = TOK_MINUS Then
      Begin
        { Difference: x0 = x1 And Not x0 }
        { First: mvn x0, x0 (Not x0) }
        WriteLn('    mvn x0, x0');
        { Then: And x0, x1, x0 }
        WriteLn('    And x0, x1, x0');
      End;
      expr_type := TYPE_SET
    End
    Else If (left_type = TYPE_REAL) Or (expr_type = TYPE_REAL) Then
    Begin
      { Mixed Or both Real - use float ops }
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;  { convert right To float }
      If left_type = TYPE_REAL Then
        EmitPopD1
      Else
      Begin
        EmitPopX1;
        EmitScvtfD1X1  { convert left To float }
      End;
      If op = TOK_PLUS Then
        EmitFAdd
      Else If op = TOK_MINUS Then
        EmitFSub
      Else { TOK_OR }
        Error(13);  { Or Not supported For reals }
      expr_type := TYPE_REAL
    End
    Else
    Begin
      { Both integers (only + And - reach here) }
      EmitPopX1;
      If op = TOK_PLUS Then
        EmitAdd
      Else
        EmitSub;
      expr_type := TYPE_INTEGER
    End
    End  { End Of Else For non-Or operators }
  End;

  { Emit labels For short-circuit Or If we had any }
  If had_or = 1 Then
  Begin
    { b .Lend - skip the mov x0, #1 }
    EmitBranchLabel(or_end_label);
    EmitLabel(or_true_label);
    EmitMovX0(1);
    EmitLabel(or_end_label)
  End
End;

Procedure ParseExpression;
Var
  op, cond, left_type: Integer;
Begin
  ParseSimpleExpr;
  If (tok_type = TOK_EQ) Or (tok_type = TOK_NEQ) Or (tok_type = TOK_LT) Or
     (tok_type = TOK_LE) Or (tok_type = TOK_GT) Or (tok_type = TOK_GE) Then
  Begin
    op := tok_type;
    left_type := expr_type;
    NextToken;
    { Push left operand appropriately }
    If left_type = TYPE_REAL Then
      EmitPushD0
    Else
      EmitPushX0;
    ParseSimpleExpr;

    If (left_type = TYPE_STRING) And (expr_type = TYPE_STRING) Then
    Begin
      { String comparison }
      { x0 = string2 addr, stack top = string1 addr }
      WriteLn('    mov x1, x0');
      EmitPopX0;  { string1 addr In x0 }
      If (op = TOK_EQ) Or (op = TOK_NEQ) Then
      Begin
        { Call rt_str_compare(x0=str1, x1=str2) - returns 1 If equal, 0 If Not }
        EmitBL(rt_str_compare);
        If op = TOK_NEQ Then
          EmitEorX0(1)
      End
      Else
      Begin
        { Relational operators: call rt_str_cmp which returns -1/0/1 }
        EmitBL(rt_str_cmp);
        { x0 = -1 If s1<s2, 0 If s1=s2, 1 If s1>s2 }
        If op = TOK_LT Then
        Begin
          { cmp x0, #0; cset x0, lt }
          WriteLn('    cmp x0, #0');
          WriteLn('    cset x0, lt');
        End
        Else If op = TOK_GT Then
        Begin
          { cmp x0, #0; cset x0, gt }
          WriteLn('    cmp x0, #0');
          WriteLn('    cset x0, gt');
        End
        Else If op = TOK_LE Then
        Begin
          { cmp x0, #0; cset x0, le }
          WriteLn('    cmp x0, #0');
          WriteLn('    cset x0, le');
        End
        Else If op = TOK_GE Then
        Begin
          { cmp x0, #0; cset x0, ge }
          WriteLn('    cmp x0, #0');
          WriteLn('    cset x0, ge');
        End
      End;
      expr_type := TYPE_INTEGER
    End
    Else If (left_type = TYPE_REAL) Or (expr_type = TYPE_REAL) Then
    Begin
      { Float comparison }
      If expr_type <> TYPE_REAL Then
        EmitScvtfD0X0;  { convert right To float }
      If left_type = TYPE_REAL Then
        EmitPopD1
      Else
      Begin
        EmitPopX1;
        EmitScvtfD1X1  { convert left To float }
      End;
      EmitFCmp;
      If op = TOK_EQ Then cond := 0
      Else If op = TOK_NEQ Then cond := 1
      Else If op = TOK_LT Then cond := 2
      Else If op = TOK_LE Then cond := 3
      Else If op = TOK_GT Then cond := 4
      Else cond := 5;
      EmitCset(cond);
      expr_type := TYPE_INTEGER
    End
    Else
    Begin
      { Integer comparison }
      EmitPopX1;
      EmitCmpX0X1;
      If op = TOK_EQ Then cond := 0
      Else If op = TOK_NEQ Then cond := 1
      Else If op = TOK_LT Then cond := 2
      Else If op = TOK_LE Then cond := 3
      Else If op = TOK_GT Then cond := 4
      Else cond := 5;
      EmitCset(cond);
      expr_type := TYPE_INTEGER
    End
  End
  Else If tok_type = TOK_IN Then
  Begin
    { Set membership: value In Set }
    { x0 = value, need To check If bit is Set In the Set }
    EmitPushX0;  { push value }
    NextToken;
    ParseSimpleExpr;  { Set In x0 }
    { x0 = Set, stack = value }
    { Result: (Set >> value) & 1 }
    EmitPopX1;  { value In x1 }
    { lsr x0, x0, x1 }
    WriteLn('    lsr x0, x0, x1');
    { And x0, x0, #1 }
    EmitAndImm(1);
    expr_type := TYPE_BOOLEAN
  End
End;

Procedure ParseStatement;
Var
  idx, lbl1, lbl2, lbl3, arg_count, i: Integer;
  var_flags, arg_idx, var_arg_idx: Integer;
  old_break, old_continue: Integer;
Begin
  If tok_type = TOK_BEGIN Then
  Begin
    NextToken;
    ParseStatement;
    While tok_type = TOK_SEMICOLON Do
    Begin
      NextToken;
      ParseStatement
    End;
    Expect(TOK_END)
  End
  Else If tok_type = TOK_IF Then
  Begin
    NextToken;
    ParseExpression;
    Expect(TOK_THEN);
    lbl1 := NewLabel;
    lbl2 := NewLabel;
    EmitBranchLabelZ(lbl1);
    ParseStatement;
    If tok_type = TOK_ELSE Then
    Begin
      EmitBranchLabel(lbl2);
      EmitLabel(lbl1);
      NextToken;
      ParseStatement;
      EmitLabel(lbl2)
    End
    Else
      EmitLabel(lbl1)
  End
  Else If tok_type = TOK_WHILE Then
  Begin
    lbl1 := NewLabel;  { loop start / Continue target }
    lbl2 := NewLabel;  { loop End / Break target }
    { Save old Break/Continue labels }
    old_break := break_label;
    old_continue := continue_label;
    break_label := lbl2;
    continue_label := lbl1;
    EmitLabel(lbl1);
    NextToken;
    ParseExpression;
    Expect(TOK_DO);
    EmitBranchLabelZ(lbl2);
    ParseStatement;
    EmitBranchLabel(lbl1);
    EmitLabel(lbl2);
    { Restore old Break/Continue labels }
    break_label := old_break;
    continue_label := old_continue
  End
  Else If tok_type = TOK_REPEAT Then
  Begin
    lbl1 := NewLabel;  { loop start / Continue target }
    lbl2 := NewLabel;  { loop End / Break target }
    { Save old Break/Continue labels }
    old_break := break_label;
    old_continue := continue_label;
    break_label := lbl2;
    continue_label := lbl1;
    EmitLabel(lbl1);
    NextToken;
    ParseStatement;
    While tok_type = TOK_SEMICOLON Do
    Begin
      NextToken;
      ParseStatement
    End;
    Expect(TOK_UNTIL);
    ParseExpression;
    EmitBranchLabelZ(lbl1);
    EmitLabel(lbl2);
    { Restore old Break/Continue labels }
    break_label := old_break;
    continue_label := old_continue
  End
  Else If tok_type = TOK_FOR Then
  Begin
    NextToken;
    If tok_type <> TOK_IDENT Then
      Error(6);
    idx := SymLookup;
    If idx < 0 Then
      Error(3);
    NextToken;
    Expect(TOK_ASSIGN);
    ParseExpression;
    EmitSturX0(sym_offset[idx]);

    lbl1 := NewLabel;  { condition check }
    lbl2 := NewLabel;  { loop End / Break target }
    lbl3 := NewLabel;  { increment / Continue target }

    { Save old Break/Continue labels }
    old_break := break_label;
    old_continue := continue_label;
    break_label := lbl2;
    continue_label := lbl3;

    If tok_type = TOK_TO Then
    Begin
      NextToken;
      ParseExpression;  { End value into x0 }
      EmitPushX0;       { save End value on stack }
      Expect(TOK_DO);
      EmitLabel(lbl1);
      EmitLdurX0(sym_offset[idx]);  { load loop Var }
      { ldur x1, [sp] - load End value from stack }
      WriteLn('    ldur x1, [sp]');
      EmitCmpX0X1;
      EmitCset(2);  { lt: Exit when End < i, meaning i > End }
      EmitBranchLabelNZ(lbl2);
      ParseStatement;
      { Continue target - increment }
      EmitLabel(lbl3);
      EmitLdurX0(sym_offset[idx]);
      WriteLn('    add x0, x0, #1');
      EmitSturX0(sym_offset[idx]);
      EmitBranchLabel(lbl1);
      EmitLabel(lbl2);
      { Restore old Break/Continue labels }
      break_label := old_break;
      continue_label := old_continue;
      { Pop End value from stack }
      WriteLn('    add sp, sp, #16');
    End
    Else
    Begin
      Expect(TOK_DOWNTO);
      ParseExpression;  { End value into x0 }
      EmitPushX0;       { save End value on stack }
      Expect(TOK_DO);
      EmitLabel(lbl1);
      EmitLdurX0(sym_offset[idx]);  { load loop Var }
      { ldur x1, [sp] - load End value from stack }
      WriteLn('    ldur x1, [sp]');
      EmitCmpX0X1;
      EmitCset(4);  { gt: Exit when End > i, meaning i < End }
      EmitBranchLabelNZ(lbl2);
      ParseStatement;
      { Continue target - decrement }
      EmitLabel(lbl3);
      EmitLdurX0(sym_offset[idx]);
      WriteLn('    sub x0, x0, #1');
      EmitSturX0(sym_offset[idx]);
      EmitBranchLabel(lbl1);
      EmitLabel(lbl2);
      { Restore old Break/Continue labels }
      break_label := old_break;
      continue_label := old_continue;
      { Pop End value from stack }
      WriteLn('    add sp, sp, #16');
    End
  End
  Else If tok_type = TOK_CASE Then
  Begin
    { Case selector Of Const: stmt; ... [Else stmt] End }
    NextToken;
    ParseExpression;  { selector In x0 }
    EmitPushX0;       { save selector on stack }
    Expect(TOK_OF);
    lbl1 := NewLabel;  { End Of Case label }

    While (tok_type <> TOK_END) And (tok_type <> TOK_ELSE) Do
    Begin
      { Parse constant(s) For this Case branch }
      lbl2 := NewLabel;  { next Case branch label }
      lbl3 := NewLabel;  { match found, execute statement }
      Repeat
        If tok_type = TOK_COMMA Then NextToken;
        { Load selector from stack (peek, don't pop): ldr x1, [sp] }
        WriteLn('    ldr x1, [sp]');
        { Parse constant value }
        If tok_type = TOK_INTEGER Then
        Begin
          EmitMovX0(tok_int);
          NextToken
        End
        Else If tok_type = TOK_MINUS Then
        Begin
          NextToken;
          If tok_type = TOK_INTEGER Then
          Begin
            EmitMovX0(0 - tok_int);
            NextToken
          End
          Else
            Error(10)
        End
        Else
          Error(10);  { expected constant }
        { Compare: cmp x1, x0 }
        EmitCmpX0X1;
        { If equal, jump To match label }
        Write('    b.eq L'); WriteLn(lbl3);
      Until tok_type = TOK_COLON;
      { No match In this group, jump To next branch }
      EmitBranchLabel(lbl2);
      { Match found - execute statement }
      EmitLabel(lbl3);
      NextToken;  { consume ':' }
      { Pop selector from stack (discard) }
      WriteLn('    add sp, sp, #16');
      ParseStatement;
      { Jump To End Of Case }
      EmitBranchLabel(lbl1);
      { Repush selector For next comparisons: sub sp, sp, #16; str x0, [sp] }
      { Actually we need To restore selector - this gets tricky }
      { Simpler approach: jump around the next branch's test }
      EmitLabel(lbl2);
      { After ParseStatement the selector was popped, repush it }
      { For simplicity, we push a placeholder And let the next iteration reload }
      { Actually, we need the selector back - let's use a different approach }
      { The cleanest way: keep selector on stack Until we match Or hit Else/End }
      { Re-push selector: we saved it In x0 before? No. Let's rethink. }
      { Better: save selector To a dedicated spot before the loop }
      { For now: don't pop Until match, just peek. Pop only when match Or done. }
      { Skip the repush - we've jumped To lbl1 If matched, lbl2 If Not }
      { At lbl2, we still have selector on stack }
      If tok_type = TOK_SEMICOLON Then NextToken
    End;

    If tok_type = TOK_ELSE Then
    Begin
      NextToken;
      { Pop selector (discard) before Else statement }
      WriteLn('    add sp, sp, #16');
      ParseStatement;
      { Note: no need To jump To lbl1, we fall through }
    End
    Else
    Begin
      { No Else - just pop selector }
      WriteLn('    add sp, sp, #16');
    End;
    EmitLabel(lbl1);
    Expect(TOK_END)
  End
  Else If tok_type = TOK_READ Then
  Begin
    { Read([f,] Var) - reads an Integer Or Real into a variable }
    NextToken;
    Expect(TOK_LPAREN);
    lbl1 := 0;  { flag: 1 If reading from file }
    If tok_type <> TOK_IDENT Then
      Error(6);
    idx := SymLookup;
    If idx < 0 Then
      Error(3);
    { Check If first arg is a file variable }
    If (sym_type[idx] = TYPE_FILE) Or (sym_type[idx] = TYPE_TEXT) Then
    Begin
      { File variable - save x19 And load file's fd }
      lbl1 := 1;
      NextToken;
      { Push x19 To save it }
      WriteLn('    str x19, [sp, #-16]!');
      { Load file's fd into x19 }
      EmitVarAddr(idx, scope_level);
      WriteLn('    ldr x19, [x0]');
      Expect(TOK_COMMA);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3)
    End;
    NextToken;
    If sym_type[idx] = TYPE_REAL Then
    Begin
      { Call read_real runtime - result In d0 }
      EmitBL(rt_read_real);
      { Store result In variable }
      If sym_level[idx] = scope_level Then
        EmitSturD0(sym_offset[idx])
      Else
        EmitSturD0Outer(sym_offset[idx], sym_level[idx], scope_level)
    End
    Else
    Begin
      { Call read_int runtime }
      EmitBL(rt_read_int);
      { Store result In variable }
      If sym_level[idx] = scope_level Then
        EmitSturX0(sym_offset[idx])
      Else
        EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
    End;
    { Restore x19 If we saved it }
    If lbl1 = 1 Then
    Begin
      WriteLn('    ldr x19, [sp], #16');
    End;
    Expect(TOK_RPAREN)
  End
  Else If tok_type = TOK_READLN Then
  Begin
    { ReadLn([f,] Var) Or ReadLn([f]) - reads Integer/Real/String And skips To End Of line }
    NextToken;
    lbl1 := 0;  { flag: 1 If reading from file }
    If tok_type = TOK_LPAREN Then
    Begin
      NextToken;
      If tok_type <> TOK_RPAREN Then
      Begin
        If tok_type <> TOK_IDENT Then
          Error(6);
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        { Check If first arg is a file variable }
        If (sym_type[idx] = TYPE_FILE) Or (sym_type[idx] = TYPE_TEXT) Then
        Begin
          { File variable - save x19 And load file's fd }
          lbl1 := 1;
          NextToken;
          { Push x19 To save it }
          WriteLn('    str x19, [sp, #-16]!');
          { Load file's fd into x19 }
          EmitVarAddr(idx, scope_level);
          WriteLn('    ldr x19, [x0]');
          { Check For comma (more args) Or just skip To rparen }
          If tok_type = TOK_COMMA Then
          Begin
            NextToken;
            If tok_type <> TOK_IDENT Then
              Error(6);
            idx := SymLookup;
            If idx < 0 Then
              Error(3)
          End
          Else
          Begin
            { Just file arg, no variable To Read into - skip To rparen }
            Expect(TOK_RPAREN);
            { Skip To End Of line }
            EmitBL(rt_skip_line);
            { Restore x19 }
            WriteLn('    ldr x19, [sp], #16');
          End
        End;
        { Only process variable If we have one }
        If tok_type = TOK_IDENT Then
        Begin
          idx := SymLookup;
          If idx < 0 Then
            Error(3);
          lbl2 := sym_type[idx];  { save Type For skip_line decision }
          NextToken;
          If sym_type[idx] = TYPE_REAL Then
          Begin
            { Call read_real runtime - result In d0 }
            EmitBL(rt_read_real);
            { Store result In variable }
            If sym_level[idx] = scope_level Then
              EmitSturD0(sym_offset[idx])
            Else
              EmitSturD0Outer(sym_offset[idx], sym_level[idx], scope_level)
          End
          Else If sym_type[idx] = TYPE_STRING Then
          Begin
            { Load String variable address into x0 }
            EmitVarAddr(idx, scope_level);
            { Call read_string runtime - already consumes newline }
            EmitBL(rt_read_string)
          End
          Else
          Begin
            { Call read_int runtime }
            EmitBL(rt_read_int);
            { Store result In variable }
            If sym_level[idx] = scope_level Then
              EmitSturX0(sym_offset[idx])
            Else
              EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
          End;
          Expect(TOK_RPAREN);
          { Skip To End Of line only For Integer/Real (read_string already consumed newline) }
          If lbl2 <> TYPE_STRING Then
            EmitBL(rt_skip_line);
          { Restore x19 If we saved it }
          If lbl1 = 1 Then
          Begin
            WriteLn('    ldr x19, [sp], #16');
          End
        End
      End
      Else
      Begin
        { ReadLn() With no args }
        Expect(TOK_RPAREN);
        EmitBL(rt_skip_line)
      End
    End
    Else
    Begin
      { ReadLn With no parens }
      EmitBL(rt_skip_line)
    End
  End
  Else If tok_type = TOK_WITH Then
  Begin
    { With record_var Do statement }
    NextToken;
    If tok_type <> TOK_IDENT Then
      Error(6);  { expected identifier }
    idx := SymLookup;
    If idx < 0 Then
      Error(3);  { undefined identifier }
    If sym_type[idx] <> TYPE_RECORD Then
      Error(9);  { expected Record Type }
    { Save current With context }
    lbl1 := with_rec_idx;  { reuse lbl1 To save old with_rec_idx }
    lbl2 := with_rec_type;  { reuse lbl2 To save old with_rec_type }
    with_rec_idx := idx;
    with_rec_type := sym_const_val[idx];  { the Type definition index }
    NextToken;
    Expect(TOK_DO);
    ParseStatement;
    { Restore With context }
    with_rec_idx := lbl1;
    with_rec_type := lbl2
  End
  Else If tok_type = TOK_IDENT Then
  Begin
    { Check For built-In procedures first }
    { Break = 98,114,101,97,107 }
    If (tok_len = 5) And (ToLower(tok_str[0]) = 98) And (ToLower(tok_str[1]) = 114) And
       (ToLower(tok_str[2]) = 101) And (ToLower(tok_str[3]) = 97) And (ToLower(tok_str[4]) = 107) Then
    Begin
      NextToken;
      If break_label = 0 Then
        Error(15)  { Break Not inside a loop }
      Else
        EmitBranchLabel(break_label)
    End
    { Continue = 99,111,110,116,105,110,117,101 }
    Else If (tok_len = 8) And (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 105) And
            (ToLower(tok_str[5]) = 110) And (ToLower(tok_str[6]) = 117) And (ToLower(tok_str[7]) = 101) Then
    Begin
      NextToken;
      If continue_label = 0 Then
        Error(15)  { Continue Not inside a loop }
      Else
        EmitBranchLabel(continue_label)
    End
    { Exit = 101,120,105,116 }
    Else If (tok_len = 4) And (ToLower(tok_str[0]) = 101) And (ToLower(tok_str[1]) = 120) And
            (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 116) Then
    Begin
      NextToken;
      If exit_label = 0 Then
      Begin
        { In main Program - just call Halt With Exit code 0 }
        EmitMovX0(0);
        { mov x16, #1 }
        WriteLn('    mov x16, #1');
        { svc #0x80 }
        WriteLn('    svc #0x80');
      End
      Else
        EmitBranchLabel(exit_label)
    End
    { Write = 119,114,105,116,101 }
    { WriteLn = 119,114,105,116,101,108,110 }
    { ReadChar = 114,101,97,100,99,104,97,114 }
    { WriteChar = 119,114,105,116,101,99,104,97 - actually too long, use 8 }
    { Halt = 104,97,108,116 }
    Else If TokIs8(119, 114, 105, 116, 101, 108, 110, 0) = 1 Then
    Begin
      { WriteLn }
      NextToken;
      lbl1 := 0;  { flag: 1 If writing To file }
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        If tok_type <> TOK_RPAREN Then
        Begin
          { Check If first arg is a file variable }
          If tok_type = TOK_IDENT Then
          Begin
            idx := SymLookup;
            If (idx >= 0) And ((sym_type[idx] = TYPE_FILE) Or (sym_type[idx] = TYPE_TEXT)) Then
            Begin
              { File variable - save x20 And load file's fd }
              lbl1 := 1;
              NextToken;
              { Push x20 To save it }
              WriteLn('    str x20, [sp, #-16]!');
              { Load file's fd into x20 }
              EmitVarAddr(idx, scope_level);
              WriteLn('    ldr x20, [x0]');
              If tok_type = TOK_COMMA Then
                NextToken
            End
          End;
          If (lbl1 = 0) Or (tok_type <> TOK_RPAREN) Then
          Begin
            While tok_type <> TOK_RPAREN Do
            Begin
              If tok_type = TOK_STRING Then
              Begin
                { Print String literal character by character }
                idx := 0;
                While idx < tok_len Do
                Begin
                  EmitMovX0(tok_str[idx]);
                  EmitBL(rt_print_char);
                  idx := idx + 1
                End;
                NextToken
              End
              Else If tok_type = TOK_IDENT Then
              Begin
                { Check If it's a String variable }
                idx := SymLookup;
                If (idx >= 0) And (sym_type[idx] = TYPE_STRING) Then
                Begin
                  { String variable - compute address And call print_string }
                  NextToken;
                  EmitVarAddr(idx, scope_level);
                  EmitBL(rt_print_string)
                End
                Else
                Begin
                  { Not a String - parse as expression And print based on Type }
                  ParseExpression;
                  If expr_type = TYPE_REAL Then
                    EmitBL(rt_print_real)
                  Else If expr_type = TYPE_STRING Then
                    EmitBL(rt_print_string)
                  Else
                    EmitBL(rt_print_int)
                End
              End
              Else
              Begin
                ParseExpression;
                If expr_type = TYPE_REAL Then
                  EmitBL(rt_print_real)
                Else If expr_type = TYPE_STRING Then
                  EmitBL(rt_print_string)
                Else
                  EmitBL(rt_print_int)
              End;
              If tok_type = TOK_COMMA Then NextToken
            End
          End
        End;
        Expect(TOK_RPAREN)
      End;
      EmitBL(rt_newline);
      { Restore x20 If we saved it }
      If lbl1 = 1 Then
      Begin
        WriteLn('    ldr x20, [sp], #16');
      End
    End
    Else If TokIs8(119, 114, 105, 116, 101, 0, 0, 0) = 1 Then
    Begin
      { Write }
      NextToken;
      lbl1 := 0;  { flag: 1 If writing To file }
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        If tok_type <> TOK_RPAREN Then
        Begin
          { Check If first arg is a file variable }
          If tok_type = TOK_IDENT Then
          Begin
            idx := SymLookup;
            If (idx >= 0) And ((sym_type[idx] = TYPE_FILE) Or (sym_type[idx] = TYPE_TEXT)) Then
            Begin
              { File variable - save x20 And load file's fd }
              lbl1 := 1;
              NextToken;
              { Push x20 To save it }
              WriteLn('    str x20, [sp, #-16]!');
              { Load file's fd into x20 }
              EmitVarAddr(idx, scope_level);
              WriteLn('    ldr x20, [x0]');
              If tok_type = TOK_COMMA Then
                NextToken
            End
          End;
          If (lbl1 = 0) Or (tok_type <> TOK_RPAREN) Then
          Begin
            While tok_type <> TOK_RPAREN Do
            Begin
              If tok_type = TOK_STRING Then
              Begin
                { Print String literal character by character }
                idx := 0;
                While idx < tok_len Do
                Begin
                  EmitMovX0(tok_str[idx]);
                  EmitBL(rt_print_char);
                  idx := idx + 1
                End;
                NextToken
              End
              Else If tok_type = TOK_IDENT Then
              Begin
                { Check If it's a String variable }
                idx := SymLookup;
                If (idx >= 0) And (sym_type[idx] = TYPE_STRING) Then
                Begin
                  { String variable - compute address And call print_string }
                  NextToken;
                  EmitVarAddr(idx, scope_level);
                  EmitBL(rt_print_string)
                End
                Else
                Begin
                  { Not a String - parse as expression And print based on Type }
                  ParseExpression;
                  If expr_type = TYPE_REAL Then
                    EmitBL(rt_print_real)
                  Else If expr_type = TYPE_STRING Then
                    EmitBL(rt_print_string)
                  Else
                    EmitBL(rt_print_int)
                End
              End
              Else
              Begin
                ParseExpression;
                If expr_type = TYPE_REAL Then
                  EmitBL(rt_print_real)
                Else If expr_type = TYPE_STRING Then
                  EmitBL(rt_print_string)
                Else
                  EmitBL(rt_print_int)
              End;
              If tok_type = TOK_COMMA Then NextToken
            End
          End
        End;
        Expect(TOK_RPAREN)
      End;
      { Restore x20 If we saved it }
      If lbl1 = 1 Then
      Begin
        WriteLn('    ldr x20, [sp], #16');
      End
    End
    Else If TokIs8(104, 97, 108, 116, 0, 0, 0, 0) = 1 Then
    Begin
      { Halt }
      NextToken;
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        If tok_type <> TOK_RPAREN Then
          ParseExpression
        Else
          EmitMovX0(0);
        Expect(TOK_RPAREN)
      End
      Else
        EmitMovX0(0);
      EmitMovX16(33554433);  { 0x2000001 = Exit }
      EmitSvc
    End
    { randomize = 114,97,110,100,111,109,105,122,101 }
    Else If (tok_len = 9) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 97) And
            (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 100) And (ToLower(tok_str[4]) = 111) And
            (ToLower(tok_str[5]) = 109) And (ToLower(tok_str[6]) = 105) And (ToLower(tok_str[7]) = 122) And
            (ToLower(tok_str[8]) = 101) Then
    Begin
      { randomize - seed the PRNG using stack pointer XOR With a constant }
      NextToken;
      If tok_type = TOK_LPAREN Then
      Begin
        NextToken;
        If tok_type <> TOK_RPAREN Then
        Begin
          { randomize(seed) - use provided seed }
          ParseExpression;
          { mov x27, x0 }
          WriteLn('    mov x27, x0');
        End
        Else
        Begin
          { randomize() - use sp as seed }
          WriteLn('    mov x27, sp');
        End;
        Expect(TOK_RPAREN)
      End
      Else
      Begin
        { randomize With no parens - use sp as seed }
        WriteLn('    mov x27, sp');
      End
    End
    { Inc = 105,110,99 }
    Else If TokIs8(105, 110, 99, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(3);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      NextToken;
      { Load address into x8 }
      EmitVarAddr(idx, scope_level);
      WriteLn('    mov x8, x0');
      { Load current value }
      WriteLn('    ldr x0, [x8]');
      { Add 1 }
      WriteLn('    add x0, x0, #1');
      { Store back }
      WriteLn('    str x0, [x8]');
      Expect(TOK_RPAREN)
    End
    { Dec = 100,101,99 }
    Else If TokIs8(100, 101, 99, 0, 0, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(3);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      NextToken;
      { Load address into x8 }
      EmitVarAddr(idx, scope_level);
      WriteLn('    mov x8, x0');
      { Load current value }
      WriteLn('    ldr x0, [x8]');
      { Subtract 1 }
      WriteLn('    sub x0, x0, #1');
      { Store back }
      WriteLn('    str x0, [x8]');
      Expect(TOK_RPAREN)
    End
    Else If (tok_len = 9) And (ToLower(tok_str[0]) = 119) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 101) And
            (ToLower(tok_str[5]) = 99) And (ToLower(tok_str[6]) = 104) And (ToLower(tok_str[7]) = 97) And
            (ToLower(tok_str[8]) = 114) Then
    Begin
      { WriteChar - 119,114,105,116,101,99,104,97,114 }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      EmitBL(rt_print_char)
    End
    { writefilechar(file, Char) - 119,114,105,116,101,102,105,108,101,99,104,97,114 }
    Else If (tok_len = 13) And (ToLower(tok_str[0]) = 119) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 101) And
            (ToLower(tok_str[5]) = 102) And (ToLower(tok_str[6]) = 105) And (ToLower(tok_str[7]) = 108) And
            (ToLower(tok_str[8]) = 101) And (ToLower(tok_str[9]) = 99) And (ToLower(tok_str[10]) = 104) And
            (ToLower(tok_str[11]) = 97) And (ToLower(tok_str[12]) = 114) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: file variable }
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      { Load file fd into x0 }
      EmitVarAddr(idx, scope_level);
      WriteLn('    ldr x0, [x0]');
      { Push fd To stack }
      EmitPushX0;
      NextToken;
      Expect(TOK_COMMA);
      { Second arg: character expression }
      ParseExpression;
      Expect(TOK_RPAREN);
      { x0 has Char, pop fd into x1, swap }
      WriteLn('    mov x1, x0');
      WriteLn('    ldr x0, [sp], #16');
      { Call Write Char To fd runtime: x0=fd, x1=Char }
      EmitBL(rt_write_char_fd)
    End
    Else If (tok_len = 8) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 97) And (ToLower(tok_str[3]) = 100) And (ToLower(tok_str[4]) = 99) And
            (ToLower(tok_str[5]) = 104) And (ToLower(tok_str[6]) = 97) And (ToLower(tok_str[7]) = 114) Then
    Begin
      { ReadChar - 114,101,97,100,99,104,97,114 }
      NextToken;
      EmitBL(rt_readchar)
    End
    Else If TokIs8(110, 101, 119, 0, 0, 0, 0, 0) = 1 Then
    Begin
      { New(p) - allocate memory For pointer variable }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);  { expected identifier }
      idx := SymLookup;
      If idx < 0 Then
        Error(3);  { undefined identifier }
      If sym_type[idx] <> TYPE_POINTER Then
        Error(14);  { expected pointer Type }
      NextToken;
      Expect(TOK_RPAREN);
      { Determine allocation size based on base Type }
      If sym_const_val[idx] = TYPE_RECORD Then
        lbl1 := sym_label[sym_label[idx]]  { Record size from Type definition }
      Else If sym_const_val[idx] = TYPE_ARRAY Then
      Begin
        { Pointer To Array: calculate size from bounds }
        arg_count := sym_label[idx];  { ptr_arr index }
        lbl1 := (ptr_arr_hi[arg_count] - ptr_arr_lo[arg_count] + 1) * 8
      End
      Else
        lbl1 := 8;  { basic types are 8 bytes }
      { Align To 8 bytes }
      lbl1 := ((lbl1 + 7) Div 8) * 8;
      { Allocate via rt_alloc: put size In x0, call rt_alloc }
      EmitMovX0(lbl1);
      EmitBL(rt_alloc);
      { Store address In pointer variable }
      If sym_level[idx] < scope_level Then
        EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
      Else
        EmitSturX0(sym_offset[idx])
    End
    Else If (tok_len = 7) And (ToLower(tok_str[0]) = 100) And (ToLower(tok_str[1]) = 105) And
            (ToLower(tok_str[2]) = 115) And (ToLower(tok_str[3]) = 112) And (ToLower(tok_str[4]) = 111) And
            (ToLower(tok_str[5]) = 115) And (ToLower(tok_str[6]) = 101) Then
    Begin
      { Dispose(p) - free memory via free list allocator }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);  { expected identifier }
      idx := SymLookup;
      If idx < 0 Then
        Error(3);  { undefined identifier }
      If sym_type[idx] <> TYPE_POINTER Then
        Error(14);  { expected pointer Type }
      NextToken;
      Expect(TOK_RPAREN);
      { Load pointer value into x0 }
      If sym_level[idx] < scope_level Then
        EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
      Else
        EmitLdurX0(sym_offset[idx]);
      { Call rt_free To return memory To free list }
      EmitBL(rt_free);
      { Set pointer To Nil For safety }
      EmitMovX0(0);
      If sym_level[idx] < scope_level Then
        EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
      Else
        EmitSturX0(sym_offset[idx])
    End
    { assign = 97,115,115,105,103,110 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 97) And (ToLower(tok_str[1]) = 115) And
            (ToLower(tok_str[2]) = 115) And (ToLower(tok_str[3]) = 105) And (ToLower(tok_str[4]) = 103) And
            (ToLower(tok_str[5]) = 110) Then
    Begin
      { assign(f, filename) - associate file variable With filename }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_COMMA);
      { Get address Of file variable }
      EmitVarAddr(idx, scope_level);
      EmitPushX0;  { save file Var address }
      { Parse filename (String expression) }
      ParseExpression;
      { x0 = source String address, stack = file Var address }
      { Copy filename To file Var offset 16 }
      EmitPopX1;  { x1 = file Var address }
      { add x1, x1, #16 - point To filename area }
      WriteLn('    add x1, x1, #16');
      { swap x0 And x1 For str_copy (dest In x0, src In x1) }
      { x0 = src String, x1 = dest (file Var + 16) }
      WriteLn('    mov x2, x0');
      WriteLn('    mov x0, x1');
      WriteLn('    mov x1, x2');
      { Now x0 = dest, x1 = src. Save dest before call. }
      EmitPushX0;
      EmitBL(rt_str_copy);
      EmitPopX0;  { restore dest address }
      { Add null terminator For C String compatibility }
      { ldrb w1, [x0] - load Length }
      WriteLn('    ldrb w1, [x0]');
      { add x1, x1, #1 - position after last Char }
      WriteLn('    add x1, x1, #1');
      { strb wzr, [x0, x1] - store null byte }
      WriteLn('    strb wzr, [x0, x1]');
      { Initialize fd To -1 (Not open) }
      EmitVarAddr(idx, scope_level);
      EmitPushX0;
      EmitMovX0(-1);
      EmitPopX1;
      { str x0, [x1] }
      WriteLn('    str x0, [x1]');
      Expect(TOK_RPAREN)
    End
    { assigntokstr = 97,115,115,105,103,110,116,111,107,115,116,114 }
    Else If (tok_len = 12) And (ToLower(tok_str[0]) = 97) And (ToLower(tok_str[1]) = 115) And
            (ToLower(tok_str[2]) = 115) And (ToLower(tok_str[3]) = 105) And (ToLower(tok_str[4]) = 103) And
            (ToLower(tok_str[5]) = 110) And (ToLower(tok_str[6]) = 116) And (ToLower(tok_str[7]) = 111) And
            (ToLower(tok_str[8]) = 107) And (ToLower(tok_str[9]) = 115) And (ToLower(tok_str[10]) = 116) And
            (ToLower(tok_str[11]) = 114) Then
    Begin
      { assigntokstr(f, start, len) - assign filename from tok_str To file }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_COMMA);
      { Parse start index }
      ParseExpression;
      EmitPushX0;  { save start }
      Expect(TOK_COMMA);
      { Parse Length }
      ParseExpression;
      { x0 = len, stack has start }
      { mov x2, x0 - x2 = len }
      WriteLn('    mov x2, x0');
      EmitPopX1;  { x1 = start }
      { Get address Of tok_str using VarAddr }
      { We need the tok_str global - find it In symbol table }
      { For now, use direct offset calculation since tok_str is a global Array }
      { Get file Var base address first }
      EmitVarAddr(idx, scope_level);
      { add x0, x0, #16 - point To filename area }
      WriteLn('    add x0, x0, #16');
      { Save dest address }
      EmitPushX0;
      { Get tok_str base address - look it up }
      { str x1, [sp, #-16]! - save start index }
      WriteLn('    str x1, [sp, #-16]!');
      { str x2, [sp, #-16]! - save len }
      WriteLn('    str x2, [sp, #-16]!');
      { Find tok_str In symbol table And get its address }
      tok_str[0] := 116; tok_str[1] := 111; tok_str[2] := 107; tok_str[3] := 95;
      tok_str[4] := 115; tok_str[5] := 116; tok_str[6] := 114; tok_str[7] := 0;
      tok_len := 7;
      arg_idx := SymLookup;
      If arg_idx < 0 Then
        Error(3);  { tok_str Not found }
      EmitVarAddr(arg_idx, scope_level);  { x0 = tok_str base }
      { mov x3, x0 - x3 = tok_str base }
      WriteLn('    mov x3, x0');
      { ldr x2, [sp], #16 - restore len }
      WriteLn('    ldr x2, [sp], #16');
      { ldr x1, [sp], #16 - restore start }
      WriteLn('    ldr x1, [sp], #16');
      { ldr x0, [sp], #16 - restore dest }
      EmitPopX0;
      { x3 + x1*8 = source address (tok_str elements are 8 bytes) }
      { lsl x1, x1, #3 }
      WriteLn('    lsl x1, x1, #3');
      { add x3, x3, x1 - x3 = source address }
      WriteLn('    add x3, x3, x1');
      { Copy loop: copy x2 characters from [x3] To [x0], skip Length byte }
      { add x0, x0, #1 - skip Length byte position }
      WriteLn('    add x0, x0, #1');
      { Save x2 (len) For later Length byte Write }
      WriteLn('    mov x4, x2');
      lbl1 := NewLabel;
      lbl2 := NewLabel;
      EmitLabel(lbl1);
      { cbz x2, done }
      Write('    cbz x2, L'); WriteLn(lbl2);
      { ldr x5, [x3], #8 - load 8-byte Integer from tok_str }
      WriteLn('    ldr x5, [x3], #8');
      { strb w5, [x0], #1 - store as byte }
      WriteLn('    strb w5, [x0], #1');
      { sub x2, x2, #1 }
      WriteLn('    sub x2, x2, #1');
      EmitBranchLabel(lbl1);
      EmitLabel(lbl2);
      { strb wzr, [x0] - null terminate }
      WriteLn('    strb wzr, [x0]');
      { Write Length byte at start Of filename: x0-x4-1 = start address }
      { sub x0, x0, x4 }
      WriteLn('    sub x0, x0, x4');
      { sub x0, x0, #1 }
      WriteLn('    sub x0, x0, #1');
      { strb w4, [x0] - store Length byte }
      WriteLn('    strb w4, [x0]');
      { Initialize fd To -1 }
      EmitVarAddr(idx, scope_level);
      EmitPushX0;
      EmitMovX0(-1);
      EmitPopX1;
      { str x0, [x1] }
      WriteLn('    str x0, [x1]');
      Expect(TOK_RPAREN)
    End
    { reset = 114,101,115,101,116 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 115) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 116) Then
    Begin
      { reset(f) - open file For reading }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Get filename address (offset 16) And convert To C String }
      EmitVarAddr(idx, scope_level);
      EmitPushX0;  { save file Var base }
      { add x0, x0, #16 - point To filename }
      WriteLn('    add x0, x0, #16');
      { Convert Pascal String To C String: skip Length byte }
      WriteLn('    add x0, x0, #1');
      { open syscall: x0=path, x1=O_RDONLY(0), x2=mode(0) }
      WriteLn('    mov x1, #0');
      WriteLn('    mov x2, #0');
      { movz x16, #5; movk x16, #0x200, lsl #16 = 0x2000005 }
      WriteLn('    movz x16, #5');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { Store fd In file variable (offset 0) }
      EmitPopX1;  { x1 = file Var base }
      { str x0, [x1] }
      WriteLn('    str x0, [x1]');
      { Store mode=1 (Read) at offset 8 }
      WriteLn('    mov x0, #1');
      { str x0, [x1, #8] }
      WriteLn('    str x0, [x1, #8]');
    End
    { rewrite = 114,101,119,114,105,116,101 }
    Else If (tok_len = 7) And (ToLower(tok_str[0]) = 114) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 119) And (ToLower(tok_str[3]) = 114) And (ToLower(tok_str[4]) = 105) And
            (ToLower(tok_str[5]) = 116) And (ToLower(tok_str[6]) = 101) Then
    Begin
      { rewrite(f) - open/create file For writing }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Get filename address (offset 16) And convert To C String }
      EmitVarAddr(idx, scope_level);
      EmitPushX0;  { save file Var base }
      { add x0, x0, #16 - point To filename }
      WriteLn('    add x0, x0, #16');
      { Convert Pascal String To C String: skip Length byte }
      WriteLn('    add x0, x0, #1');
      { open syscall: x0=path, x1=O_WRONLY|O_CREAT|O_TRUNC(1537), x2=mode(420) }
      { mov x1, #1537 }
      WriteLn('    mov x1, #1537');
      { mov x2, #420 }
      WriteLn('    mov x2, #420');
      { movz x16, #5; movk x16, #0x200, lsl #16 = 0x2000005 }
      WriteLn('    movz x16, #5');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { Store fd In file variable (offset 0) }
      EmitPopX1;  { x1 = file Var base }
      { str x0, [x1] }
      WriteLn('    str x0, [x1]');
      { Store mode=2 (Write) at offset 8 }
      WriteLn('    mov x0, #2');
      { str x0, [x1, #8] }
      WriteLn('    str x0, [x1, #8]');
    End
    { close = 99,108,111,115,101 }
    Else If (tok_len = 5) And (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 108) And
            (ToLower(tok_str[2]) = 111) And (ToLower(tok_str[3]) = 115) And (ToLower(tok_str[4]) = 101) Then
    Begin
      { close(f) - close file }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Load fd from file variable }
      EmitVarAddr(idx, scope_level);
      { ldr x0, [x0] - load fd }
      WriteLn('    ldr x0, [x0]');
      { close syscall: x0=fd }
      { movz x16, #6; movk x16, #0x200, lsl #16 = 0x2000006 }
      WriteLn('    movz x16, #6');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { Set fd To -1 To mark as closed }
      EmitVarAddr(idx, scope_level);
      EmitPushX0;
      EmitMovX0(-1);
      EmitPopX1;
      { str x0, [x1] }
      WriteLn('    str x0, [x1]');
      { Set mode To 0 (closed) at offset 8 }
      WriteLn('    mov x0, #0');
      { str x0, [x1, #8] }
      WriteLn('    str x0, [x1, #8]');
    End
    { setinput = 115,101,116,105,110,112,117,116 }
    Else If (tok_len = 8) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 105) And (ToLower(tok_str[4]) = 110) And
            (ToLower(tok_str[5]) = 112) And (ToLower(tok_str[6]) = 117) And (ToLower(tok_str[7]) = 116) Then
    Begin
      { setinput(f) - Set input file descriptor from Text file variable }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If sym_type[idx] <> TYPE_TEXT Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Load fd from file variable And store In x19 }
      EmitVarAddr(idx, scope_level);
      { ldr x19, [x0] }
      WriteLn('    ldr x19, [x0]');
    End
    { setoutput = 115,101,116,111,117,116,112,117,116 }
    Else If (tok_len = 9) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 111) And (ToLower(tok_str[4]) = 117) And
            (ToLower(tok_str[5]) = 116) And (ToLower(tok_str[6]) = 112) And (ToLower(tok_str[7]) = 117) And
            (ToLower(tok_str[8]) = 116) Then
    Begin
      { setoutput(f) - Set output file descriptor from Text file variable }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If sym_type[idx] <> TYPE_TEXT Then
        Error(9);
      NextToken;
      Expect(TOK_RPAREN);
      { Load fd from file variable And store In x20 }
      EmitVarAddr(idx, scope_level);
      { ldr x20, [x0] }
      WriteLn('    ldr x20, [x0]');
    End
    { setinputfd = 115,101,116,105,110,112,117,116,102,100 (10 chars) }
    Else If (tok_len = 10) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 105) And (ToLower(tok_str[4]) = 110) And
            (ToLower(tok_str[5]) = 112) And (ToLower(tok_str[6]) = 117) And (ToLower(tok_str[7]) = 116) And
            (ToLower(tok_str[8]) = 102) And (ToLower(tok_str[9]) = 100) Then
    Begin
      { setinputfd(fd) - Set input file descriptor directly from Integer }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { mov x19, x0 }
      WriteLn('    mov x19, x0');
    End
    { setoutputfd = 115,101,116,111,117,116,112,117,116,102,100 (11 chars) }
    Else If (tok_len = 11) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 116) And (ToLower(tok_str[3]) = 111) And (ToLower(tok_str[4]) = 117) And
            (ToLower(tok_str[5]) = 116) And (ToLower(tok_str[6]) = 112) And (ToLower(tok_str[7]) = 117) And
            (ToLower(tok_str[8]) = 116) And (ToLower(tok_str[9]) = 102) And (ToLower(tok_str[10]) = 100) Then
    Begin
      { setoutputfd(fd) - Set output file descriptor directly from Integer }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { mov x20, x0 }
      WriteLn('    mov x20, x0');
    End
    { closefd = 99,108,111,115,101,102,100 (7 chars) }
    Else If (tok_len = 7) And (ToLower(tok_str[0]) = 99) And (ToLower(tok_str[1]) = 108) And
            (ToLower(tok_str[2]) = 111) And (ToLower(tok_str[3]) = 115) And (ToLower(tok_str[4]) = 101) And
            (ToLower(tok_str[5]) = 102) And (ToLower(tok_str[6]) = 100) Then
    Begin
      { closefd(fd) - close a file descriptor }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;
      Expect(TOK_RPAREN);
      { x0 = fd To close }
      { close syscall: x16 = 0x2000006 }
      WriteLn('    movz x16, #6');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc
    End
    { writefd = 119,114,105,116,101,102,100 (7 chars) }
    Else If (tok_len = 7) And (ToLower(tok_str[0]) = 119) And (ToLower(tok_str[1]) = 114) And
            (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 101) And
            (ToLower(tok_str[5]) = 102) And (ToLower(tok_str[6]) = 100) Then
    Begin
      { writefd(fd, Char) - Write one Char To fd }
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;  { fd }
      EmitPushX0;
      Expect(TOK_COMMA);
      ParseExpression;  { Char }
      { x0 = Char, stack top = fd }
      { sub sp, sp, #16; strb w0, [sp] - store Char In buffer }
      WriteLn('    sub sp, sp, #16');
      { strb w0, [sp] }
      WriteLn('    strb w0, [sp]');
      { ldr x0, [sp, #16] - load fd from saved position }
      WriteLn('    ldr x0, [sp, #16]');
      { mov x1, sp - buffer address }
      WriteLn('    mov x1, sp');
      { mov x2, #1 - Write 1 byte }
      WriteLn('    mov x2, #1');
      { Write syscall: x16 = 0x2000004 }
      WriteLn('    movz x16, #4');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      { add sp, sp, #32 - restore stack (16 For buffer + 16 For saved fd) }
      WriteLn('    add sp, sp, #32');
      Expect(TOK_RPAREN)
    End
    { seek = 115,101,101,107 }
    Else If (tok_len = 4) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 101) And (ToLower(tok_str[3]) = 107) Then
    Begin
      { seek(f, pos) - move To position In file }
      NextToken;
      Expect(TOK_LPAREN);
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If (sym_type[idx] <> TYPE_FILE) And (sym_type[idx] <> TYPE_TEXT) Then
        Error(9);
      NextToken;
      Expect(TOK_COMMA);
      { Get file fd And save To x23 }
      EmitVarAddr(idx, scope_level);
      { ldr x0, [x0] - load fd }
      WriteLn('    ldr x0, [x0]');
      { Save fd To x23 }
      WriteLn('    mov x23, x0');
      { Parse position expression }
      ParseExpression;
      { x0 = position, x23 = fd }
      { mov x1, x0 (position To x1) }
      WriteLn('    mov x1, x0');
      { mov x0, x23 (fd To x0) }
      WriteLn('    mov x0, x23');
      { mov x2, #0 (SEEK_SET) }
      WriteLn('    mov x2, #0');
      { lseek syscall: 0x20000C7 }
      WriteLn('    movz x16, #0xC7');
      WriteLn('    movk x16, #0x200, lsl #16');
      EmitSvc;
      Expect(TOK_RPAREN)
    End
    { delete = 100,101,108,101,116,101 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 100) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 108) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 116) And
            (ToLower(tok_str[5]) = 101) Then
    Begin
      { delete(s, start, count) - remove chars from String }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: String variable }
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If sym_type[idx] <> TYPE_STRING Then
        Error(9);
      NextToken;
      EmitVarAddr(idx, scope_level);
      EmitPushX0;
      Expect(TOK_COMMA);
      { Second arg: start position }
      ParseExpression;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Third arg: count }
      ParseExpression;
      { x0=count, stack has String addr And start }
      WriteLn('    mov x2, x0');
      EmitPopX1;  { start }
      EmitPopX0;  { String addr }
      EmitBL(rt_str_delete);
      Expect(TOK_RPAREN)
    End
    { insert = 105,110,115,101,114,116 }
    Else If (tok_len = 6) And (ToLower(tok_str[0]) = 105) And (ToLower(tok_str[1]) = 110) And
            (ToLower(tok_str[2]) = 115) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 114) And
            (ToLower(tok_str[5]) = 116) Then
    Begin
      { insert(source, dest, pos) - insert source into dest at pos }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: source String }
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level);
        EmitPushX0
      End
      Else If tok_type = TOK_STRING Then
      Begin
        { String literal - allocate temp on heap }
        WriteLn('    mov x8, x21');
        EmitMovX0(tok_len);
        WriteLn('    strb w0, [x8]');
        For i := 0 To tok_len - 1 Do
        Begin
          EmitMovX0(tok_str[i]);
          Write('    strb w0, [x8, #'); Write(i + 1); WriteLn(']');
        End;
        WriteLn('    mov x0, x21');
        WriteLn('    add x21, x21, #256');
        EmitPushX0;
        NextToken
      End
      Else
        Error(9);
      Expect(TOK_COMMA);
      { Second arg: dest String variable }
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If sym_type[idx] <> TYPE_STRING Then
        Error(9);
      NextToken;
      EmitVarAddr(idx, scope_level);
      EmitPushX0;
      Expect(TOK_COMMA);
      { Third arg: position }
      ParseExpression;
      { x0=pos, stack has source And dest }
      WriteLn('    mov x2, x0');
      EmitPopX1;  { dest }
      EmitPopX0;  { source }
      EmitBL(rt_str_insert);
      Expect(TOK_RPAREN)
    End
    { str = 115,116,114 - but only If Not a local variable }
    Else If (tok_len = 3) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 116) And
            (ToLower(tok_str[2]) = 114) And (SymLookup < 0) Then
    Begin
      { str(n, s) - convert Integer n To String s }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: Integer expression }
      ParseExpression;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Second arg: String variable }
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      If sym_type[idx] <> TYPE_STRING Then
        Error(9);
      NextToken;
      EmitVarAddr(idx, scope_level);
      { x0 = String addr, pop Integer into x1 Then swap }
      WriteLn('    mov x1, x0');
      EmitPopX0;  { x0 = Integer value }
      { Now: x0 = Integer, x1 = String addr }
      EmitBL(rt_int_to_str);
      Expect(TOK_RPAREN)
    End
    { val = 118,97,108 - but only If Not a local variable }
    Else If (tok_len = 3) And (ToLower(tok_str[0]) = 118) And (ToLower(tok_str[1]) = 97) And
            (ToLower(tok_str[2]) = 108) And (SymLookup < 0) Then
    Begin
      { val(s, v, code) - convert String s To Integer v, error In code }
      NextToken;
      Expect(TOK_LPAREN);
      { First arg: String }
      If tok_type = TOK_IDENT Then
      Begin
        idx := SymLookup;
        If idx < 0 Then
          Error(3);
        If sym_type[idx] <> TYPE_STRING Then
          Error(9);
        NextToken;
        EmitVarAddr(idx, scope_level)
      End
      Else If tok_type = TOK_STRING Then
      Begin
        { String literal - allocate temp on heap }
        WriteLn('    mov x8, x21');
        EmitMovX0(tok_len);
        WriteLn('    strb w0, [x8]');
        For i := 0 To tok_len - 1 Do
        Begin
          EmitMovX0(tok_str[i]);
          Write('    strb w0, [x8, #'); Write(i + 1); WriteLn(']');
        End;
        WriteLn('    mov x0, x21');
        WriteLn('    add x21, x21, #256');
        NextToken
      End
      Else
        Error(9);
      { Call rt_str_to_int: x0=String addr -> x0=value, x1=error }
      EmitBL(rt_str_to_int);
      { Save both results: push error first (x1), Then value (x0) }
      EmitPushX1;
      EmitPushX0;
      Expect(TOK_COMMA);
      { Second arg: Integer variable To receive value }
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      NextToken;
      { Get address Of v into x0, move To x1, pop value, store }
      EmitVarAddr(idx, scope_level);
      WriteLn('    mov x1, x0');
      EmitPopX0;  { value }
      { str x0, [x1] }
      WriteLn('    str x0, [x1]');
      Expect(TOK_COMMA);
      { Third arg: Integer variable To receive error code }
      If tok_type <> TOK_IDENT Then
        Error(6);
      idx := SymLookup;
      If idx < 0 Then
        Error(3);
      NextToken;
      { Get address Of code into x0, move To x1, pop error, store }
      EmitVarAddr(idx, scope_level);
      WriteLn('    mov x1, x0');
      EmitPopX0;  { error }
      { str x0, [x1] }
      WriteLn('    str x0, [x1]');
      Expect(TOK_RPAREN)
    End
    { clrscr = 99,108,114,115,99,114 }
    Else If TokIs8(99, 108, 114, 115, 99, 114, 0, 0) = 1 Then
    Begin
      NextToken;
      EmitBL(rt_clrscr)
    End
    { gotoxy = 103,111,116,111,120,121 }
    Else If TokIs8(103, 111, 116, 111, 120, 121, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;    { x }
      EmitPushX0;
      Expect(TOK_COMMA);
      ParseExpression;    { y }
      EmitPopX1;          { x1=x, x0=y }
      EmitBL(rt_gotoxy);
      Expect(TOK_RPAREN)
    End
    { clreol = 99,108,114,101,111,108 }
    Else If TokIs8(99, 108, 114, 101, 111, 108, 0, 0) = 1 Then
    Begin
      NextToken;
      EmitBL(rt_clreol)
    End
    { textcolor = 116,101,120,116,99,111,108,111,114 (9 chars) }
    Else If (tok_len = 9) And (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 120) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 99) And
            (ToLower(tok_str[5]) = 111) And (ToLower(tok_str[6]) = 108) And (ToLower(tok_str[7]) = 111) And
            (ToLower(tok_str[8]) = 114) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;    { color code 0-7 }
      EmitBL(rt_textcolor);
      Expect(TOK_RPAREN)
    End
    { textbackground = 116,101,120,116,98,97,99,107,103,114,111,117,110,100 (14 chars) }
    Else If (tok_len = 14) And (ToLower(tok_str[0]) = 116) And (ToLower(tok_str[1]) = 101) And
            (ToLower(tok_str[2]) = 120) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 98) And
            (ToLower(tok_str[5]) = 97) And (ToLower(tok_str[6]) = 99) And (ToLower(tok_str[7]) = 107) And
            (ToLower(tok_str[8]) = 103) And (ToLower(tok_str[9]) = 114) And (ToLower(tok_str[10]) = 111) And
            (ToLower(tok_str[11]) = 117) And (ToLower(tok_str[12]) = 110) And (ToLower(tok_str[13]) = 100) Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;    { color code 0-7 }
      EmitBL(rt_textbackground);
      Expect(TOK_RPAREN)
    End
    { normvideo = 110,111,114,109,118,105,100,101,111 (9 chars) }
    Else If (tok_len = 9) And (ToLower(tok_str[0]) = 110) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 114) And (ToLower(tok_str[3]) = 109) And (ToLower(tok_str[4]) = 118) And
            (ToLower(tok_str[5]) = 105) And (ToLower(tok_str[6]) = 100) And (ToLower(tok_str[7]) = 101) And
            (ToLower(tok_str[8]) = 111) Then
    Begin
      NextToken;
      EmitBL(rt_normvideo)
    End
    { highvideo = 104,105,103,104,118,105,100,101,111 (9 chars) }
    Else If (tok_len = 9) And (ToLower(tok_str[0]) = 104) And (ToLower(tok_str[1]) = 105) And
            (ToLower(tok_str[2]) = 103) And (ToLower(tok_str[3]) = 104) And (ToLower(tok_str[4]) = 118) And
            (ToLower(tok_str[5]) = 105) And (ToLower(tok_str[6]) = 100) And (ToLower(tok_str[7]) = 101) And
            (ToLower(tok_str[8]) = 111) Then
    Begin
      NextToken;
      EmitBL(rt_highvideo)
    End
    { lowvideo = 108,111,119,118,105,100,101,111 (8 chars) }
    Else If TokIs8(108, 111, 119, 118, 105, 100, 101, 111) = 1 Then
    Begin
      NextToken;
      EmitBL(rt_lowvideo)
    End
    { hidecursor = 104,105,100,101,99,117,114,115,111,114 (10 chars) }
    Else If (tok_len = 10) And (ToLower(tok_str[0]) = 104) And (ToLower(tok_str[1]) = 105) And
            (ToLower(tok_str[2]) = 100) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 99) And
            (ToLower(tok_str[5]) = 117) And (ToLower(tok_str[6]) = 114) And (ToLower(tok_str[7]) = 115) And
            (ToLower(tok_str[8]) = 111) And (ToLower(tok_str[9]) = 114) Then
    Begin
      NextToken;
      EmitBL(rt_hidecursor)
    End
    { showcursor = 115,104,111,119,99,117,114,115,111,114 (10 chars) }
    Else If (tok_len = 10) And (ToLower(tok_str[0]) = 115) And (ToLower(tok_str[1]) = 104) And
            (ToLower(tok_str[2]) = 111) And (ToLower(tok_str[3]) = 119) And (ToLower(tok_str[4]) = 99) And
            (ToLower(tok_str[5]) = 117) And (ToLower(tok_str[6]) = 114) And (ToLower(tok_str[7]) = 115) And
            (ToLower(tok_str[8]) = 111) And (ToLower(tok_str[9]) = 114) Then
    Begin
      NextToken;
      EmitBL(rt_showcursor)
    End
    { sleep = 115,108,101,101,112 (5 chars) - Sleep(ms) }
    Else If TokIs8(115, 108, 101, 101, 112, 0, 0, 0) = 1 Then
    Begin
      NextToken;
      Expect(TOK_LPAREN);
      ParseExpression;  { ms In x0 }
      EmitBL(rt_sleep);
      Expect(TOK_RPAREN)
    End
    { initkeyboard = 105,110,105,116,107,101,121,98,111,97,114,100 (12 chars) }
    Else If (tok_len = 12) And (ToLower(tok_str[0]) = 105) And (ToLower(tok_str[1]) = 110) And
            (ToLower(tok_str[2]) = 105) And (ToLower(tok_str[3]) = 116) And (ToLower(tok_str[4]) = 107) And
            (ToLower(tok_str[5]) = 101) And (ToLower(tok_str[6]) = 121) And (ToLower(tok_str[7]) = 98) And
            (ToLower(tok_str[8]) = 111) And (ToLower(tok_str[9]) = 97) And (ToLower(tok_str[10]) = 114) And
            (ToLower(tok_str[11]) = 100) Then
    Begin
      NextToken;
      EmitBL(rt_initkeyboard)
    End
    { donekeyboard = 100,111,110,101,107,101,121,98,111,97,114,100 (12 chars) }
    Else If (tok_len = 12) And (ToLower(tok_str[0]) = 100) And (ToLower(tok_str[1]) = 111) And
            (ToLower(tok_str[2]) = 110) And (ToLower(tok_str[3]) = 101) And (ToLower(tok_str[4]) = 107) And
            (ToLower(tok_str[5]) = 101) And (ToLower(tok_str[6]) = 121) And (ToLower(tok_str[7]) = 98) And
            (ToLower(tok_str[8]) = 111) And (ToLower(tok_str[9]) = 97) And (ToLower(tok_str[10]) = 114) And
            (ToLower(tok_str[11]) = 100) Then
    Begin
      NextToken;
      EmitBL(rt_donekeyboard)
    End
    Else
    Begin
      { Check For With context - try To find identifier as a field }
      If with_rec_idx >= 0 Then
      Begin
        arg_count := FindField(with_rec_type);  { reuse arg_count For field_idx }
        If arg_count >= 0 Then
        Begin
          { Found field - handle assignment }
          NextToken;
          Expect(TOK_ASSIGN);
          ParseExpression;  { value In x0 Or d0 }
          { Compute address: base + field_offset }
          If field_type[arg_count] = TYPE_REAL Then
          Begin
            { Value is In d0, need To store To field }
            If expr_type <> TYPE_REAL Then
              EmitScvtfD0X0;
            EmitPushD0;  { save value }
          End
          Else
            EmitPushX0;  { save value }
          { Compute address }
          If sym_level[with_rec_idx] < scope_level Then
          Begin
            EmitFollowChain(sym_level[with_rec_idx], scope_level);
            WriteLn('    add x1, x8, #');
          End
          Else
          Begin
            WriteLn('    add x1, x29, #');
          End;
          { Store value To field }
          If field_type[arg_count] = TYPE_REAL Then
          Begin
            EmitPopD0;
            { str d0, [x1] }
            WriteLn('    str d0, [x1]');
          End
          Else
          Begin
            EmitPopX0;
            { str x0, [x1] }
            WriteLn('    str x0, [x1]');
          End
        End
        Else
        Begin
          { Field Not found, proceed With normal lookup }
          idx := SymLookup;
          If idx < 0 Then
            Error(3)
        End
      End
      Else
      Begin
        { Not a built-In, look up In symbol table }
        idx := SymLookup;
        If idx < 0 Then
          Error(3)
      End;
      { Skip If we already handled With field assignment }
      If (with_rec_idx < 0) Or (arg_count < 0) Then
      Begin
      NextToken;

      If sym_kind[idx] = SYM_PROCEDURE Then
      Begin
        { Procedure call - pass args In x0-x7 }
        arg_count := 0;
        var_flags := sym_var_param_flags[idx];
        If tok_type = TOK_LPAREN Then
        Begin
          NextToken;
          If tok_type <> TOK_RPAREN Then
          Begin
            { Evaluate all args And push To stack }
            Repeat
              If tok_type = TOK_COMMA Then NextToken;
              { Check If this is a Var parameter }
              If IsVarParam(var_flags, arg_count) = 1 Then
              Begin
                { Var param - pass address Of variable }
                If tok_type <> TOK_IDENT Then
                  Error(6);  { Var param requires variable }
                var_arg_idx := SymLookup;
                If var_arg_idx < 0 Then
                  Error(3);
                NextToken;
                { Check For Array element - pass address Of element }
                If (sym_type[var_arg_idx] = TYPE_ARRAY) And (tok_type = TOK_LBRACKET) Then
                Begin
                  NextToken;  { consume '[' }
                  ParseExpression;  { index In x0 }
                  Expect(TOK_RBRACKET);
                  { Compute element address }
                  EmitPushX0;
                  EmitMovX0(sym_const_val[var_arg_idx]);  { low bound }
                  EmitPopX1;
                  { x0 = x1 - x0 = index - low_bound }
                  WriteLn('    sub x0, x1, x0');
                  { Multiply by 8 using lsl #3 }
                  WriteLn('    lsl x0, x0, #3');
                  { Get base address And subtract element offset }
                  If sym_level[var_arg_idx] < scope_level Then
                  Begin
                    EmitFollowChain(sym_level[var_arg_idx], scope_level);
                    EmitSubLargeOffset(1, 8, 0 - sym_offset[var_arg_idx])
                  End
                  Else
                    EmitSubLargeOffset(1, 29, 0 - sym_offset[var_arg_idx]);
                  { Address = base - element_offset }
                  WriteLn('    sub x0, x1, x0');
                End
                Else
                  { Simple variable - emit address }
                  EmitVarAddr(var_arg_idx, scope_level)
              End
              Else
              Begin
                { Value param - evaluate expression }
                ParseExpression
              End;
              EmitPushX0;
              arg_count := arg_count + 1
            Until tok_type <> TOK_COMMA
          End;
          Expect(TOK_RPAREN)
        End;
        { Pop args from stack into registers In reverse order }
        For i := arg_count - 1 DownTo 0 Do
        Begin
          Write('    ldr x'); Write(i); WriteLn(', [sp], #16');
        End;
        { Set up static link For callee }
        EmitStaticLink(sym_level[idx], scope_level);
        { Check If calling imported Unit Procedure }
        If sym_unit_idx[idx] >= 0 Then
          EmitBLUnitProc(sym_unit_idx[idx], idx)
        Else
          EmitBL(sym_label[idx])
      End
      Else If (sym_kind[idx] = SYM_VAR) Or (sym_kind[idx] = SYM_PARAM) Then
      Begin
        If (sym_type[idx] = TYPE_ARRAY) And (tok_type = TOK_LBRACKET) Then
        Begin
          { Array element assignment: arr[index] := expr Or arr[index].field := expr }
          NextToken;  { consume '[' }
          ParseExpression;  { index In x0 }
          Expect(TOK_RBRACKET);
          { Subtract low bound }
          EmitPushX0;
          EmitMovX0(sym_const_val[idx]);
          EmitPopX1;
          { x0 = x1 - x0 = index - low_bound }
          WriteLn('    sub x0, x1, x0');
          { Multiply by element size }
          If sym_var_param_flags[idx] > 0 Then
          Begin
            { Array Of records }
            lbl1 := sym_label[sym_var_param_flags[idx] - 1];
            EmitPushX0;
            EmitMovX0(lbl1);
            EmitPopX1;
            WriteLn('    mul x0, x1, x0');
          End
          Else
          Begin
            WriteLn('    lsl x0, x0, #3');
          End;
          { Get base address }
          If sym_level[idx] < scope_level Then
          Begin
            EmitFollowChain(sym_level[idx], scope_level);
            EmitSubLargeOffset(1, 8, 0 - sym_offset[idx])
          End
          Else
            EmitSubLargeOffset(1, 29, 0 - sym_offset[idx]);
          { x1 = base, x0 = offset, compute element address In x1 }
          WriteLn('    sub x1, x1, x0');
          { Check For field access }
          If (sym_var_param_flags[idx] > 0) And (tok_type = TOK_DOT) Then
          Begin
            NextToken;
            arg_count := FindField(sym_var_param_flags[idx] - 1);
            If arg_count < 0 Then
              Error(11);
            NextToken;
            { Add field offset }
            If field_offset[arg_count] > 0 Then
            Begin
              WriteLn('    add x1, x1, #');
            End;
            EmitPushX1;  { save field address }
            Expect(TOK_ASSIGN);
            ParseExpression;
            If field_type[arg_count] = TYPE_REAL Then
            Begin
              If expr_type <> TYPE_REAL Then
                EmitScvtfD0X0;
              EmitPopX1;
              WriteLn('    str d0, [x1]');
            End
            Else
            Begin
              EmitPopX1;
              WriteLn('    str x0, [x1]');
            End
          End
          Else
          Begin
            { Basic Array assignment }
            EmitPushX1;  { save element address }
            Expect(TOK_ASSIGN);
            ParseExpression;
            EmitPopX1;
            WriteLn('    str x0, [x1]');
          End
        End
        Else If (sym_type[idx] = TYPE_RECORD) And (tok_type = TOK_DOT) Then
        Begin
          { Record field assignment: rec.field := value Or rec.field.subfield := value }
          NextToken;  { consume '.' }
          If tok_type <> TOK_IDENT Then
            Error(11);
          { Find the field }
          arg_count := FindField(sym_const_val[idx]);  { reuse arg_count For field_idx }
          If arg_count < 0 Then
            Error(15);  { undefined field }
          { Accumulate total offset For nested fields }
          lbl1 := field_offset[arg_count];  { total offset from base }
          NextToken;
          { Handle nested Record fields }
          While (field_type[arg_count] = TYPE_RECORD) And (tok_type = TOK_DOT) Do
          Begin
            NextToken;  { consume '.' }
            If tok_type <> TOK_IDENT Then
              Error(11);
            lbl2 := arg_count;  { save current field index }
            arg_count := FindField(field_rec_type[lbl2]);
            If arg_count < 0 Then
              Error(15);
            lbl1 := lbl1 + field_offset[arg_count];  { accumulate offset }
            NextToken
          End;
          Expect(TOK_ASSIGN);
          ParseExpression;  { value In x0 Or d0 }

          { Compute field address: base + total_offset }
          If field_type[arg_count] = TYPE_REAL Then
          Begin
            { Value is In d0, need To store To field }
            If expr_type <> TYPE_REAL Then
              EmitScvtfD0X0;
            EmitPushD0;  { save value }
            { Compute address }
            If sym_level[idx] < scope_level Then
            Begin
              EmitFollowChain(sym_level[idx], scope_level);
              WriteLn('    add x0, x8, #');
            End
            Else
            Begin
              WriteLn('    add x0, x29, #');
            End;
            EmitPopD0;
            { str d0, [x0] }
            WriteLn('    str d0, [x0]');
          End
          Else
          Begin
            { Value is In x0 }
            EmitPushX0;  { save value }
            { Compute address }
            If sym_level[idx] < scope_level Then
            Begin
              EmitFollowChain(sym_level[idx], scope_level);
              WriteLn('    add x1, x8, #');
            End
            Else
            Begin
              WriteLn('    add x1, x29, #');
            End;
            EmitPopX0;
            { str x0, [x1] }
            WriteLn('    str x0, [x1]');
          End
        End
        Else If (sym_type[idx] = TYPE_POINTER) And (tok_type = TOK_CARET) Then
        Begin
          { Pointer dereference assignment: p^ := value Or pp^^ := value Or p^.field := value }
          { Count consecutive ^ tokens }
          lbl1 := 0;  { deref count }
          While tok_type = TOK_CARET Do
          Begin
            lbl1 := lbl1 + 1;
            NextToken
          End;
          { Load pointer value }
          If sym_level[idx] < scope_level Then
            EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
          Else
            EmitLdurX0(sym_offset[idx]);
          { Dereference (count-1) times To get target address }
          For i := 1 To lbl1 - 1 Do
          Begin
            WriteLn('    ldr x0, [x0]');
          End;
          { lbl2 = remaining pointer depth after all derefs }
          lbl2 := ptr_depth[idx] - lbl1;

          If (lbl2 = 0) And (ptr_ultimate_type[idx] = TYPE_RECORD) And (tok_type = TOK_DOT) Then
          Begin
            { Pointer To Record field assignment: p^.field := value Or p^.field.subfield := value }
            NextToken;  { consume '.' }
            { Find field In the Record Type }
            arg_count := FindField(ptr_ultimate_rec[idx]);
            If arg_count < 0 Then
              Error(11);  { unknown field }
            NextToken;  { consume field name }
            { Add field offset To pointer: x0 = x0 + offset }
            If field_offset[arg_count] > 0 Then
            Begin
              WriteLn('    add x0, x0, #');
            End;
            { Handle nested Record fields }
            While (field_type[arg_count] = TYPE_RECORD) And (tok_type = TOK_DOT) Do
            Begin
              NextToken;  { consume '.' }
              If tok_type <> TOK_IDENT Then
                Error(11);
              var_arg_idx := arg_count;  { save current field index }
              arg_count := FindField(field_rec_type[var_arg_idx]);
              If arg_count < 0 Then
                Error(15);
              If field_offset[arg_count] > 0 Then
              Begin
                WriteLn('    add x0, x0, #');
              End;
              NextToken
            End;
            EmitPushX0;  { save field address }
            Expect(TOK_ASSIGN);
            ParseExpression;  { value To store }
            If field_type[arg_count] = TYPE_REAL Then
            Begin
              If expr_type <> TYPE_REAL Then
                EmitScvtfD0X0;
              EmitPopX1;  { get address into x1 }
              { str d0, [x1] }
              WriteLn('    str d0, [x1]');
            End
            Else
            Begin
              EmitPopX1;  { get address into x1 }
              { str x0, [x1] }
              WriteLn('    str x0, [x1]');
            End
          End
          Else If (lbl2 = 0) And (ptr_ultimate_type[idx] = TYPE_ARRAY) And (tok_type = TOK_LBRACKET) Then
          Begin
            { Pointer To Array element assignment: pa^[i] := value }
            NextToken;  { consume '[' }
            EmitPushX0;  { save Array base address }
            ParseExpression;  { index In x0 }
            Expect(TOK_RBRACKET);
            { x0 = index, stack has base address }
            { Subtract low bound }
            arg_count := sym_label[idx];  { ptr_arr index }
            EmitPushX0;
            EmitMovX0(ptr_arr_lo[arg_count]);
            EmitPopX1;
            { x0 = x1 - x0 = index - low_bound }
            WriteLn('    sub x0, x1, x0');
            { Multiply by 8 using lsl #3 }
            WriteLn('    lsl x0, x0, #3');
            { Add To base: x0 = base + offset }
            EmitPopX1;  { x1 = base address }
            WriteLn('    add x8, x1, x0');
            { x8 now has element address }
            Expect(TOK_ASSIGN);
            ParseExpression;  { value To store }
            { Store value }
            If ptr_arr_elem[arg_count] = TYPE_REAL Then
            Begin
              If expr_type <> TYPE_REAL Then
                EmitScvtfD0X0;
              WriteLn('    str d0, [x8]');
            End
            Else
            Begin
              WriteLn('    str x0, [x8]');
            End
          End
          Else
          Begin
            { Simple pointer dereference assignment: p^ := value Or pp^^ := value }
            EmitPushX0;  { save address }
            Expect(TOK_ASSIGN);
            ParseExpression;  { value To store }
            { Determine target Type }
            If (lbl2 = 0) And (ptr_ultimate_type[idx] = TYPE_REAL) Then
            Begin
              { Value In d0, need To store through pointer }
              If expr_type <> TYPE_REAL Then
                EmitScvtfD0X0;
              EmitPopX1;  { get address into x1 }
              { str d0, [x1] }
              WriteLn('    str d0, [x1]');
            End
            Else
            Begin
              { Value In x0 }
              EmitPopX1;  { get address into x1 }
              { str x0, [x1] }
              WriteLn('    str x0, [x1]');
            End
          End
        End
        Else If sym_type[idx] = TYPE_STRING Then
        Begin
          { Check For String indexed assignment s[i] := Char }
          If tok_type = TOK_LBRACKET Then
          Begin
            NextToken;  { consume '[' }
            { Get String base address }
            EmitVarAddr(idx, scope_level);
            EmitPushX0;  { save base address }
            ParseExpression;  { index In x0 }
            Expect(TOK_RBRACKET);
            { Add index To base: address = base + index }
            EmitPopX1;  { x1 = base address }
            WriteLn('    add x8, x1, x0');
            { x8 now has the address To store To }
            Expect(TOK_ASSIGN);
            ParseExpression;  { value To store In x0 }
            { strb w0, [x8] }
            WriteLn('    strb w0, [x8]');
          End
          Else
          Begin
          { String assignment }
          Expect(TOK_ASSIGN);
          If tok_type = TOK_STRING Then
          Begin
            { Assign from String literal }
            { Compute base address Of String variable into x8 }
            If sym_level[idx] < scope_level Then
            Begin
              EmitFollowChain(sym_level[idx], scope_level);
              { add/sub x8, x8, #offset }
              If sym_offset[idx] < 0 Then
              Begin
                WriteLn('    sub x8, x8, #');
              End
              Else
              Begin
                WriteLn('    add x8, x8, #');
              End
            End
            Else
            Begin
              { add/sub x8, x29, #offset }
              If sym_offset[idx] < 0 Then
              Begin
                WriteLn('    sub x8, x29, #');
              End
              Else
              Begin
                WriteLn('    add x8, x29, #');
              End
            End;
            { Store Length at [x8] }
            EmitMovX0(tok_len);
            WriteLn('    strb w0, [x8]');
            { Store each character at [x8+1], [x8+2], etc }
            For i := 0 To tok_len - 1 Do
            Begin
              EmitMovX0(tok_str[i]);
              Write('    strb w0, [x8, #'); Write(i + 1); WriteLn(']');
            End;
            NextToken
          End
          Else
          Begin
            { Parse String expression (variable, copy, concat, Or + expressions) }
            ParseExpression;
            If expr_type <> TYPE_STRING Then
              Error(12);  { expected String }
            { x0 = source String address, copy To dest }
            WriteLn('    mov x1, x0');
            { Get dest address into x0 }
            EmitVarAddr(idx, scope_level);
            { Call rt_str_copy(x0=dest, x1=source) }
            EmitBL(rt_str_copy)
          End
          End  { End Of Else For String whole assignment }
        End
        Else If sym_type[idx] = TYPE_REAL Then
        Begin
          { Real variable assignment }
          Expect(TOK_ASSIGN);
          ParseExpression;
          { Convert Integer To float If needed }
          If expr_type <> TYPE_REAL Then
            EmitScvtfD0X0;
          { Check If this is a Var param - need To dereference address }
          If sym_is_var_param[idx] = 1 Then
          Begin
            { d0 has the value, need To store To address In Var param }
            EmitPushD0;  { save value }
            { Load the address stored In the Var param }
            If sym_level[idx] < scope_level Then
              EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            Else
              EmitLdurX0(sym_offset[idx]);
            { x0 now has the address, pop value To d0 }
            EmitPopD0;
            { Store d0 To [x0] }
            WriteLn('    str d0, [x0]');
          End
          Else
          Begin
            If sym_level[idx] < scope_level Then
              EmitSturD0Outer(sym_offset[idx], sym_level[idx], scope_level)
            Else
              EmitSturD0(sym_offset[idx])
          End
        End
        Else
        Begin
          { Simple Integer assignment }
          Expect(TOK_ASSIGN);
          ParseExpression;
          { Check If this is a Var param - need To dereference address }
          If sym_is_var_param[idx] = 1 Then
          Begin
            { x0 has the value, need To store To address In Var param }
            EmitPushX0;  { save value }
            { Load the address stored In the Var param }
            If sym_level[idx] < scope_level Then
              EmitLdurX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            Else
              EmitLdurX0(sym_offset[idx]);
            { x0 now has the address, pop value To x1 }
            EmitPopX1;
            { Store x1 To [x0] }
            WriteLn('    str x1, [x0]');
          End
          Else
          Begin
            If sym_level[idx] < scope_level Then
              EmitSturX0Outer(sym_offset[idx], sym_level[idx], scope_level)
            Else
              EmitSturX0(sym_offset[idx])
          End
        End
      End
      Else If sym_kind[idx] = SYM_FUNCTION Then
      Begin
        { Function result assignment - store To result variable at -16 }
        Expect(TOK_ASSIGN);
        ParseExpression;
        { For Real functions, store In d0 }
        If sym_type[idx] = TYPE_REAL Then
        Begin
          If expr_type <> TYPE_REAL Then
            EmitScvtfD0X0;
          EmitSturD0(-16)
        End
        Else If sym_type[idx] = TYPE_STRING Then
        Begin
          { String Function - x0 has source String addr, copy To heap For return }
          { x0 = source, x1 = dest (heap), call str_copy }
          WriteLn('    mov x8, x0');
          WriteLn('    mov x0, x21');
          { Save heap addr as result }
          EmitSturX0(-16);
          { x8 = dest, x9 = source For str_copy }
          WriteLn('    mov x9, x8');
          WriteLn('    mov x8, x21');
          EmitBL(rt_str_copy);
          { Advance heap pointer }
          WriteLn('    add x21, x21, #256');
        End
        Else
          EmitSturX0(-16)
      End
      Else
        Error(7)
      End  { End Of If (with_rec_idx < 0) Or (arg_count < 0) }
    End  { End Of Else For non-builtin identifier }
  End  { End Of Else If tok_type = TOK_IDENT }
End;


{ ----- Declarations ----- }

Procedure ParseVarDeclarations;
Var
  idx, first_idx, arr_size, lo_bound, hi_bound, j, base_idx: Integer;
Begin
  NextToken;  { consume 'Var' }
  While tok_type = TOK_IDENT Do
  Begin
    { Remember first Var In a group For fixing up Array size }
    local_offset := local_offset - 8;
    first_idx := SymAdd(SYM_VAR, TYPE_INTEGER, scope_level, local_offset);
    idx := first_idx;
    NextToken;
    While tok_type = TOK_COMMA Do
    Begin
      NextToken;
      If tok_type <> TOK_IDENT Then
        Error(8);
      local_offset := local_offset - 8;
      idx := SymAdd(SYM_VAR, TYPE_INTEGER, scope_level, local_offset);
      NextToken
    End;
    Expect(TOK_COLON);
    { Parse Type }
    If (tok_type = TOK_INTEGER_TYPE) Or (tok_type = TOK_CHAR_TYPE) Or
       (tok_type = TOK_BOOLEAN_TYPE) Then
      NextToken
    Else If tok_type = TOK_REAL_TYPE Then
    Begin
      { Set Type To Real For all vars In this group }
      For j := first_idx To idx Do
        sym_type[j] := TYPE_REAL;
      NextToken
    End
    Else If tok_type = TOK_ARRAY Then
    Begin
      NextToken;
      Expect(TOK_LBRACKET);
      { Parse low bound }
      If tok_type = TOK_INTEGER Then
      Begin
        lo_bound := tok_int;
        NextToken
      End
      Else
        Error(9);
      Expect(TOK_DOTDOT);
      { Parse high bound }
      If tok_type = TOK_INTEGER Then
      Begin
        hi_bound := tok_int;
        NextToken
      End
      Else
        Error(9);
      Expect(TOK_RBRACKET);
      Expect(TOK_OF);
      { Parse element Type }
      If (tok_type = TOK_INTEGER_TYPE) Or (tok_type = TOK_CHAR_TYPE) Or
         (tok_type = TOK_BOOLEAN_TYPE) Then
      Begin
        NextToken;
        arr_size := (hi_bound - lo_bound + 1) * 8;
        local_offset := local_offset - (arr_size - 8);
        sym_type[first_idx] := TYPE_ARRAY;
        sym_const_val[first_idx] := lo_bound;
        sym_label[first_idx] := arr_size;
        sym_var_param_flags[first_idx] := 0  { 0 = basic Type element }
      End
      Else If tok_type = TOK_IDENT Then
      Begin
        { Array Of Record Type }
        base_idx := SymLookup;
        If (base_idx >= 0) And (sym_kind[base_idx] = SYM_TYPEDEF) And (sym_type[base_idx] = TYPE_RECORD) Then
        Begin
          arr_size := (hi_bound - lo_bound + 1) * sym_label[base_idx];
          local_offset := local_offset - (arr_size - 8);
          sym_type[first_idx] := TYPE_ARRAY;
          sym_const_val[first_idx] := lo_bound;
          sym_label[first_idx] := arr_size;
          sym_var_param_flags[first_idx] := base_idx + 1;  { Record Type index + 1 (0 means basic) }
          NextToken
        End
        Else
          Error(9)
      End
      Else
        Error(9)
    End
    Else If tok_type = TOK_STRING_TYPE Then
    Begin
      { String Type: 256 bytes (1 Length byte + 255 Char bytes) }
      NextToken;
      { Handle all variables In the list }
      For j := first_idx To idx Do
      Begin
        sym_type[j] := TYPE_STRING;
        sym_label[j] := 256;  { Store size For reference }
        { Adjust offset: already allocated 8 bytes, need 248 more }
        If j = first_idx Then
        Begin
          local_offset := local_offset - 248;
          sym_offset[j] := local_offset  { Update offset To start Of 256-byte area }
        End
        Else
        Begin
          local_offset := local_offset - 256;
          sym_offset[j] := local_offset
        End
      End
    End
    Else If tok_type = TOK_TEXT Then
    Begin
      { Text file Type: 272 bytes (fd + mode + filename) }
      NextToken;
      For j := first_idx To idx Do
      Begin
        sym_type[j] := TYPE_TEXT;
        sym_const_val[j] := TYPE_CHAR;  { element Type is Char }
        sym_label[j] := 1;  { element size is 1 byte }
        { Adjust offset: already allocated 8 bytes, need 264 more For 272 total }
        If j = first_idx Then
        Begin
          local_offset := local_offset - 264;
          sym_offset[j] := local_offset
        End
        Else
        Begin
          local_offset := local_offset - 272;
          sym_offset[j] := local_offset
        End
      End
    End
    Else If tok_type = TOK_FILE Then
    Begin
      { Typed file: file Of T - 272 bytes (fd + mode + filename) }
      NextToken;
      Expect(TOK_OF);
      { Parse element Type }
      If tok_type = TOK_INTEGER_TYPE Then
      Begin
        base_idx := TYPE_INTEGER;
        arr_size := 8;
        NextToken
      End
      Else If tok_type = TOK_CHAR_TYPE Then
      Begin
        base_idx := TYPE_CHAR;
        arr_size := 1;
        NextToken
      End
      Else If tok_type = TOK_BOOLEAN_TYPE Then
      Begin
        base_idx := TYPE_BOOLEAN;
        arr_size := 1;
        NextToken
      End
      Else If tok_type = TOK_REAL_TYPE Then
      Begin
        base_idx := TYPE_REAL;
        arr_size := 8;
        NextToken
      End
      Else If tok_type = TOK_IDENT Then
      Begin
        { Record Type }
        lo_bound := SymLookup;
        If (lo_bound >= 0) And (sym_kind[lo_bound] = SYM_TYPEDEF) And (sym_type[lo_bound] = TYPE_RECORD) Then
        Begin
          base_idx := TYPE_RECORD;
          arr_size := sym_label[lo_bound];  { Record size }
          file_rec_idx[file_count] := lo_bound;
          NextToken
        End
        Else
          Error(14)
      End
      Else
        Error(9);
      { Store file Type info }
      file_elem_type[file_count] := base_idx;
      file_elem_size[file_count] := arr_size;
      For j := first_idx To idx Do
      Begin
        sym_type[j] := TYPE_FILE;
        sym_const_val[j] := file_count;  { index into file arrays }
        sym_label[j] := arr_size;  { element size }
        { Adjust offset For 272 bytes }
        If j = first_idx Then
        Begin
          local_offset := local_offset - 264;
          sym_offset[j] := local_offset
        End
        Else
        Begin
          local_offset := local_offset - 272;
          sym_offset[j] := local_offset
        End
      End;
      file_count := file_count + 1
    End
    Else If tok_type = TOK_SET Then
    Begin
      { Inline Set Type: Set Of Char / Set Of 0..63 }
      NextToken;  { consume 'Set' }
      Expect(TOK_OF);
      If tok_type = TOK_CHAR_TYPE Then
      Begin
        { Set Of Char - Uses 64-bit bitmask }
        For j := first_idx To idx Do
        Begin
          sym_type[j] := TYPE_SET;
          sym_const_val[j] := set_count
        End;
        set_base[set_count] := TYPE_CHAR;
        set_low[set_count] := 0;
        set_high[set_count] := 63;  { limited To 64 elements }
        set_count := set_count + 1;
        NextToken
      End
      Else If tok_type = TOK_INTEGER Then
      Begin
        { Set Of 0..N - inline subrange }
        lo_bound := tok_int;
        NextToken;
        Expect(TOK_DOTDOT);
        If tok_type <> TOK_INTEGER Then Error(9);
        hi_bound := tok_int;
        NextToken;
        For j := first_idx To idx Do
        Begin
          sym_type[j] := TYPE_SET;
          sym_const_val[j] := set_count
        End;
        set_base[set_count] := TYPE_INTEGER;
        set_low[set_count] := lo_bound;
        set_high[set_count] := hi_bound;
        set_count := set_count + 1
      End
      Else If tok_type = TOK_IDENT Then
      Begin
        { Set Of EnumType }
        base_idx := SymLookup;
        If (base_idx >= 0) And (sym_kind[base_idx] = SYM_TYPEDEF) And
           (sym_type[base_idx] = TYPE_ENUM) Then
        Begin
          For j := first_idx To idx Do
          Begin
            sym_type[j] := TYPE_SET;
            sym_const_val[j] := set_count
          End;
          set_base[set_count] := TYPE_ENUM;
          set_low[set_count] := 0;
          set_high[set_count] := sym_label[base_idx] - 1;  { enum count - 1 }
          set_count := set_count + 1;
          NextToken
        End
        Else
          Error(9)
      End
      Else
        Error(9)
    End
    Else If tok_type = TOK_CARET Then
    Begin
      { Pointer Type: ^BaseType Or ^^BaseType Or ^Array[lo..hi] Of T }
      NextToken;
      lo_bound := 1;  { reuse lo_bound For depth count }
      While tok_type = TOK_CARET Do
      Begin
        lo_bound := lo_bound + 1;
        NextToken
      End;
      { Check For pointer To Array }
      If tok_type = TOK_ARRAY Then
      Begin
        { ^Array[lo..hi] Of T }
        NextToken;  { consume 'Array' }
        Expect(TOK_LBRACKET);
        If tok_type <> TOK_INTEGER Then
          Error(9);
        hi_bound := tok_int;  { reuse hi_bound temporarily For low }
        NextToken;
        Expect(TOK_DOTDOT);
        If tok_type <> TOK_INTEGER Then
          Error(9);
        arr_size := tok_int;  { high bound }
        NextToken;
        Expect(TOK_RBRACKET);
        Expect(TOK_OF);
        { Parse element Type }
        If tok_type = TOK_INTEGER_TYPE Then
          base_idx := TYPE_INTEGER
        Else If tok_type = TOK_CHAR_TYPE Then
          base_idx := TYPE_CHAR
        Else If tok_type = TOK_BOOLEAN_TYPE Then
          base_idx := TYPE_BOOLEAN
        Else If tok_type = TOK_REAL_TYPE Then
          base_idx := TYPE_REAL
        Else
          base_idx := TYPE_INTEGER;  { default }
        { Store In ptr_arr arrays }
        ptr_arr_lo[ptr_arr_count] := hi_bound;
        ptr_arr_hi[ptr_arr_count] := arr_size;
        ptr_arr_elem[ptr_arr_count] := base_idx;
        ptr_arr_rec[ptr_arr_count] := 0;
        For j := first_idx To idx Do
        Begin
          sym_type[j] := TYPE_POINTER;
          sym_const_val[j] := TYPE_ARRAY;  { immediate base is Array }
          sym_label[j] := ptr_arr_count;   { index into ptr_arr arrays }
          ptr_depth[j] := lo_bound;
          ptr_ultimate_type[j] := TYPE_ARRAY;
          ptr_ultimate_rec[j] := 0
        End;
        ptr_arr_count := ptr_arr_count + 1;
        NextToken
      End
      { Now parse ultimate base Type }
      Else If tok_type = TOK_INTEGER_TYPE Then
      Begin
        For j := first_idx To idx Do
        Begin
          sym_type[j] := TYPE_POINTER;
          If lo_bound = 1 Then
            sym_const_val[j] := TYPE_INTEGER
          Else
            sym_const_val[j] := TYPE_POINTER;  { immediate base is pointer }
          ptr_depth[j] := lo_bound;
          ptr_ultimate_type[j] := TYPE_INTEGER;
          ptr_ultimate_rec[j] := 0
        End;
        NextToken
      End
      Else If tok_type = TOK_CHAR_TYPE Then
      Begin
        For j := first_idx To idx Do
        Begin
          sym_type[j] := TYPE_POINTER;
          If lo_bound = 1 Then
            sym_const_val[j] := TYPE_CHAR
          Else
            sym_const_val[j] := TYPE_POINTER;
          ptr_depth[j] := lo_bound;
          ptr_ultimate_type[j] := TYPE_CHAR;
          ptr_ultimate_rec[j] := 0
        End;
        NextToken
      End
      Else If tok_type = TOK_BOOLEAN_TYPE Then
      Begin
        For j := first_idx To idx Do
        Begin
          sym_type[j] := TYPE_POINTER;
          If lo_bound = 1 Then
            sym_const_val[j] := TYPE_BOOLEAN
          Else
            sym_const_val[j] := TYPE_POINTER;
          ptr_depth[j] := lo_bound;
          ptr_ultimate_type[j] := TYPE_BOOLEAN;
          ptr_ultimate_rec[j] := 0
        End;
        NextToken
      End
      Else If tok_type = TOK_REAL_TYPE Then
      Begin
        For j := first_idx To idx Do
        Begin
          sym_type[j] := TYPE_POINTER;
          If lo_bound = 1 Then
            sym_const_val[j] := TYPE_REAL
          Else
            sym_const_val[j] := TYPE_POINTER;
          ptr_depth[j] := lo_bound;
          ptr_ultimate_type[j] := TYPE_REAL;
          ptr_ultimate_rec[j] := 0
        End;
        NextToken
      End
      Else If tok_type = TOK_IDENT Then
      Begin
        { Pointer To Record Type: ^RecordType Or ^^RecordType etc }
        arr_size := SymLookup;  { reuse arr_size as type_idx }
        If (arr_size >= 0) And (sym_kind[arr_size] = SYM_TYPEDEF) And (sym_type[arr_size] = TYPE_RECORD) Then
        Begin
          For j := first_idx To idx Do
          Begin
            sym_type[j] := TYPE_POINTER;
            If lo_bound = 1 Then
              sym_const_val[j] := TYPE_RECORD
            Else
              sym_const_val[j] := TYPE_POINTER;
            sym_label[j] := arr_size;  { store Record Type index }
            ptr_depth[j] := lo_bound;
            ptr_ultimate_type[j] := TYPE_RECORD;
            ptr_ultimate_rec[j] := arr_size
          End;
          NextToken
        End
        Else
          Error(14)  { expected Type identifier }
      End
      Else
        Error(14)  { expected Type identifier }
    End
    Else If tok_type = TOK_IDENT Then
    Begin
      { May be a Record, enum, subrange, Or Set Type name }
      arr_size := SymLookup;  { reuse arr_size as type_idx temporarily }
      If (arr_size >= 0) And (sym_kind[arr_size] = SYM_TYPEDEF) Then
      Begin
        If sym_type[arr_size] = TYPE_RECORD Then
        Begin
          { Allocate space For Record }
          lo_bound := sym_label[arr_size];  { reuse lo_bound For Record size }
          { Adjust local_offset: we already allocated 8 bytes, need rest }
          local_offset := local_offset - (lo_bound - 8);
          For j := first_idx To idx Do
          Begin
            sym_type[j] := TYPE_RECORD;
            sym_const_val[j] := arr_size  { link To Type definition }
          End
        End
        Else If sym_type[arr_size] = TYPE_ENUM Then
        Begin
          { Enum variables use 8 bytes (same as Integer) }
          For j := first_idx To idx Do
          Begin
            sym_type[j] := TYPE_ENUM;
            sym_const_val[j] := arr_size  { link To Type definition }
          End
        End
        Else If sym_type[arr_size] = TYPE_SUBRANGE Then
        Begin
          { Subrange variables use 8 bytes (same as Integer) }
          For j := first_idx To idx Do
          Begin
            sym_type[j] := TYPE_SUBRANGE;
            sym_const_val[j] := arr_size  { link To Type definition }
          End
        End
        Else If sym_type[arr_size] = TYPE_SET Then
        Begin
          { Set variables use 8 bytes (64-bit bitmask) }
          For j := first_idx To idx Do
          Begin
            sym_type[j] := TYPE_SET;
            sym_const_val[j] := arr_size  { link To Type definition }
          End
        End
        Else
          Error(9);
        NextToken
      End
      Else
        Error(9)
    End
    Else
      Error(9);
    Expect(TOK_SEMICOLON)
  End
End;

Procedure ParseConstDeclarations;
Var
  idx: Integer;
Begin
  NextToken;  { consume 'Const' }
  While tok_type = TOK_IDENT Do
  Begin
    idx := SymAdd(SYM_CONST, TYPE_INTEGER, scope_level, 0);
    NextToken;
    Expect(TOK_EQ);
    If tok_type = TOK_INTEGER Then
    Begin
      sym_const_val[idx] := tok_int;
      NextToken
    End
    Else
      Error(10);
    Expect(TOK_SEMICOLON)
  End
End;

Procedure ParseTypeDeclarations;
Var
  type_idx, fld_start, fld_offset, fld_type: Integer;
  i, base_idx, nested_idx, nested_size, first_fld: Integer;
  enum_val, lo_val, hi_val, set_base_type: Integer;
Begin
  NextToken;  { consume 'Type' }
  While tok_type = TOK_IDENT Do
  Begin
    { Create Type symbol - will Set actual Type later }
    type_idx := SymAdd(SYM_TYPEDEF, TYPE_RECORD, scope_level, 0);
    NextToken;
    Expect(TOK_EQ);

    If tok_type = TOK_RECORD Then
    Begin
      { Record Type }
      NextToken;  { consume 'Record' }
      fld_start := field_count;
      fld_offset := 0;
      sym_const_val[type_idx] := fld_start;  { first field index }

      { Parse fields Until 'End' Or 'Case' (variant part) }
      While (tok_type <> TOK_END) And (tok_type <> TOK_CASE) Do
      Begin
        { Collect field names (may be comma-separated) }
        first_fld := field_count;
        Repeat
          If tok_type <> TOK_IDENT Then
            Error(11);

          { Save field name }
          base_idx := field_count * 32;
          For i := 0 To tok_len - 1 Do
            field_name[base_idx + i] := tok_str[i];
          field_name[base_idx + tok_len] := 0;
          field_count := field_count + 1;

          NextToken;
          If tok_type = TOK_COMMA Then
            NextToken
        Until tok_type = TOK_COLON;

        Expect(TOK_COLON);

        { Parse field Type }
        nested_size := 8;  { default For basic types }
        If tok_type = TOK_INTEGER_TYPE Then
        Begin
          fld_type := TYPE_INTEGER;
          nested_idx := 0;
          NextToken
        End
        Else If tok_type = TOK_CHAR_TYPE Then
        Begin
          fld_type := TYPE_CHAR;
          nested_idx := 0;
          NextToken
        End
        Else If tok_type = TOK_BOOLEAN_TYPE Then
        Begin
          fld_type := TYPE_BOOLEAN;
          nested_idx := 0;
          NextToken
        End
        Else If tok_type = TOK_REAL_TYPE Then
        Begin
          fld_type := TYPE_REAL;
          nested_idx := 0;
          NextToken
        End
        Else If tok_type = TOK_IDENT Then
        Begin
          { Nested Record Type Or enum Type }
          nested_idx := SymLookup;
          If (nested_idx >= 0) And (sym_kind[nested_idx] = SYM_TYPEDEF) Then
          Begin
            If sym_type[nested_idx] = TYPE_RECORD Then
            Begin
              fld_type := TYPE_RECORD;
              nested_size := sym_label[nested_idx]
            End
            Else If sym_type[nested_idx] = TYPE_ENUM Then
              fld_type := TYPE_ENUM
            Else If sym_type[nested_idx] = TYPE_SUBRANGE Then
              fld_type := TYPE_SUBRANGE
            Else If sym_type[nested_idx] = TYPE_SET Then
              fld_type := TYPE_SET
            Else
              Error(9);
            NextToken
          End
          Else
            Error(9)
        End
        Else
          Error(9);

        { Apply Type To all collected field names }
        For i := first_fld To field_count - 1 Do
        Begin
          field_type[i] := fld_type;
          field_offset[i] := fld_offset;
          field_rec_idx[i] := type_idx;
          field_rec_type[i] := nested_idx;
          If fld_type = TYPE_RECORD Then
            fld_offset := fld_offset + nested_size
          Else
            fld_offset := fld_offset + 8
        End;

        { Expect semicolon Or End }
        If tok_type = TOK_SEMICOLON Then
          NextToken
      End;

      { Check For variant part }
      If tok_type = TOK_CASE Then
      Begin
        NextToken;  { consume 'Case' }

        { Check For tag field: "Case tag: Type Of" vs "Case Type Of" }
        If tok_type = TOK_IDENT Then
        Begin
          { Could be "tag: Type" Or just "Type" - peek ahead }
          { Save identifier For potential tag field }
          base_idx := field_count * 32;
          For i := 0 To tok_len - 1 Do
            field_name[base_idx + i] := tok_str[i];
          field_name[base_idx + tok_len] := 0;

          NextToken;
          If tok_type = TOK_COLON Then
          Begin
            { It's a tag field }
            field_count := field_count + 1;
            NextToken;
            { Parse tag Type }
            If tok_type = TOK_INTEGER_TYPE Then
              fld_type := TYPE_INTEGER
            Else If tok_type = TOK_CHAR_TYPE Then
              fld_type := TYPE_CHAR
            Else If tok_type = TOK_BOOLEAN_TYPE Then
              fld_type := TYPE_BOOLEAN
            Else
              fld_type := TYPE_INTEGER;  { default }
            NextToken;

            { Record tag field }
            field_type[field_count - 1] := fld_type;
            field_offset[field_count - 1] := fld_offset;
            field_rec_idx[field_count - 1] := type_idx;
            field_rec_type[field_count - 1] := 0;
            fld_offset := fld_offset + 8
          End
          { Else: identifier was the Type name, already consumed }
        End
        Else
          NextToken;  { consume Type keyword }

        Expect(TOK_OF);

        { variant_start marks where all variants Begin }
        nested_idx := fld_offset;  { reuse as variant_start }
        nested_size := 0;          { reuse as max_variant_size }

        { Parse variant alternatives }
        While tok_type <> TOK_END Do
        Begin
          { Skip constant label(s) }
          While (tok_type <> TOK_COLON) And (tok_type <> TOK_END) Do
            NextToken;

          If tok_type = TOK_COLON Then
          Begin
          NextToken;  { consume ':' }
          Expect(TOK_LPAREN);

          { Parse fields In this variant - all start at variant_start }
          fld_offset := nested_idx;  { reset To variant start }

          While tok_type <> TOK_RPAREN Do
          Begin
            { Collect field names }
            first_fld := field_count;
            Repeat
              If tok_type <> TOK_IDENT Then
                Error(11);
              base_idx := field_count * 32;
              For i := 0 To tok_len - 1 Do
                field_name[base_idx + i] := tok_str[i];
              field_name[base_idx + tok_len] := 0;
              field_count := field_count + 1;
              NextToken;
              If tok_type = TOK_COMMA Then
                NextToken
            Until tok_type = TOK_COLON;

            Expect(TOK_COLON);

            { Parse field Type }
            lo_val := 8;  { reuse as field_size }
            If tok_type = TOK_INTEGER_TYPE Then
              fld_type := TYPE_INTEGER
            Else If tok_type = TOK_CHAR_TYPE Then
              fld_type := TYPE_CHAR
            Else If tok_type = TOK_BOOLEAN_TYPE Then
              fld_type := TYPE_BOOLEAN
            Else If tok_type = TOK_REAL_TYPE Then
              fld_type := TYPE_REAL
            Else If tok_type = TOK_IDENT Then
            Begin
              hi_val := SymLookup;  { reuse as lookup result }
              If (hi_val >= 0) And (sym_kind[hi_val] = SYM_TYPEDEF) Then
              Begin
                If sym_type[hi_val] = TYPE_RECORD Then
                Begin
                  fld_type := TYPE_RECORD;
                  lo_val := sym_label[hi_val]
                End
                Else
                  fld_type := sym_type[hi_val]
              End
              Else
                fld_type := TYPE_INTEGER
            End
            Else
              fld_type := TYPE_INTEGER;
            NextToken;

            { Record fields }
            For i := first_fld To field_count - 1 Do
            Begin
              field_type[i] := fld_type;
              field_offset[i] := fld_offset;
              field_rec_idx[i] := type_idx;
              If fld_type = TYPE_RECORD Then
                field_rec_type[i] := hi_val
              Else
                field_rec_type[i] := 0;
              fld_offset := fld_offset + lo_val
            End;

            If tok_type = TOK_SEMICOLON Then
              NextToken
          End;

          NextToken;  { consume ')' }

          { Track max variant size }
          If (fld_offset - nested_idx) > nested_size Then
            nested_size := fld_offset - nested_idx;

          If tok_type = TOK_SEMICOLON Then
            NextToken
          End  { End If tok_type = TOK_COLON }
        End;

        fld_offset := nested_idx + nested_size  { final size }
      End;

      NextToken;  { consume 'End' }
      sym_label[type_idx] := fld_offset  { total Record size }
    End
    Else If tok_type = TOK_LPAREN Then
    Begin
      { Enumerated Type: (Red, Green, Blue) }
      sym_type[type_idx] := TYPE_ENUM;
      sym_const_val[type_idx] := enum_count;  { index into enum arrays }
      enum_low[enum_count] := 0;
      enum_val := 0;
      NextToken;  { consume '(' }
      While tok_type <> TOK_RPAREN Do
      Begin
        If tok_type <> TOK_IDENT Then
          Error(11);
        { Add enum value as a constant }
        base_idx := SymAdd(SYM_CONST, TYPE_ENUM, scope_level, 0);
        sym_const_val[base_idx] := enum_val;
        sym_label[base_idx] := type_idx;  { link To enum Type }
        enum_val := enum_val + 1;
        NextToken;
        If tok_type = TOK_COMMA Then
          NextToken
      End;
      enum_high[enum_count] := enum_val - 1;
      sym_label[type_idx] := enum_val;  { number Of values }
      enum_count := enum_count + 1;
      NextToken  { consume ')' }
    End
    Else If tok_type = TOK_SET Then
    Begin
      { Set Type: Set Of Char / Set Of EnumType / Set Of 0..63 }
      sym_type[type_idx] := TYPE_SET;
      NextToken;  { consume 'Set' }
      Expect(TOK_OF);
      sym_const_val[type_idx] := set_count;  { index into Set arrays }
      If tok_type = TOK_CHAR_TYPE Then
      Begin
        set_base[set_count] := TYPE_CHAR;
        set_low[set_count] := 0;
        set_high[set_count] := 255;
        NextToken
      End
      Else If tok_type = TOK_IDENT Then
      Begin
        base_idx := SymLookup;
        If (base_idx >= 0) And (sym_kind[base_idx] = SYM_TYPEDEF) Then
        Begin
          If sym_type[base_idx] = TYPE_ENUM Then
          Begin
            set_base[set_count] := TYPE_ENUM;
            nested_idx := sym_const_val[base_idx];  { enum index }
            set_low[set_count] := enum_low[nested_idx];
            set_high[set_count] := enum_high[nested_idx]
          End
          Else If sym_type[base_idx] = TYPE_SUBRANGE Then
          Begin
            set_base[set_count] := TYPE_SUBRANGE;
            nested_idx := sym_const_val[base_idx];  { subrange index }
            set_low[set_count] := subr_low[nested_idx];
            set_high[set_count] := subr_high[nested_idx]
          End
          Else
            Error(9);
          NextToken
        End
        Else
          Error(9)
      End
      Else If tok_type = TOK_INTEGER Then
      Begin
        { Set Of 0..63 - inline subrange }
        lo_val := tok_int;
        NextToken;
        Expect(TOK_DOTDOT);
        If tok_type <> TOK_INTEGER Then
          Error(9);
        hi_val := tok_int;
        If hi_val - lo_val > 63 Then
          Error(16);  { Set too large }
        set_base[set_count] := TYPE_SUBRANGE;
        set_low[set_count] := lo_val;
        set_high[set_count] := hi_val;
        NextToken
      End
      Else
        Error(9);
      set_count := set_count + 1
    End
    Else If (tok_type = TOK_INTEGER) Or (tok_type = TOK_MINUS) Then
    Begin
      { Subrange Type: 0..9 Or -10..10 }
      If tok_type = TOK_MINUS Then
      Begin
        NextToken;
        If tok_type <> TOK_INTEGER Then
          Error(9);
        lo_val := 0 - tok_int
      End
      Else
        lo_val := tok_int;
      NextToken;
      Expect(TOK_DOTDOT);
      If tok_type = TOK_MINUS Then
      Begin
        NextToken;
        If tok_type <> TOK_INTEGER Then
          Error(9);
        hi_val := 0 - tok_int
      End
      Else If tok_type = TOK_INTEGER Then
        hi_val := tok_int
      Else
        Error(9);
      sym_type[type_idx] := TYPE_SUBRANGE;
      sym_const_val[type_idx] := subr_count;  { index into subrange arrays }
      subr_low[subr_count] := lo_val;
      subr_high[subr_count] := hi_val;
      subr_base[subr_count] := TYPE_INTEGER;
      sym_label[type_idx] := hi_val - lo_val + 1;  { number Of values }
      subr_count := subr_count + 1;
      NextToken
    End
    Else If tok_type = TOK_IDENT Then
    Begin
      { Could be alias To another Type, Or subrange Of enum }
      base_idx := SymLookup;
      If base_idx >= 0 Then
      Begin
        If sym_kind[base_idx] = SYM_CONST Then
        Begin
          { Subrange starting With enum constant }
          lo_val := sym_const_val[base_idx];
          nested_idx := sym_label[base_idx];  { enum Type }
          NextToken;
          Expect(TOK_DOTDOT);
          If tok_type <> TOK_IDENT Then
            Error(9);
          base_idx := SymLookup;
          If (base_idx < 0) Or (sym_kind[base_idx] <> SYM_CONST) Then
            Error(9);
          hi_val := sym_const_val[base_idx];
          sym_type[type_idx] := TYPE_SUBRANGE;
          sym_const_val[type_idx] := subr_count;
          subr_low[subr_count] := lo_val;
          subr_high[subr_count] := hi_val;
          subr_base[subr_count] := TYPE_ENUM;
          sym_label[type_idx] := hi_val - lo_val + 1;
          subr_count := subr_count + 1;
          NextToken
        End
        Else If sym_kind[base_idx] = SYM_TYPEDEF Then
        Begin
          { Type alias - copy the Type info }
          sym_type[type_idx] := sym_type[base_idx];
          sym_const_val[type_idx] := sym_const_val[base_idx];
          sym_label[type_idx] := sym_label[base_idx];
          NextToken
        End
        Else
          Error(9)
      End
      Else
        Error(9)
    End
    Else
      Error(9);
    Expect(TOK_SEMICOLON)
  End
End;

Procedure ParseProcedureDeclaration; Forward;
Procedure ParseFunctionDeclaration; Forward;

Procedure ParseBlock;
Var
  saved_offset: Integer;
  alloc_size: Integer;
  body_label: Integer;
Begin
  saved_offset := local_offset;
  body_label := 0;

  While (tok_type = TOK_CONST) Or (tok_type = TOK_VAR) Or (tok_type = TOK_TYPE_KW) Do
  Begin
    If tok_type = TOK_CONST Then
      ParseConstDeclarations
    Else If tok_type = TOK_TYPE_KW Then
      ParseTypeDeclarations
    Else
      ParseVarDeclarations
  End;

  { If there are Procedure/Function declarations, jump over them }
  If (tok_type = TOK_PROCEDURE) Or (tok_type = TOK_FUNCTION) Then
  Begin
    body_label := NewLabel;
    EmitBranchLabel(body_label)
  End;

  While (tok_type = TOK_PROCEDURE) Or (tok_type = TOK_FUNCTION) Do
  Begin
    If tok_type = TOK_PROCEDURE Then
      ParseProcedureDeclaration
    Else
      ParseFunctionDeclaration
  End;

  If body_label > 0 Then
    EmitLabel(body_label);

  { Allocate stack space - round up To 16 For alignment }
  alloc_size := 0;
  If local_offset < saved_offset Then
  Begin
    alloc_size := saved_offset - local_offset;
    alloc_size := ((alloc_size + 15) Div 16) * 16;
    EmitSubSP(alloc_size)
  End;

  Expect(TOK_BEGIN);
  ParseStatement;
  While tok_type = TOK_SEMICOLON Do
  Begin
    NextToken;
    ParseStatement
  End;
  Expect(TOK_END);

  { Deallocate stack space }
  If alloc_size > 0 Then
  Begin
    EmitAddSP(alloc_size)
  End
End;

Procedure ParseProcedureDeclaration;
Var
  idx, proc_label: Integer;
  saved_level, saved_offset: Integer;
  param_count, param_idx, i, j: Integer;
  param_indices: Array[0..7] Of Integer;
  is_var_group: Integer;
  saved_exit_label, proc_exit_label: Integer;
Begin
  NextToken;  { consume 'Procedure' }

  If tok_type <> TOK_IDENT Then
    Error(11);

  { Check If Procedure already exists (Forward declaration) }
  idx := SymLookup;
  If (idx >= 0) And (sym_kind[idx] = SYM_PROCEDURE) Then
  Begin
    { Reuse existing Forward-declared Procedure }
    proc_label := sym_label[idx]
  End
  Else
  Begin
    { Create New Procedure symbol }
    idx := SymAdd(SYM_PROCEDURE, TYPE_VOID, scope_level, 0);
    proc_label := NewLabel;
    sym_label[idx] := proc_label
  End;
  NextToken;

  { Save state And enter New scope For parameters }
  saved_level := scope_level;
  saved_offset := local_offset;
  scope_level := scope_level + 1;
  local_offset := -8;  { Reserve -8 For static link }
  param_count := 0;

  { Handle optional parameters }
  If tok_type = TOK_LPAREN Then
  Begin
    NextToken;
    If tok_type <> TOK_RPAREN Then
    Begin
      Repeat
        If tok_type = TOK_SEMICOLON Then NextToken;
        { Check For 'Var' keyword - applies To all idents In this group }
        is_var_group := 0;
        If tok_type = TOK_VAR Then
        Begin
          is_var_group := 1;
          NextToken
        End;
        { Parse identifier list For this parameter group }
        If tok_type <> TOK_IDENT Then Error(11);
        Repeat
          If tok_type = TOK_COMMA Then NextToken;
          If tok_type <> TOK_IDENT Then Error(11);
          { Add parameter }
          local_offset := local_offset - 8;
          param_idx := SymAdd(SYM_PARAM, TYPE_INTEGER, scope_level, local_offset);
          If is_var_group = 1 Then
            sym_is_var_param[param_idx] := 1;
          If param_count < 8 Then
            param_indices[param_count] := param_idx;
          param_count := param_count + 1;
          NextToken
        Until tok_type <> TOK_COMMA;
        { Parse Type annotation And Set param types }
        If tok_type = TOK_COLON Then
        Begin
          NextToken;
          If tok_type = TOK_REAL_TYPE Then
          Begin
            { Set all params In this group To TYPE_REAL }
            { Find starting index Of this group And Set types }
            { param_indices has the indices, but we need To know where this group started }
            { For simplicity, Set all recent params To Real - this is approximate }
            sym_type[param_idx] := TYPE_REAL;
            NextToken
          End
          Else If tok_type = TOK_STRING_TYPE Then
          Begin
            { String parameter }
            sym_type[param_idx] := TYPE_STRING;
            If is_var_group = 0 Then
            Begin
              { Value parameter - need 256 bytes total, already have 8, need 248 more }
              local_offset := local_offset - 248;
              sym_offset[param_idx] := local_offset;  { Update offset To start Of 256-byte area }
              sym_label[param_idx] := 256  { Mark as needing copy-In }
            End;
            { Var String params keep the 8-byte slot For address }
            NextToken
          End
          Else If (tok_type = TOK_INTEGER_TYPE) Or (tok_type = TOK_CHAR_TYPE) Or
             (tok_type = TOK_BOOLEAN_TYPE) Then
            NextToken
        End
      Until tok_type <> TOK_SEMICOLON
    End;
    Expect(TOK_RPAREN)
  End;

  { Build Var-param bitmap And store on Procedure symbol }
  sym_var_param_flags[idx] := 0;
  For i := 0 To param_count - 1 Do
    If sym_is_var_param[param_indices[i]] = 1 Then
    Begin
      If i = 0 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 1;
      If i = 1 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 2;
      If i = 2 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 4;
      If i = 3 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 8;
      If i = 4 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 16;
      If i = 5 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 32;
      If i = 6 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 64;
      If i = 7 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 128
    End;

  Expect(TOK_SEMICOLON);

  { Check For Forward declaration Or Interface declaration }
  If (tok_type = TOK_FORWARD) Or (in_interface = 1) Then
  Begin
    If tok_type = TOK_FORWARD Then
    Begin
      NextToken;
      Expect(TOK_SEMICOLON)
    End;
    PopScope(scope_level);
    scope_level := saved_level;
    local_offset := saved_offset
  End
  Else
  Begin

  { Emit Procedure label And prolog - save x29, x30, static link }
  { For units, use named labels To avoid conflicts when linking }
  If compiling_unit = 1 Then
  Begin
    EmitGloblCurrentUnit(idx);  { Export the symbol }
    EmitUnitLabel(idx)
  End
  Else
    EmitLabel(proc_label);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);  { Allocate space For static link }
  EmitStoreStaticLink;

  { Allocate space For parameters And copy from registers }
  If param_count > 0 Then
  Begin
    { Allocate based on actual space needed (local_offset tracks it) }
    { param_space = -(local_offset) - 8 (static link already counted separately) }
    j := 0 - local_offset - 8;
    j := ((j + 15) Div 16) * 16;  { Align To 16 }
    If j > 0 Then
      EmitSubSP(j);
    For i := 0 To param_count - 1 Do
    Begin
      If i < 8 Then
      Begin
        { Check If this is a String value parameter (needs copy) }
        If (sym_type[param_indices[i]] = TYPE_STRING) And (sym_is_var_param[param_indices[i]] = 0) Then
        Begin
          { String value param: xi has address Of source, copy To local storage }
          { x9 = source (passed address), compute x8 = dest using large offset handling }
          EmitIndent;
          WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
          WriteChar(120); WriteChar(57); WriteChar(44); WriteChar(32);  { x9, }
          WriteChar(120); WriteChar(48 + i);  { xi }
          EmitNL;
          { Compute dest address: x8 = x29 - offset (handle large negative offset) }
          EmitIndent;
          WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
          WriteChar(120); WriteChar(56); WriteChar(44); WriteChar(32);  { x8, }
          WriteChar(35);
          Write(0 - sym_offset[param_indices[i]]);  { positive value }
          EmitNL;
          EmitIndent;
          WriteChar(115); WriteChar(117); WriteChar(98); WriteChar(32);  { sub }
          WriteChar(120); WriteChar(56); WriteChar(44); WriteChar(32);  { x8, }
          WriteChar(120); WriteChar(50); WriteChar(57); WriteChar(44); WriteChar(32);  { x29, }
          WriteChar(120); WriteChar(56);  { x8 }
          EmitNL;
          EmitBL(rt_str_copy)
        End
        Else
        Begin
          { Normal param: store register To stack }
          EmitIndent;
          WriteChar(115); WriteChar(116); WriteChar(117); WriteChar(114); WriteChar(32);  { stur }
          WriteChar(120); WriteChar(48 + i); WriteChar(44); WriteChar(32);  { xi, }
          WriteChar(91); WriteChar(120); WriteChar(50); WriteChar(57);  { [x29 }
          WriteChar(44); WriteChar(32); WriteChar(35);  { , # }
          Write(sym_offset[param_indices[i]]);
          WriteChar(93);  { ] }
          EmitNL
        End
      End
    End
  End;

  { Set up Exit label For this Procedure }
  saved_exit_label := exit_label;
  proc_exit_label := NewLabel;
  exit_label := proc_exit_label;

  { Parse Procedure body }
  ParseBlock;

  { Pop local symbols And restore scope }
  PopScope(scope_level);
  scope_level := saved_level;
  local_offset := saved_offset;

  { Emit Exit label For Exit statements }
  EmitLabel(proc_exit_label);
  exit_label := saved_exit_label;

  { Restore sp To frame pointer (undoes static link + params + local allocations) }
  EmitIndent;
  WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
  WriteChar(115); WriteChar(112); WriteChar(44); WriteChar(32);  { sp, }
  WriteChar(120); WriteChar(50); WriteChar(57);  { x29 }
  EmitNL;

  { Restore frame And return }
  EmitLdp;
  EmitIndent;
  WriteChar(114); WriteChar(101); WriteChar(116);  { ret }
  EmitNL;

  Expect(TOK_SEMICOLON)
  End  { End Of Else For non-Forward declaration }
End;

Procedure ParseFunctionDeclaration;
Var
  idx, func_label: Integer;
  saved_level, saved_offset: Integer;
  param_count, param_idx, i, j: Integer;
  param_indices: Array[0..7] Of Integer;
  is_var_group: Integer;
  saved_exit_label, func_exit_label: Integer;
Begin
  NextToken;  { consume 'Function' }

  If tok_type <> TOK_IDENT Then
    Error(11);

  { Check If Function already exists (Forward declaration) }
  idx := SymLookup;
  If (idx >= 0) And (sym_kind[idx] = SYM_FUNCTION) Then
  Begin
    { Reuse existing Forward-declared Function }
    func_label := sym_label[idx]
  End
  Else
  Begin
    { Create New Function symbol }
    idx := SymAdd(SYM_FUNCTION, TYPE_INTEGER, scope_level, 0);
    func_label := NewLabel;
    sym_label[idx] := func_label
  End;
  NextToken;

  { Save state And enter New scope For parameters }
  saved_level := scope_level;
  saved_offset := local_offset;
  scope_level := scope_level + 1;
  local_offset := -16;  { Reserve -8 For static link, -16 For result }
  param_count := 0;

  { Handle optional parameters }
  If tok_type = TOK_LPAREN Then
  Begin
    NextToken;
    If tok_type <> TOK_RPAREN Then
    Begin
      Repeat
        If tok_type = TOK_SEMICOLON Then NextToken;
        { Check For 'Var' keyword - applies To all idents In this group }
        is_var_group := 0;
        If tok_type = TOK_VAR Then
        Begin
          is_var_group := 1;
          NextToken
        End;
        { Parse identifier list For this parameter group }
        If tok_type <> TOK_IDENT Then Error(11);
        Repeat
          If tok_type = TOK_COMMA Then NextToken;
          If tok_type <> TOK_IDENT Then Error(11);
          { Add parameter }
          local_offset := local_offset - 8;
          param_idx := SymAdd(SYM_PARAM, TYPE_INTEGER, scope_level, local_offset);
          If is_var_group = 1 Then
            sym_is_var_param[param_idx] := 1;
          If param_count < 8 Then
            param_indices[param_count] := param_idx;
          param_count := param_count + 1;
          NextToken
        Until tok_type <> TOK_COMMA;
        { Parse Type annotation And Set param types }
        If tok_type = TOK_COLON Then
        Begin
          NextToken;
          If tok_type = TOK_REAL_TYPE Then
          Begin
            sym_type[param_idx] := TYPE_REAL;
            NextToken
          End
          Else If tok_type = TOK_STRING_TYPE Then
          Begin
            { String parameter }
            sym_type[param_idx] := TYPE_STRING;
            If is_var_group = 0 Then
            Begin
              { Value parameter - need 256 bytes total, already have 8, need 248 more }
              local_offset := local_offset - 248;
              sym_offset[param_idx] := local_offset;  { Update offset To start Of 256-byte area }
              sym_label[param_idx] := 256  { Mark as needing copy-In }
            End;
            { Var String params keep the 8-byte slot For address }
            NextToken
          End
          Else If (tok_type = TOK_INTEGER_TYPE) Or (tok_type = TOK_CHAR_TYPE) Or
             (tok_type = TOK_BOOLEAN_TYPE) Then
            NextToken
        End
      Until tok_type <> TOK_SEMICOLON
    End;
    Expect(TOK_RPAREN)
  End;

  { Build Var-param bitmap And store on Function symbol }
  sym_var_param_flags[idx] := 0;
  For i := 0 To param_count - 1 Do
    If sym_is_var_param[param_indices[i]] = 1 Then
    Begin
      If i = 0 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 1;
      If i = 1 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 2;
      If i = 2 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 4;
      If i = 3 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 8;
      If i = 4 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 16;
      If i = 5 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 32;
      If i = 6 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 64;
      If i = 7 Then sym_var_param_flags[idx] := sym_var_param_flags[idx] + 128
    End;

  { Parse return Type }
  Expect(TOK_COLON);
  If (tok_type = TOK_INTEGER_TYPE) Or (tok_type = TOK_CHAR_TYPE) Or
     (tok_type = TOK_BOOLEAN_TYPE) Then
    NextToken
  Else If tok_type = TOK_REAL_TYPE Then
  Begin
    sym_type[idx] := TYPE_REAL;
    NextToken
  End
  Else If tok_type = TOK_STRING_TYPE Then
  Begin
    sym_type[idx] := TYPE_STRING;
    NextToken
  End
  Else
    Error(9);

  Expect(TOK_SEMICOLON);

  { Check For Forward declaration Or Interface declaration }
  If (tok_type = TOK_FORWARD) Or (in_interface = 1) Then
  Begin
    If tok_type = TOK_FORWARD Then
    Begin
      NextToken;
      Expect(TOK_SEMICOLON)
    End;
    PopScope(scope_level);
    scope_level := saved_level;
    local_offset := saved_offset
  End
  Else
  Begin

  { Emit Function label And prolog - save x29, x30, static link }
  { For units, use named labels To avoid conflicts when linking }
  If compiling_unit = 1 Then
  Begin
    EmitGloblCurrentUnit(idx);  { Export the symbol }
    EmitUnitLabel(idx)
  End
  Else
    EmitLabel(func_label);
  EmitStp;
  EmitMovFP;
  EmitSubSP(16);  { Allocate space For static link }
  EmitStoreStaticLink;

  { Allocate space For parameters And copy from registers }
  If param_count > 0 Then
  Begin
    { Allocate based on actual space needed (local_offset tracks it) }
    { For functions, local_offset includes return value at -16, params start at -24 }
    j := 0 - local_offset - 16;  { -16 For return value slot }
    j := ((j + 15) Div 16) * 16;  { Align To 16 }
    If j > 0 Then
      EmitSubSP(j);
    For i := 0 To param_count - 1 Do
    Begin
      If i < 8 Then
      Begin
        { Check If this is a String value parameter (needs copy) }
        If (sym_type[param_indices[i]] = TYPE_STRING) And (sym_is_var_param[param_indices[i]] = 0) Then
        Begin
          { String value param: xi has address Of source, copy To local storage }
          { x9 = source (passed address), compute x8 = dest using large offset handling }
          EmitIndent;
          WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
          WriteChar(120); WriteChar(57); WriteChar(44); WriteChar(32);  { x9, }
          WriteChar(120); WriteChar(48 + i);  { xi }
          EmitNL;
          { Compute dest address: x8 = x29 - offset (handle large negative offset) }
          EmitIndent;
          WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
          WriteChar(120); WriteChar(56); WriteChar(44); WriteChar(32);  { x8, }
          WriteChar(35);
          Write(0 - sym_offset[param_indices[i]]);  { positive value }
          EmitNL;
          EmitIndent;
          WriteChar(115); WriteChar(117); WriteChar(98); WriteChar(32);  { sub }
          WriteChar(120); WriteChar(56); WriteChar(44); WriteChar(32);  { x8, }
          WriteChar(120); WriteChar(50); WriteChar(57); WriteChar(44); WriteChar(32);  { x29, }
          WriteChar(120); WriteChar(56);  { x8 }
          EmitNL;
          EmitBL(rt_str_copy)
        End
        Else
        Begin
          { Normal param: store register To stack }
          EmitIndent;
          WriteChar(115); WriteChar(116); WriteChar(117); WriteChar(114); WriteChar(32);  { stur }
          WriteChar(120); WriteChar(48 + i); WriteChar(44); WriteChar(32);  { xi, }
          WriteChar(91); WriteChar(120); WriteChar(50); WriteChar(57);  { [x29 }
          WriteChar(44); WriteChar(32); WriteChar(35);  { , # }
          Write(sym_offset[param_indices[i]]);
          WriteChar(93);  { ] }
          EmitNL
        End
      End
    End
  End;

  { Set up Exit label For this Function }
  saved_exit_label := exit_label;
  func_exit_label := NewLabel;
  exit_label := func_exit_label;

  { Parse Function body }
  ParseBlock;

  { Pop local symbols And restore scope }
  PopScope(scope_level);
  scope_level := saved_level;
  local_offset := saved_offset;

  { Emit Exit label For Exit statements }
  EmitLabel(func_exit_label);
  exit_label := saved_exit_label;

  { Load result from local variable into x0 Or d0 }
  If sym_type[idx] = TYPE_REAL Then
    EmitLdurD0(-16)
  Else
    EmitLdurX0(-16);

  { Restore sp To frame pointer (undoes static link + params + local allocations) }
  EmitIndent;
  WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
  WriteChar(115); WriteChar(112); WriteChar(44); WriteChar(32);  { sp, }
  WriteChar(120); WriteChar(50); WriteChar(57);  { x29 }
  EmitNL;

  { Restore frame And return }
  EmitLdp;
  EmitIndent;
  WriteChar(114); WriteChar(101); WriteChar(116);  { ret }
  EmitNL;

  Expect(TOK_SEMICOLON)
  End  { End Of Else For non-Forward declaration }
End;

{ Write Unit name To TPU file (from current_unit_name) }
Procedure TPUWriteUnitName;
Var
  i: Integer;
Begin
  For i := 0 To current_unit_len - 1 Do
    writefilechar(tpu_file, current_unit_name[i])
End;

{ Write an Integer To TPU file }
Procedure TPUWriteInt(n: Integer);
Var
  neg: Integer;
  digits: Array[0..19] Of Integer;
  count, i: Integer;
Begin
  neg := 0;
  If n < 0 Then
  Begin
    neg := 1;
    n := 0 - n
  End;
  count := 0;
  If n = 0 Then
  Begin
    digits[0] := 48;
    count := 1
  End
  Else
  Begin
    While n > 0 Do
    Begin
      digits[count] := 48 + (n Mod 10);
      n := n Div 10;
      count := count + 1
    End
  End;
  If neg = 1 Then
    writefilechar(tpu_file, 45);  { '-' }
  For i := count - 1 DownTo 0 Do
    writefilechar(tpu_file, digits[i])
End;

{ Write symbol name To TPU file }
Procedure TPUWriteSymName(idx: Integer);
Var
  base, i, c: Integer;
Begin
  base := idx * 32;
  i := 0;
  c := sym_name[base];
  While c <> 0 Do
  Begin
    writefilechar(tpu_file, c);
    i := i + 1;
    c := sym_name[base + i]
  End
End;

{ Write Type name To TPU file }
Procedure TPUWriteType(t: Integer);
Begin
  If t = TYPE_INTEGER Then
    Write(tpu_file, 'Integer')
  Else If t = TYPE_CHAR Then
    Write(tpu_file, 'Char')
  Else If t = TYPE_BOOLEAN Then
    Write(tpu_file, 'Boolean')
  Else If t = TYPE_STRING Then
    Write(tpu_file, 'String')
  Else If t = TYPE_REAL Then
    Write(tpu_file, 'Real')
  Else If t = TYPE_VOID Then
    Write(tpu_file, 'VOID')
  Else If t = TYPE_POINTER Then
    Write(tpu_file, 'POINTER')
  Else If t = TYPE_RECORD Then
    Write(tpu_file, 'Record')
  Else If t = TYPE_ARRAY Then
    Write(tpu_file, 'Array')
  Else
    Write(tpu_file, 'UNKNOWN')
End;

{ Write TPU file For current Unit }
Procedure WriteTPUFile;
Var
  i, base, c, j: Integer;
Begin
  { Build filename In tok_str: unitname.tpu (lowercase) }
  For i := 0 To current_unit_len - 1 Do
    tok_str[i] := ToLower(current_unit_name[i]);
  tok_str[current_unit_len] := 46;      { . }
  tok_str[current_unit_len + 1] := 116; { t }
  tok_str[current_unit_len + 2] := 112; { p }
  tok_str[current_unit_len + 3] := 117; { u }
  tok_str[current_unit_len + 4] := 0;

  { Open file For writing using assigntokstr }
  assigntokstr(tpu_file, 0, current_unit_len + 4);
  rewrite(tpu_file);

  { Write header }
  WriteLn(tpu_file, 'TUXPASCAL_UNIT_V1');

  { Write Unit name }
  Write(tpu_file, 'Unit ');
  TPUWriteUnitName;
  WriteLn(tpu_file);

  { Write Interface section }
  WriteLn(tpu_file, 'Interface');

  { Write Interface symbols }
  For i := interface_start To interface_end Do
  Begin
    If sym_kind[i] = SYM_CONST Then
    Begin
      Write(tpu_file, 'Const ');
      TPUWriteSymName(i);
      Write(tpu_file, ' ');
      TPUWriteType(sym_type[i]);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_const_val[i]);
      WriteLn(tpu_file)
    End
    Else If sym_kind[i] = SYM_VAR Then
    Begin
      Write(tpu_file, 'Var ');
      TPUWriteSymName(i);
      Write(tpu_file, ' ');
      TPUWriteType(sym_type[i]);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_offset[i]);
      WriteLn(tpu_file)
    End
    Else If sym_kind[i] = SYM_PROCEDURE Then
    Begin
      Write(tpu_file, 'PROC ');
      TPUWriteSymName(i);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_label[i]);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_var_param_flags[i]);
      WriteLn(tpu_file)
    End
    Else If sym_kind[i] = SYM_FUNCTION Then
    Begin
      Write(tpu_file, 'FUNC ');
      TPUWriteSymName(i);
      Write(tpu_file, ' ');
      TPUWriteType(sym_type[i]);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_label[i]);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_var_param_flags[i]);
      WriteLn(tpu_file)
    End
    Else If sym_kind[i] = SYM_TYPEDEF Then
    Begin
      Write(tpu_file, 'Type ');
      TPUWriteSymName(i);
      Write(tpu_file, ' ');
      TPUWriteType(sym_type[i]);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_const_val[i]);
      Write(tpu_file, ' ');
      TPUWriteInt(sym_label[i]);
      WriteLn(tpu_file)
    End
  End;

  WriteLn(tpu_file, 'ENDINTERFACE');

  close(tpu_file)
End;

{ Read a line from TPU file into tpu_line buffer }
Function TPUReadLine: Integer;
Var
  c: Integer;
  done: Integer;
Begin
  tpu_line_len := 0;
  TPUReadLine := 0;
  done := 0;
  If Not eof(tpu_file) Then
  Begin
    While (Not eof(tpu_file)) And (done = 0) Do
    Begin
      Read(tpu_file, c);
      If c = 10 Then
        done := 1
      Else If c <> 13 Then
      Begin
        tpu_line[tpu_line_len] := c;
        tpu_line_len := tpu_line_len + 1
      End
    End;
    tpu_line[tpu_line_len] := 0;
    If tpu_line_len > 0 Then
      TPUReadLine := 1
    Else If done = 1 Then
      TPUReadLine := 1  { empty line is still a line }
  End
End;

{ Note: TPULineStartsWith removed - checks are inlined using first 3 chars }

{ Parse Integer from tpu_line at tpu_pos (updates tpu_pos) }
Function TPUParseInt: Integer;
Var
  neg, result: Integer;
Begin
  neg := 0;
  result := 0;
  If tpu_line[tpu_pos] = 45 Then  { '-' }
  Begin
    neg := 1;
    tpu_pos := tpu_pos + 1
  End;
  While (tpu_line[tpu_pos] >= 48) And (tpu_line[tpu_pos] <= 57) Do
  Begin
    result := result * 10 + (tpu_line[tpu_pos] - 48);
    tpu_pos := tpu_pos + 1
  End;
  If neg = 1 Then
    TPUParseInt := 0 - result
  Else
    TPUParseInt := result
End;

{ Skip spaces In tpu_line at tpu_pos (updates tpu_pos) }
Procedure TPUSkipSpaces;
Begin
  While tpu_line[tpu_pos] = 32 Do
    tpu_pos := tpu_pos + 1
End;

{ Parse identifier from tpu_line at tpu_pos, store In tok_str (updates tpu_pos) }
Procedure TPUParseIdent;
Begin
  tok_len := 0;
  TPUSkipSpaces;
  While (tpu_line[tpu_pos] <> 32) And (tpu_line[tpu_pos] <> 0) Do
  Begin
    tok_str[tok_len] := tpu_line[tpu_pos];
    tok_len := tok_len + 1;
    tpu_pos := tpu_pos + 1
  End;
  tok_str[tok_len] := 0
End;

{ Parse Type from tpu_line at tpu_pos, return TYPE_* constant }
Function TPUParseType: Integer;
Begin
  TPUParseIdent;
  If (tok_str[0] = 73) And (tok_str[1] = 78) And (tok_str[2] = 84) Then  { INT }
    TPUParseType := TYPE_INTEGER
  Else If (tok_str[0] = 67) And (tok_str[1] = 72) And (tok_str[2] = 65) Then  { CHA }
    TPUParseType := TYPE_CHAR
  Else If (tok_str[0] = 66) And (tok_str[1] = 79) And (tok_str[2] = 79) Then  { BOO }
    TPUParseType := TYPE_BOOLEAN
  Else If (tok_str[0] = 83) And (tok_str[1] = 84) And (tok_str[2] = 82) Then  { STR }
    TPUParseType := TYPE_STRING
  Else If (tok_str[0] = 82) And (tok_str[1] = 69) And (tok_str[2] = 65) Then  { REA }
    TPUParseType := TYPE_REAL
  Else If (tok_str[0] = 86) And (tok_str[1] = 79) And (tok_str[2] = 73) Then  { VOI }
    TPUParseType := TYPE_VOID
  Else If (tok_str[0] = 80) And (tok_str[1] = 79) And (tok_str[2] = 73) Then  { POI }
    TPUParseType := TYPE_POINTER
  Else If (tok_str[0] = 82) And (tok_str[1] = 69) And (tok_str[2] = 67) Then  { REC }
    TPUParseType := TYPE_RECORD
  Else If (tok_str[0] = 65) And (tok_str[1] = 82) And (tok_str[2] = 82) Then  { ARR }
    TPUParseType := TYPE_ARRAY
  Else
    TPUParseType := TYPE_INTEGER
End;

{ Load Interface from a TPU file }
Function LoadTPUInterface: Integer;
Var
  idx: Integer;
  unit_base, i: Integer;
Begin
  LoadTPUInterface := 0;

  { Read And verify header }
  If TPUReadLine = 0 Then
  Begin
    LoadTPUInterface := -1
  End
  Else
  Begin
    { Check For TUXPASCAL_UNIT_V1 }
    If (tpu_line[0] <> 84) Or (tpu_line[1] <> 85) Or (tpu_line[2] <> 88) Then
    Begin
      LoadTPUInterface := -1
    End
    Else
    Begin
      { Read Unit line }
      If TPUReadLine = 0 Then
        LoadTPUInterface := -1
      Else
      Begin
        { Store Unit name For symbol prefixing }
        unit_base := loaded_count * 32;
        tpu_pos := 5;  { Skip 'Unit ' }
        i := 0;
        While (tpu_line[tpu_pos] <> 0) And (i < 31) Do
        Begin
          loaded_units[unit_base + i] := tpu_line[tpu_pos];
          tpu_pos := tpu_pos + 1;
          i := i + 1
        End;
        loaded_units[unit_base + i] := 0;

        unit_sym_start[loaded_count] := sym_count;

        { Read Interface line }
        If TPUReadLine = 0 Then
          LoadTPUInterface := -1
        Else
        Begin
          { Parse Interface declarations Until ENDINTERFACE }
          While TPUReadLine = 1 Do
          Begin
            If (tpu_line[0] = 69) And (tpu_line[1] = 78) And (tpu_line[2] = 68) Then
            Begin
              { ENDINTERFACE }
              unit_sym_end[loaded_count] := sym_count - 1;
              loaded_count := loaded_count + 1;
              LoadTPUInterface := 1
            End
            Else If (tpu_line[0] = 67) And (tpu_line[1] = 79) And (tpu_line[2] = 78) Then
            Begin
              { Const name Type value }
              tpu_pos := 6;  { Skip 'Const ' }
              TPUParseIdent;
              idx := SymAdd(SYM_CONST, TYPE_INTEGER, 0, 0);
              TPUSkipSpaces;
              sym_type[idx] := TPUParseType;
              TPUSkipSpaces;
              sym_const_val[idx] := TPUParseInt
            End
            Else If (tpu_line[0] = 86) And (tpu_line[1] = 65) And (tpu_line[2] = 82) Then
            Begin
              { Var name Type offset }
              tpu_pos := 4;  { Skip 'Var ' }
              TPUParseIdent;
              idx := SymAdd(SYM_VAR, TYPE_INTEGER, 0, 0);
              TPUSkipSpaces;
              sym_type[idx] := TPUParseType;
              TPUSkipSpaces;
              sym_offset[idx] := TPUParseInt
            End
            Else If (tpu_line[0] = 80) And (tpu_line[1] = 82) And (tpu_line[2] = 79) Then
            Begin
              { PROC name label flags }
              tpu_pos := 5;  { Skip 'PROC ' }
              TPUParseIdent;
              idx := SymAdd(SYM_PROCEDURE, TYPE_VOID, 0, 0);
              sym_unit_idx[idx] := loaded_count;  { Mark as imported from this Unit }
              TPUSkipSpaces;
              sym_label[idx] := TPUParseInt;
              TPUSkipSpaces;
              sym_var_param_flags[idx] := TPUParseInt
            End
            Else If (tpu_line[0] = 70) And (tpu_line[1] = 85) And (tpu_line[2] = 78) Then
            Begin
              { FUNC name Type label flags }
              tpu_pos := 5;  { Skip 'FUNC ' }
              TPUParseIdent;
              idx := SymAdd(SYM_FUNCTION, TYPE_INTEGER, 0, 0);
              sym_unit_idx[idx] := loaded_count;  { Mark as imported from this Unit }
              TPUSkipSpaces;
              sym_type[idx] := TPUParseType;
              TPUSkipSpaces;
              sym_label[idx] := TPUParseInt;
              TPUSkipSpaces;
              sym_var_param_flags[idx] := TPUParseInt
            End
            Else If (tpu_line[0] = 84) And (tpu_line[1] = 89) And (tpu_line[2] = 80) Then
            Begin
              { Type name kind const_val label }
              tpu_pos := 5;  { Skip 'Type ' }
              TPUParseIdent;
              idx := SymAdd(SYM_TYPEDEF, TYPE_RECORD, 0, 0);
              TPUSkipSpaces;
              sym_type[idx] := TPUParseType;
              TPUSkipSpaces;
              sym_const_val[idx] := TPUParseInt;
              TPUSkipSpaces;
              sym_label[idx] := TPUParseInt
            End
          End
        End
      End
    End
  End
End;

{ Parse Uses clause: Uses Unit1, Unit2, ...; }
Procedure ParseUsesClause;
Var
  i: Integer;
Begin
  NextToken;  { consume 'Uses' }
  Repeat
    If tok_type <> TOK_IDENT Then
      Error(6);  { expected identifier }

    { Build TPU filename In tok_str: unitname.tpu (lowercase For Case-insensitivity) }
    For i := 0 To tok_len - 1 Do
      tok_str[i] := ToLower(tok_str[i]);
    tok_str[tok_len] := 46;      { . }
    tok_str[tok_len + 1] := 116; { t }
    tok_str[tok_len + 2] := 112; { p }
    tok_str[tok_len + 3] := 117; { u }
    tok_str[tok_len + 4] := 0;

    { Open TPU file }
    assigntokstr(tpu_file, 0, tok_len + 4);
    reset(tpu_file);

    { Load Interface symbols }
    If LoadTPUInterface < 0 Then
      Error(18);  { Unit Not found Or invalid }

    close(tpu_file);

    NextToken;
    If tok_type = TOK_COMMA Then
      NextToken
  Until tok_type = TOK_SEMICOLON;
  Expect(TOK_SEMICOLON)
End;

{ Parse a Unit: Unit Name; Interface ... Implementation ... End. }
Procedure ParseUnit;
Var
  unit_lbl: Integer;
  i: Integer;
Begin
  { Unit Name; }
  NextToken;  { consume 'Unit' }
  If tok_type <> TOK_IDENT Then
    Error(6);  { expected identifier }

  { Store Unit name For qualified symbol names }
  current_unit_len := tok_len;
  For i := 0 To tok_len - 1 Do
    current_unit_name[i] := tok_str[i];
  current_unit_name[tok_len] := 0;

  compiling_unit := 1;
  NextToken;
  Expect(TOK_SEMICOLON);

  { Emit Unit header - no _main, just label For Unit init }
  EmitAlign4;

  { Jump over runtime routines (units still need runtime For their code) }
  unit_lbl := NewLabel;
  EmitBranchLabel(unit_lbl);

  { Emit runtime routines needed by Unit code }
  rt_print_int := NewLabel;
  rt_newline := NewLabel;
  rt_readchar := NewLabel;
  rt_print_char := NewLabel;
  rt_write_char_fd := NewLabel;
  rt_read_int := NewLabel;
  rt_skip_line := NewLabel;
  rt_print_string := NewLabel;
  rt_print_real := NewLabel;
  rt_read_real := NewLabel;
  rt_read_string := NewLabel;
  rt_heap_init := NewLabel;
  rt_alloc := NewLabel;
  rt_free := NewLabel;
  rt_str_copy := NewLabel;
  rt_str_compare := NewLabel;
  rt_str_concat := NewLabel;
  rt_str_cmp := NewLabel;
  rt_str_pos := NewLabel;
  rt_str_delete := NewLabel;
  rt_str_insert := NewLabel;
  rt_int_to_str := NewLabel;
  rt_str_to_int := NewLabel;
  rt_str_ltrim := NewLabel;
  rt_str_rtrim := NewLabel;
  rt_str_trim := NewLabel;
  rt_clrscr := NewLabel;
  rt_gotoxy := NewLabel;
  rt_clreol := NewLabel;
  rt_textcolor := NewLabel;
  rt_textbackground := NewLabel;
  rt_normvideo := NewLabel;
  rt_highvideo := NewLabel;
  rt_lowvideo := NewLabel;
  rt_hidecursor := NewLabel;
  rt_showcursor := NewLabel;
  rt_sleep := NewLabel;
  rt_keypressed := NewLabel;
  rt_initkeyboard := NewLabel;
  rt_donekeyboard := NewLabel;
  rt_sin := NewLabel;
  rt_cos := NewLabel;
  rt_tan := NewLabel;
  rt_exp := NewLabel;
  rt_ln := NewLabel;
  rt_random := NewLabel;
  rt_arctan := NewLabel;
  rt_arcsin := NewLabel;
  rt_arccos := NewLabel;
  rt_paramstr := NewLabel;

  EmitPrintIntRuntime;
  EmitNewlineRuntime;
  EmitReadcharRuntime;
  EmitPrintCharRuntime;
  EmitWriteCharFdRuntime;
  EmitReadIntRuntime;
  EmitSkipLineRuntime;
  EmitPrintStringRuntime;
  EmitPrintRealRuntime;
  EmitReadRealRuntime;
  EmitReadStringRuntime;
  EmitHeapInitRuntime;
  EmitAllocRuntime;
  EmitFreeRuntime;
  EmitStrCopyRuntime;
  EmitStrCompareRuntime;
  EmitStrConcatRuntime;
  EmitStrCmpRuntime;
  EmitStrPosRuntime;
  EmitStrDeleteRuntime;
  EmitStrInsertRuntime;
  EmitIntToStrRuntime;
  EmitStrToIntRuntime;
  EmitStrLtrimRuntime;
  EmitStrRtrimRuntime;
  EmitStrTrimRuntime;
  EmitClrScrRuntime;
  EmitGotoXYRuntime;
  EmitClrEolRuntime;
  EmitTextColorRuntime;
  EmitTextBackgroundRuntime;
  EmitNormVideoRuntime;
  EmitHighVideoRuntime;
  EmitLowVideoRuntime;
  EmitHideCursorRuntime;
  EmitShowCursorRuntime;
  EmitSleepRuntime;
  EmitKeyPressedRuntime;
  EmitInitKeyboardRuntime;
  EmitDoneKeyboardRuntime;
  EmitSinRuntime;
  EmitCosRuntime;
  EmitTanRuntime;
  EmitExpRuntime;
  EmitLnRuntime;
  EmitRandomRuntime;
  EmitArctanRuntime;
  EmitArcsinRuntime;
  EmitArccosRuntime;
  EmitParamStrRuntime;

  EmitLabel(unit_lbl);

  { Interface section }
  Expect(TOK_INTERFACE);
  in_interface := 1;
  interface_start := sym_count;  { Track first Interface symbol }

  { Parse Interface declarations (Const, Type, Var, Procedure/Function headers) }
  While (tok_type = TOK_CONST) Or (tok_type = TOK_TYPE_KW) Or
        (tok_type = TOK_VAR) Or (tok_type = TOK_PROCEDURE) Or
        (tok_type = TOK_FUNCTION) Do
  Begin
    If tok_type = TOK_CONST Then
      ParseConstDeclarations
    Else If tok_type = TOK_TYPE_KW Then
      ParseTypeDeclarations
    Else If tok_type = TOK_VAR Then
      ParseVarDeclarations
    Else If tok_type = TOK_PROCEDURE Then
    Begin
      { In Interface, only parse the header }
      ParseProcedureDeclaration
    End
    Else If tok_type = TOK_FUNCTION Then
    Begin
      ParseFunctionDeclaration
    End
  End;

  interface_end := sym_count - 1;  { Track last Interface symbol }
  in_interface := 0;

  { Implementation section }
  Expect(TOK_IMPLEMENTATION);

  { Parse Implementation (full Procedure/Function bodies) }
  While (tok_type = TOK_CONST) Or (tok_type = TOK_TYPE_KW) Or
        (tok_type = TOK_VAR) Or (tok_type = TOK_PROCEDURE) Or
        (tok_type = TOK_FUNCTION) Do
  Begin
    If tok_type = TOK_CONST Then
      ParseConstDeclarations
    Else If tok_type = TOK_TYPE_KW Then
      ParseTypeDeclarations
    Else If tok_type = TOK_VAR Then
      ParseVarDeclarations
    Else If tok_type = TOK_PROCEDURE Then
      ParseProcedureDeclaration
    Else If tok_type = TOK_FUNCTION Then
      ParseFunctionDeclaration
  End;

  { Unit initialization entry point - always emit even If no init code }
  EmitGloblUnitInit;
  EmitUnitInitLabel;
  EmitStp;
  EmitMovFP;

  { Optional initialization section }
  If tok_type = TOK_BEGIN Then
  Begin
    NextToken;
    While tok_type <> TOK_END Do
    Begin
      ParseStatement;
      If tok_type = TOK_SEMICOLON Then
        NextToken
    End;
    Expect(TOK_END)
  End;

  Expect(TOK_DOT);

  { Unit init returns To caller }
  EmitLdp;
  EmitRet;

  { Write TPU file With Interface information }
  WriteTPUFile;

  compiling_unit := 0
End;

Procedure ParseProgram;
Var
  main_lbl, i: Integer;
Begin
  { Check If this is a Unit Or Program }
  If tok_type = TOK_UNIT Then
  Begin
    ParseUnit;
    Halt(0)  { Unit compilation done }
  End;

  Expect(TOK_PROGRAM);
  If tok_type <> TOK_IDENT Then
    Error(11);
  NextToken;
  Expect(TOK_SEMICOLON);

  { Check For Uses clause }
  If tok_type = TOK_USES Then
    ParseUsesClause;

  { Emit header }
  EmitGlobl;
  EmitAlign4;
  EmitMain;

  { Jump over runtime routines }
  main_lbl := NewLabel;
  EmitBranchLabel(main_lbl);

  { Emit runtime routines }
  rt_print_int := NewLabel;
  rt_newline := NewLabel;
  rt_readchar := NewLabel;
  rt_print_char := NewLabel;
  rt_write_char_fd := NewLabel;
  rt_read_int := NewLabel;
  rt_skip_line := NewLabel;
  rt_print_string := NewLabel;
  rt_print_real := NewLabel;
  rt_read_real := NewLabel;
  rt_read_string := NewLabel;
  rt_heap_init := NewLabel;
  rt_alloc := NewLabel;
  rt_free := NewLabel;
  rt_str_copy := NewLabel;
  rt_str_compare := NewLabel;
  rt_str_concat := NewLabel;
  rt_str_cmp := NewLabel;
  rt_str_pos := NewLabel;
  rt_str_delete := NewLabel;
  rt_str_insert := NewLabel;
  rt_int_to_str := NewLabel;
  rt_str_to_int := NewLabel;
  rt_str_ltrim := NewLabel;
  rt_str_rtrim := NewLabel;
  rt_str_trim := NewLabel;
  rt_clrscr := NewLabel;
  rt_gotoxy := NewLabel;
  rt_clreol := NewLabel;
  rt_textcolor := NewLabel;
  rt_textbackground := NewLabel;
  rt_normvideo := NewLabel;
  rt_highvideo := NewLabel;
  rt_lowvideo := NewLabel;
  rt_hidecursor := NewLabel;
  rt_showcursor := NewLabel;
  rt_sleep := NewLabel;
  rt_keypressed := NewLabel;
  rt_initkeyboard := NewLabel;
  rt_donekeyboard := NewLabel;
  rt_sin := NewLabel;
  rt_cos := NewLabel;
  rt_tan := NewLabel;
  rt_exp := NewLabel;
  rt_ln := NewLabel;
  rt_random := NewLabel;
  rt_arctan := NewLabel;
  rt_arcsin := NewLabel;
  rt_arccos := NewLabel;
  rt_paramstr := NewLabel;

  EmitPrintIntRuntime;
  EmitNewlineRuntime;
  EmitReadcharRuntime;
  EmitPrintCharRuntime;
  EmitWriteCharFdRuntime;
  EmitReadIntRuntime;
  EmitSkipLineRuntime;
  EmitPrintStringRuntime;
  EmitPrintRealRuntime;
  EmitReadRealRuntime;
  EmitReadStringRuntime;
  EmitHeapInitRuntime;
  EmitAllocRuntime;
  EmitFreeRuntime;
  EmitStrCopyRuntime;
  EmitStrCompareRuntime;
  EmitStrConcatRuntime;
  EmitStrCmpRuntime;
  EmitStrPosRuntime;
  EmitStrDeleteRuntime;
  EmitStrInsertRuntime;
  EmitIntToStrRuntime;
  EmitStrToIntRuntime;
  EmitStrLtrimRuntime;
  EmitStrRtrimRuntime;
  EmitStrTrimRuntime;
  EmitClrScrRuntime;
  EmitGotoXYRuntime;
  EmitClrEolRuntime;
  EmitTextColorRuntime;
  EmitTextBackgroundRuntime;
  EmitNormVideoRuntime;
  EmitHighVideoRuntime;
  EmitLowVideoRuntime;
  EmitHideCursorRuntime;
  EmitShowCursorRuntime;
  EmitSleepRuntime;
  EmitKeyPressedRuntime;
  EmitInitKeyboardRuntime;
  EmitDoneKeyboardRuntime;
  EmitSinRuntime;
  EmitCosRuntime;
  EmitTanRuntime;
  EmitExpRuntime;
  EmitLnRuntime;
  EmitRandomRuntime;
  EmitArctanRuntime;
  EmitArcsinRuntime;
  EmitArccosRuntime;
  EmitParamStrRuntime;

  { Main Program entry }
  EmitLabel(main_lbl);
  EmitStp;
  EmitMovFP;

  { Save argc To x25, argv To x26 (before any calls clobber x0/x1) }
  { mov x25, x0 }
  EmitIndent;
  WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
  WriteChar(120); WriteChar(50); WriteChar(53); WriteChar(44); WriteChar(32);  { x25, }
  WriteChar(120); WriteChar(48);  { x0 }
  EmitNL;
  { mov x26, x1 }
  EmitIndent;
  WriteChar(109); WriteChar(111); WriteChar(118); WriteChar(32);  { mov }
  WriteChar(120); WriteChar(50); WriteChar(54); WriteChar(44); WriteChar(32);  { x26, }
  WriteChar(120); WriteChar(49);  { x1 }
  EmitNL;

  EmitFileOpenInit;
  EmitBL(rt_heap_init);

  { Call Unit initialization routines }
  For i := 0 To loaded_count - 1 Do
    EmitBLUnitInit(i);

  ParseBlock;

  Expect(TOK_DOT);

  { Exit syscall }
  EmitMovX0(0);
  EmitMovX16(33554433);  { 0x2000001 }
  EmitSvc
End;

{ ----- Main ----- }

Begin
  { Initialize }
  line_num := 1;
  col_num := 0;
  sym_count := 0;
  scope_level := 0;
  local_offset := 0;
  label_count := 0;
  string_count := 0;
  had_error := 0;
  rt_print_int := 0;
  rt_newline := 0;
  rt_readchar := 0;
  rt_print_char := 0;
  rt_read_int := 0;
  rt_skip_line := 0;
  rt_print_string := 0;
  rt_print_real := 0;
  rt_read_real := 0;
  rt_read_string := 0;
  rt_heap_init := 0;
  rt_str_copy := 0;
  rt_str_compare := 0;
  rt_str_concat := 0;
  string_temp_idx := 0;
  out_fd := 1;
  pushback_ch := -1;
  expr_type := TYPE_INTEGER;
  ptr_base_type := TYPE_INTEGER;
  field_count := 0;
  with_rec_idx := -1;
  with_rec_type := 0;
  break_label := 0;
  continue_label := 0;
  exit_label := 0;
  ptr_arr_count := 0;
  file_count := 0;
  enum_count := 0;
  subr_count := 0;
  set_count := 0;
  rt_alloc := 0;
  rt_free := 0;
  include_depth := 0;
  compiling_unit := 0;
  in_interface := 0;
  current_unit_len := 0;
  interface_start := 0;
  interface_end := 0;
  loaded_count := 0;
  tpu_line_len := 0;
  tpu_pos := 0;

  { Read first character And token }
  NextChar;
  NextToken;

  { Compile the Program }
  ParseProgram
End.
